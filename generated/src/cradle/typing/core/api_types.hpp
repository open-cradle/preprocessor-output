// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#ifndef THINKNODE_ACCOUNT
#define THINKNODE_ACCOUNT "mgh"
#endif
#ifndef THINKNODE_FUNCTION_APP
#define THINKNODE_FUNCTION_APP "dosimetry"
#endif
#ifndef THINKNODE_TYPES_APP
#define THINKNODE_TYPES_APP "dosimetry"
#endif









#ifdef NIL_TYPE 
    #undef NIL_TYPE 
#endif 

#ifdef BOOLEAN_TYPE 
    #undef BOOLEAN_TYPE 
#endif 

#ifdef INTEGER_TYPE 
    #undef INTEGER_TYPE 
#endif 

#ifdef FLOAT_TYPE 
    #undef FLOAT_TYPE 
#endif 

#ifdef STRING_TYPE 
    #undef STRING_TYPE 
#endif 

#ifdef DATETIME_TYPE 
    #undef DATETIME_TYPE 
#endif 

#ifdef BLOB_TYPE 
    #undef BLOB_TYPE 
#endif 

#ifdef DYNAMIC_TYPE 
    #undef DYNAMIC_TYPE 
#endif 

#ifdef STRUCTURE_TYPE 
    #undef STRUCTURE_TYPE 
#endif 

#ifdef UNION_TYPE 
    #undef UNION_TYPE 
#endif 

#ifdef ENUM_TYPE 
    #undef ENUM_TYPE 
#endif 

#ifdef MAP_TYPE 
    #undef MAP_TYPE 
#endif 

#ifdef ARRAY_TYPE 
    #undef ARRAY_TYPE 
#endif 

#ifdef OPTIONAL_TYPE 
    #undef OPTIONAL_TYPE 
#endif 

#ifdef REFERENCE_TYPE 
    #undef REFERENCE_TYPE 
#endif 

#ifdef NAMED_TYPE 
    #undef NAMED_TYPE 
#endif 

#ifdef FUNCTION_TYPE 
    #undef FUNCTION_TYPE 
#endif 

#ifdef RECORD_TYPE 
    #undef RECORD_TYPE 
#endif 

























































































#ifdef MUTATION_TYPE 
    #undef MUTATION_TYPE 
#endif 

#ifdef UPGRADE_TYPE 
    #undef UPGRADE_TYPE 
#endif 






























































#line 1 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
#ifndef CRADLE_TYPING_API_TYPES_HPP
#define CRADLE_TYPING_API_TYPES_HPP

#line 4 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
#include <cradle/inner/core/monitoring.h>
#include <cradle/typing/core/flags.h>
#include <cradle/typing/core/type_definitions.h>
#include <cradle/typing/core/upgrades.hpp>

#line 9 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
namespace cradle {

#line 11 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
struct api_nil_type;
struct api_boolean_type;
struct api_integer_type;
struct api_float_type;
struct api_string_type;
struct api_datetime_type;
struct api_blob_type;
struct api_dynamic_type;
struct api_structure_info;
struct api_union_info;
struct api_enum_info;
struct api_array_info;
struct api_map_info;
struct api_named_type_reference;
struct api_function_type_info;
struct api_record_info;
struct api_structure_field_info;


#ifdef NIL_TYPE 
    #undef NIL_TYPE 
#endif 

#ifdef BOOLEAN_TYPE 
    #undef BOOLEAN_TYPE 
#endif 

#ifdef INTEGER_TYPE 
    #undef INTEGER_TYPE 
#endif 

#ifdef FLOAT_TYPE 
    #undef FLOAT_TYPE 
#endif 

#ifdef STRING_TYPE 
    #undef STRING_TYPE 
#endif 

#ifdef DATETIME_TYPE 
    #undef DATETIME_TYPE 
#endif 

#ifdef BLOB_TYPE 
    #undef BLOB_TYPE 
#endif 

#ifdef DYNAMIC_TYPE 
    #undef DYNAMIC_TYPE 
#endif 

#ifdef STRUCTURE_TYPE 
    #undef STRUCTURE_TYPE 
#endif 

#ifdef UNION_TYPE 
    #undef UNION_TYPE 
#endif 

#ifdef ENUM_TYPE 
    #undef ENUM_TYPE 
#endif 

#ifdef MAP_TYPE 
    #undef MAP_TYPE 
#endif 

#ifdef ARRAY_TYPE 
    #undef ARRAY_TYPE 
#endif 

#ifdef OPTIONAL_TYPE 
    #undef OPTIONAL_TYPE 
#endif 

#ifdef REFERENCE_TYPE 
    #undef REFERENCE_TYPE 
#endif 

#ifdef NAMED_TYPE 
    #undef NAMED_TYPE 
#endif 

#ifdef FUNCTION_TYPE 
    #undef FUNCTION_TYPE 
#endif 

#ifdef RECORD_TYPE 
    #undef RECORD_TYPE 
#endif 
#line 29 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
enum class api_type_info_tag { NIL_TYPE,BOOLEAN_TYPE,INTEGER_TYPE,FLOAT_TYPE,STRING_TYPE,DATETIME_TYPE,BLOB_TYPE,DYNAMIC_TYPE,STRUCTURE_TYPE,UNION_TYPE,ENUM_TYPE,MAP_TYPE,ARRAY_TYPE,OPTIONAL_TYPE,REFERENCE_TYPE,NAMED_TYPE,FUNCTION_TYPE,RECORD_TYPE }; template<> struct definitive_type_info_query<api_type_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_type_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<api_type_info_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(api_type_info_tag) { return sizeof(api_type_info_tag); } inline size_t hash_value(api_type_info_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(api_type_info_tag) { return 18; } char const* get_value_id(api_type_info_tag value); void to_dynamic(     cradle::dynamic* v,     api_type_info_tag x); void from_dynamic(     api_type_info_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      api_type_info_tag const& x); struct api_type_info { api_type_info_tag type; std::any contents_; api_type_info() {} api_type_info(api_type_info const& other) : type(other.type), contents_(other.contents_) {} api_type_info(api_type_info&& other) : type(other.type), contents_(std::move(other.contents_)) {} api_type_info& operator=(api_type_info const& other) { type = other.type; contents_ = other.contents_; return *this; } api_type_info& operator=(api_type_info&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<api_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_type_info> {     static void     get(cradle::api_type_info*); }; api_type_info make_api_type_info_with_nil_type(api_nil_type const& x); api_type_info make_api_type_info_with_nil_type(api_nil_type&& x); api_type_info make_api_type_info_with_boolean_type(api_boolean_type const& x); api_type_info make_api_type_info_with_boolean_type(api_boolean_type&& x); api_type_info make_api_type_info_with_integer_type(api_integer_type const& x); api_type_info make_api_type_info_with_integer_type(api_integer_type&& x); api_type_info make_api_type_info_with_float_type(api_float_type const& x); api_type_info make_api_type_info_with_float_type(api_float_type&& x); api_type_info make_api_type_info_with_string_type(api_string_type const& x); api_type_info make_api_type_info_with_string_type(api_string_type&& x); api_type_info make_api_type_info_with_datetime_type(api_datetime_type const& x); api_type_info make_api_type_info_with_datetime_type(api_datetime_type&& x); api_type_info make_api_type_info_with_blob_type(api_blob_type const& x); api_type_info make_api_type_info_with_blob_type(api_blob_type&& x); api_type_info make_api_type_info_with_dynamic_type(api_dynamic_type const& x); api_type_info make_api_type_info_with_dynamic_type(api_dynamic_type&& x); api_type_info make_api_type_info_with_structure_type(api_structure_info const& x); api_type_info make_api_type_info_with_structure_type(api_structure_info&& x); api_type_info make_api_type_info_with_union_type(api_union_info const& x); api_type_info make_api_type_info_with_union_type(api_union_info&& x); api_type_info make_api_type_info_with_enum_type(api_enum_info const& x); api_type_info make_api_type_info_with_enum_type(api_enum_info&& x); api_type_info make_api_type_info_with_map_type(api_map_info const& x); api_type_info make_api_type_info_with_map_type(api_map_info&& x); api_type_info make_api_type_info_with_array_type(api_array_info const& x); api_type_info make_api_type_info_with_array_type(api_array_info&& x); api_type_info make_api_type_info_with_optional_type(api_type_info const& x); api_type_info make_api_type_info_with_optional_type(api_type_info&& x); api_type_info make_api_type_info_with_reference_type(api_type_info const& x); api_type_info make_api_type_info_with_reference_type(api_type_info&& x); api_type_info make_api_type_info_with_named_type(api_named_type_reference const& x); api_type_info make_api_type_info_with_named_type(api_named_type_reference&& x); api_type_info make_api_type_info_with_function_type(api_function_type_info const& x); api_type_info make_api_type_info_with_function_type(api_function_type_info&& x); api_type_info make_api_type_info_with_record_type(api_record_info const& x); api_type_info make_api_type_info_with_record_type(api_record_info&& x); static inline api_type_info_tag  get_tag(api_type_info const& x) { return x.type; } bool static inline is_nil_type(api_type_info const& x) { return x.type == api_type_info_tag::NIL_TYPE; } bool static inline is_boolean_type(api_type_info const& x) { return x.type == api_type_info_tag::BOOLEAN_TYPE; } bool static inline is_integer_type(api_type_info const& x) { return x.type == api_type_info_tag::INTEGER_TYPE; } bool static inline is_float_type(api_type_info const& x) { return x.type == api_type_info_tag::FLOAT_TYPE; } bool static inline is_string_type(api_type_info const& x) { return x.type == api_type_info_tag::STRING_TYPE; } bool static inline is_datetime_type(api_type_info const& x) { return x.type == api_type_info_tag::DATETIME_TYPE; } bool static inline is_blob_type(api_type_info const& x) { return x.type == api_type_info_tag::BLOB_TYPE; } bool static inline is_dynamic_type(api_type_info const& x) { return x.type == api_type_info_tag::DYNAMIC_TYPE; } bool static inline is_structure_type(api_type_info const& x) { return x.type == api_type_info_tag::STRUCTURE_TYPE; } bool static inline is_union_type(api_type_info const& x) { return x.type == api_type_info_tag::UNION_TYPE; } bool static inline is_enum_type(api_type_info const& x) { return x.type == api_type_info_tag::ENUM_TYPE; } bool static inline is_map_type(api_type_info const& x) { return x.type == api_type_info_tag::MAP_TYPE; } bool static inline is_array_type(api_type_info const& x) { return x.type == api_type_info_tag::ARRAY_TYPE; } bool static inline is_optional_type(api_type_info const& x) { return x.type == api_type_info_tag::OPTIONAL_TYPE; } bool static inline is_reference_type(api_type_info const& x) { return x.type == api_type_info_tag::REFERENCE_TYPE; } bool static inline is_named_type(api_type_info const& x) { return x.type == api_type_info_tag::NAMED_TYPE; } bool static inline is_function_type(api_type_info const& x) { return x.type == api_type_info_tag::FUNCTION_TYPE; } bool static inline is_record_type(api_type_info const& x) { return x.type == api_type_info_tag::RECORD_TYPE; } api_nil_type const& as_nil_type(api_type_info const& x); api_boolean_type const& as_boolean_type(api_type_info const& x); api_integer_type const& as_integer_type(api_type_info const& x); api_float_type const& as_float_type(api_type_info const& x); api_string_type const& as_string_type(api_type_info const& x); api_datetime_type const& as_datetime_type(api_type_info const& x); api_blob_type const& as_blob_type(api_type_info const& x); api_dynamic_type const& as_dynamic_type(api_type_info const& x); api_structure_info const& as_structure_type(api_type_info const& x); api_union_info const& as_union_type(api_type_info const& x); api_enum_info const& as_enum_type(api_type_info const& x); api_map_info const& as_map_type(api_type_info const& x); api_array_info const& as_array_type(api_type_info const& x); api_type_info const& as_optional_type(api_type_info const& x); api_type_info const& as_reference_type(api_type_info const& x); api_named_type_reference const& as_named_type(api_type_info const& x); api_function_type_info const& as_function_type(api_type_info const& x); api_record_info const& as_record_type(api_type_info const& x); api_nil_type& as_nil_type(api_type_info& x); api_boolean_type& as_boolean_type(api_type_info& x); api_integer_type& as_integer_type(api_type_info& x); api_float_type& as_float_type(api_type_info& x); api_string_type& as_string_type(api_type_info& x); api_datetime_type& as_datetime_type(api_type_info& x); api_blob_type& as_blob_type(api_type_info& x); api_dynamic_type& as_dynamic_type(api_type_info& x); api_structure_info& as_structure_type(api_type_info& x); api_union_info& as_union_type(api_type_info& x); api_enum_info& as_enum_type(api_type_info& x); api_map_info& as_map_type(api_type_info& x); api_array_info& as_array_type(api_type_info& x); api_type_info& as_optional_type(api_type_info& x); api_type_info& as_reference_type(api_type_info& x); api_named_type_reference& as_named_type(api_type_info& x); api_function_type_info& as_function_type(api_type_info& x); api_record_info& as_record_type(api_type_info& x); void set_to_nil_type(api_type_info& x, api_nil_type const& y); void set_to_nil_type(api_type_info& x, api_nil_type&& y); void set_to_boolean_type(api_type_info& x, api_boolean_type const& y); void set_to_boolean_type(api_type_info& x, api_boolean_type&& y); void set_to_integer_type(api_type_info& x, api_integer_type const& y); void set_to_integer_type(api_type_info& x, api_integer_type&& y); void set_to_float_type(api_type_info& x, api_float_type const& y); void set_to_float_type(api_type_info& x, api_float_type&& y); void set_to_string_type(api_type_info& x, api_string_type const& y); void set_to_string_type(api_type_info& x, api_string_type&& y); void set_to_datetime_type(api_type_info& x, api_datetime_type const& y); void set_to_datetime_type(api_type_info& x, api_datetime_type&& y); void set_to_blob_type(api_type_info& x, api_blob_type const& y); void set_to_blob_type(api_type_info& x, api_blob_type&& y); void set_to_dynamic_type(api_type_info& x, api_dynamic_type const& y); void set_to_dynamic_type(api_type_info& x, api_dynamic_type&& y); void set_to_structure_type(api_type_info& x, api_structure_info const& y); void set_to_structure_type(api_type_info& x, api_structure_info&& y); void set_to_union_type(api_type_info& x, api_union_info const& y); void set_to_union_type(api_type_info& x, api_union_info&& y); void set_to_enum_type(api_type_info& x, api_enum_info const& y); void set_to_enum_type(api_type_info& x, api_enum_info&& y); void set_to_map_type(api_type_info& x, api_map_info const& y); void set_to_map_type(api_type_info& x, api_map_info&& y); void set_to_array_type(api_type_info& x, api_array_info const& y); void set_to_array_type(api_type_info& x, api_array_info&& y); void set_to_optional_type(api_type_info& x, api_type_info const& y); void set_to_optional_type(api_type_info& x, api_type_info&& y); void set_to_reference_type(api_type_info& x, api_type_info const& y); void set_to_reference_type(api_type_info& x, api_type_info&& y); void set_to_named_type(api_type_info& x, api_named_type_reference const& y); void set_to_named_type(api_type_info& x, api_named_type_reference&& y); void set_to_function_type(api_type_info& x, api_function_type_info const& y); void set_to_function_type(api_type_info& x, api_function_type_info&& y); void set_to_record_type(api_type_info& x, api_record_info const& y); void set_to_record_type(api_type_info& x, api_record_info&& y); bool operator==(api_type_info const& a, api_type_info const& b); bool operator!=(api_type_info const& a, api_type_info const& b); bool operator<(api_type_info const& a, api_type_info const& b); size_t hash_value(api_type_info const& x);void swap(api_type_info& a, api_type_info& b); void to_dynamic(cradle::dynamic* v, api_type_info const& x); void from_dynamic(api_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_type_info const& x); size_t deep_sizeof(api_type_info const& x); 

#line 52 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_nil_type {  api_nil_type() {} };  inline api_nil_type make_api_nil_type(   ) { return api_nil_type(   ); }template<> struct definitive_type_info_query<api_nil_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_nil_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_nil_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_nil_type const& a, api_nil_type const& b); bool operator!=(api_nil_type const& a, api_nil_type const& b); bool operator<(api_nil_type const& a, api_nil_type const& b); void swap(api_nil_type& a, api_nil_type& b); size_t deep_sizeof(api_nil_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_nil_type const& x); void to_dynamic(cradle::dynamic* v, api_nil_type const& x); void read_fields_from_record(api_nil_type& x, cradle::dynamic_map const& record); void from_dynamic(api_nil_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_nil_type const& x);std::ostream& operator<<(std::ostream& s, api_nil_type const& x);size_t hash_value(api_nil_type const& x);} namespace cradle { 

#line 57 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_boolean_type {  api_boolean_type() {} };  inline api_boolean_type make_api_boolean_type(   ) { return api_boolean_type(   ); }template<> struct definitive_type_info_query<api_boolean_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_boolean_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_boolean_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_boolean_type const& a, api_boolean_type const& b); bool operator!=(api_boolean_type const& a, api_boolean_type const& b); bool operator<(api_boolean_type const& a, api_boolean_type const& b); void swap(api_boolean_type& a, api_boolean_type& b); size_t deep_sizeof(api_boolean_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_boolean_type const& x); void to_dynamic(cradle::dynamic* v, api_boolean_type const& x); void read_fields_from_record(api_boolean_type& x, cradle::dynamic_map const& record); void from_dynamic(api_boolean_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_boolean_type const& x);std::ostream& operator<<(std::ostream& s, api_boolean_type const& x);size_t hash_value(api_boolean_type const& x);} namespace cradle { 

#line 62 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_integer_type {  api_integer_type() {} };  inline api_integer_type make_api_integer_type(   ) { return api_integer_type(   ); }template<> struct definitive_type_info_query<api_integer_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_integer_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_integer_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_integer_type const& a, api_integer_type const& b); bool operator!=(api_integer_type const& a, api_integer_type const& b); bool operator<(api_integer_type const& a, api_integer_type const& b); void swap(api_integer_type& a, api_integer_type& b); size_t deep_sizeof(api_integer_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_integer_type const& x); void to_dynamic(cradle::dynamic* v, api_integer_type const& x); void read_fields_from_record(api_integer_type& x, cradle::dynamic_map const& record); void from_dynamic(api_integer_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_integer_type const& x);std::ostream& operator<<(std::ostream& s, api_integer_type const& x);size_t hash_value(api_integer_type const& x);} namespace cradle { 

#line 67 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_float_type {  api_float_type() {} };  inline api_float_type make_api_float_type(   ) { return api_float_type(   ); }template<> struct definitive_type_info_query<api_float_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_float_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_float_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_float_type const& a, api_float_type const& b); bool operator!=(api_float_type const& a, api_float_type const& b); bool operator<(api_float_type const& a, api_float_type const& b); void swap(api_float_type& a, api_float_type& b); size_t deep_sizeof(api_float_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_float_type const& x); void to_dynamic(cradle::dynamic* v, api_float_type const& x); void read_fields_from_record(api_float_type& x, cradle::dynamic_map const& record); void from_dynamic(api_float_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_float_type const& x);std::ostream& operator<<(std::ostream& s, api_float_type const& x);size_t hash_value(api_float_type const& x);} namespace cradle { 

#line 72 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_string_type {  api_string_type() {} };  inline api_string_type make_api_string_type(   ) { return api_string_type(   ); }template<> struct definitive_type_info_query<api_string_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_string_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_string_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_string_type const& a, api_string_type const& b); bool operator!=(api_string_type const& a, api_string_type const& b); bool operator<(api_string_type const& a, api_string_type const& b); void swap(api_string_type& a, api_string_type& b); size_t deep_sizeof(api_string_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_string_type const& x); void to_dynamic(cradle::dynamic* v, api_string_type const& x); void read_fields_from_record(api_string_type& x, cradle::dynamic_map const& record); void from_dynamic(api_string_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_string_type const& x);std::ostream& operator<<(std::ostream& s, api_string_type const& x);size_t hash_value(api_string_type const& x);} namespace cradle { 

#line 77 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_datetime_type {  api_datetime_type() {} };  inline api_datetime_type make_api_datetime_type(   ) { return api_datetime_type(   ); }template<> struct definitive_type_info_query<api_datetime_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_datetime_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_datetime_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_datetime_type const& a, api_datetime_type const& b); bool operator!=(api_datetime_type const& a, api_datetime_type const& b); bool operator<(api_datetime_type const& a, api_datetime_type const& b); void swap(api_datetime_type& a, api_datetime_type& b); size_t deep_sizeof(api_datetime_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_datetime_type const& x); void to_dynamic(cradle::dynamic* v, api_datetime_type const& x); void read_fields_from_record(api_datetime_type& x, cradle::dynamic_map const& record); void from_dynamic(api_datetime_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_datetime_type const& x);std::ostream& operator<<(std::ostream& s, api_datetime_type const& x);size_t hash_value(api_datetime_type const& x);} namespace cradle { 

#line 82 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_blob_type {  api_blob_type() {} };  inline api_blob_type make_api_blob_type(   ) { return api_blob_type(   ); }template<> struct definitive_type_info_query<api_blob_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_blob_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_blob_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_blob_type const& a, api_blob_type const& b); bool operator!=(api_blob_type const& a, api_blob_type const& b); bool operator<(api_blob_type const& a, api_blob_type const& b); void swap(api_blob_type& a, api_blob_type& b); size_t deep_sizeof(api_blob_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_blob_type const& x); void to_dynamic(cradle::dynamic* v, api_blob_type const& x); void read_fields_from_record(api_blob_type& x, cradle::dynamic_map const& record); void from_dynamic(api_blob_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_blob_type const& x);std::ostream& operator<<(std::ostream& s, api_blob_type const& x);size_t hash_value(api_blob_type const& x);} namespace cradle { 

#line 87 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_dynamic_type {  api_dynamic_type() {} };  inline api_dynamic_type make_api_dynamic_type(   ) { return api_dynamic_type(   ); }template<> struct definitive_type_info_query<api_dynamic_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_dynamic_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_dynamic_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_dynamic_type const& a, api_dynamic_type const& b); bool operator!=(api_dynamic_type const& a, api_dynamic_type const& b); bool operator<(api_dynamic_type const& a, api_dynamic_type const& b); void swap(api_dynamic_type& a, api_dynamic_type& b); size_t deep_sizeof(api_dynamic_type const& x); void write_fields_to_record(cradle::dynamic_map& record, api_dynamic_type const& x); void to_dynamic(cradle::dynamic* v, api_dynamic_type const& x); void read_fields_from_record(api_dynamic_type& x, cradle::dynamic_map const& record); void from_dynamic(api_dynamic_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_dynamic_type const& x);std::ostream& operator<<(std::ostream& s, api_dynamic_type const& x);size_t hash_value(api_dynamic_type const& x);} namespace cradle { 

#line 92 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_structure_field_info { string description;  api_type_info schema;  cradle::omissible<bool > omissible;  api_structure_field_info() {} api_structure_field_info(string const& description, api_type_info const& schema, cradle::omissible<bool > const& omissible) : description(description), schema(schema), omissible(omissible) {} };  inline api_structure_field_info make_api_structure_field_info(  string description, api_type_info schema, cradle::omissible<bool > omissible ) { return api_structure_field_info(  std::move(description), std::move(schema), std::move(omissible) ); }template<> struct definitive_type_info_query<api_structure_field_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_structure_field_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_structure_field_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_structure_field_info const& a, api_structure_field_info const& b); bool operator!=(api_structure_field_info const& a, api_structure_field_info const& b); bool operator<(api_structure_field_info const& a, api_structure_field_info const& b); void swap(api_structure_field_info& a, api_structure_field_info& b); size_t deep_sizeof(api_structure_field_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_structure_field_info const& x); void to_dynamic(cradle::dynamic* v, api_structure_field_info const& x); void read_fields_from_record(api_structure_field_info& x, cradle::dynamic_map const& record); void from_dynamic(api_structure_field_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_structure_field_info const& x);std::ostream& operator<<(std::ostream& s, api_structure_field_info const& x);size_t hash_value(api_structure_field_info const& x);} namespace cradle { 

#line 100 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_structure_info { std::map<string,api_structure_field_info > fields;  api_structure_info() {} explicit api_structure_info(std::map<string,api_structure_field_info > const& fields) : fields(fields) {} };  inline api_structure_info make_api_structure_info(  std::map<string,api_structure_field_info > fields ) { return api_structure_info(  std::move(fields) ); }template<> struct definitive_type_info_query<api_structure_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_structure_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_structure_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_structure_info const& a, api_structure_info const& b); bool operator!=(api_structure_info const& a, api_structure_info const& b); bool operator<(api_structure_info const& a, api_structure_info const& b); void swap(api_structure_info& a, api_structure_info& b); size_t deep_sizeof(api_structure_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_structure_info const& x); void to_dynamic(cradle::dynamic* v, api_structure_info const& x); void read_fields_from_record(api_structure_info& x, cradle::dynamic_map const& record); void from_dynamic(api_structure_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_structure_info const& x);std::ostream& operator<<(std::ostream& s, api_structure_info const& x);size_t hash_value(api_structure_info const& x);} namespace cradle { 

#line 106 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_union_member_info { string description;  api_type_info schema;  api_union_member_info() {} api_union_member_info(string const& description, api_type_info const& schema) : description(description), schema(schema) {} };  inline api_union_member_info make_api_union_member_info(  string description, api_type_info schema ) { return api_union_member_info(  std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<api_union_member_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_union_member_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_union_member_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_union_member_info const& a, api_union_member_info const& b); bool operator!=(api_union_member_info const& a, api_union_member_info const& b); bool operator<(api_union_member_info const& a, api_union_member_info const& b); void swap(api_union_member_info& a, api_union_member_info& b); size_t deep_sizeof(api_union_member_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_union_member_info const& x); void to_dynamic(cradle::dynamic* v, api_union_member_info const& x); void read_fields_from_record(api_union_member_info& x, cradle::dynamic_map const& record); void from_dynamic(api_union_member_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_union_member_info const& x);std::ostream& operator<<(std::ostream& s, api_union_member_info const& x);size_t hash_value(api_union_member_info const& x);} namespace cradle { 

#line 113 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_union_info { std::map<string,api_union_member_info > members;  api_union_info() {} explicit api_union_info(std::map<string,api_union_member_info > const& members) : members(members) {} };  inline api_union_info make_api_union_info(  std::map<string,api_union_member_info > members ) { return api_union_info(  std::move(members) ); }template<> struct definitive_type_info_query<api_union_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_union_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_union_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_union_info const& a, api_union_info const& b); bool operator!=(api_union_info const& a, api_union_info const& b); bool operator<(api_union_info const& a, api_union_info const& b); void swap(api_union_info& a, api_union_info& b); size_t deep_sizeof(api_union_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_union_info const& x); void to_dynamic(cradle::dynamic* v, api_union_info const& x); void read_fields_from_record(api_union_info& x, cradle::dynamic_map const& record); void from_dynamic(api_union_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_union_info const& x);std::ostream& operator<<(std::ostream& s, api_union_info const& x);size_t hash_value(api_union_info const& x);} namespace cradle { 

#line 119 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_enum_value_info { string description;  api_enum_value_info() {} explicit api_enum_value_info(string const& description) : description(description) {} };  inline api_enum_value_info make_api_enum_value_info(  string description ) { return api_enum_value_info(  std::move(description) ); }template<> struct definitive_type_info_query<api_enum_value_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_enum_value_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_enum_value_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_enum_value_info const& a, api_enum_value_info const& b); bool operator!=(api_enum_value_info const& a, api_enum_value_info const& b); bool operator<(api_enum_value_info const& a, api_enum_value_info const& b); void swap(api_enum_value_info& a, api_enum_value_info& b); size_t deep_sizeof(api_enum_value_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_enum_value_info const& x); void to_dynamic(cradle::dynamic* v, api_enum_value_info const& x); void read_fields_from_record(api_enum_value_info& x, cradle::dynamic_map const& record); void from_dynamic(api_enum_value_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_enum_value_info const& x);std::ostream& operator<<(std::ostream& s, api_enum_value_info const& x);size_t hash_value(api_enum_value_info const& x);} namespace cradle { 

#line 125 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_enum_info { std::map<string,api_enum_value_info > values;  api_enum_info() {} explicit api_enum_info(std::map<string,api_enum_value_info > const& values) : values(values) {} };  inline api_enum_info make_api_enum_info(  std::map<string,api_enum_value_info > values ) { return api_enum_info(  std::move(values) ); }template<> struct definitive_type_info_query<api_enum_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_enum_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_enum_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_enum_info const& a, api_enum_info const& b); bool operator!=(api_enum_info const& a, api_enum_info const& b); bool operator<(api_enum_info const& a, api_enum_info const& b); void swap(api_enum_info& a, api_enum_info& b); size_t deep_sizeof(api_enum_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_enum_info const& x); void to_dynamic(cradle::dynamic* v, api_enum_info const& x); void read_fields_from_record(api_enum_info& x, cradle::dynamic_map const& record); void from_dynamic(api_enum_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_enum_info const& x);std::ostream& operator<<(std::ostream& s, api_enum_info const& x);size_t hash_value(api_enum_info const& x);} namespace cradle { 

#line 131 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_array_info { omissible<integer > size;  api_type_info element_schema;  api_array_info() {} api_array_info(omissible<integer > const& size, api_type_info const& element_schema) : size(size), element_schema(element_schema) {} };  inline api_array_info make_api_array_info(  omissible<integer > size, api_type_info element_schema ) { return api_array_info(  std::move(size), std::move(element_schema) ); }template<> struct definitive_type_info_query<api_array_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_array_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_array_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_array_info const& a, api_array_info const& b); bool operator!=(api_array_info const& a, api_array_info const& b); bool operator<(api_array_info const& a, api_array_info const& b); void swap(api_array_info& a, api_array_info& b); size_t deep_sizeof(api_array_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_array_info const& x); void to_dynamic(cradle::dynamic* v, api_array_info const& x); void read_fields_from_record(api_array_info& x, cradle::dynamic_map const& record); void from_dynamic(api_array_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_array_info const& x);std::ostream& operator<<(std::ostream& s, api_array_info const& x);size_t hash_value(api_array_info const& x);} namespace cradle { 

#line 139 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_map_info { api_type_info key_schema;  api_type_info value_schema;  api_map_info() {} api_map_info(api_type_info const& key_schema, api_type_info const& value_schema) : key_schema(key_schema), value_schema(value_schema) {} };  inline api_map_info make_api_map_info(  api_type_info key_schema, api_type_info value_schema ) { return api_map_info(  std::move(key_schema), std::move(value_schema) ); }template<> struct definitive_type_info_query<api_map_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_map_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_map_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_map_info const& a, api_map_info const& b); bool operator!=(api_map_info const& a, api_map_info const& b); bool operator<(api_map_info const& a, api_map_info const& b); void swap(api_map_info& a, api_map_info& b); size_t deep_sizeof(api_map_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_map_info const& x); void to_dynamic(cradle::dynamic* v, api_map_info const& x); void read_fields_from_record(api_map_info& x, cradle::dynamic_map const& record); void from_dynamic(api_map_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_map_info const& x);std::ostream& operator<<(std::ostream& s, api_map_info const& x);size_t hash_value(api_map_info const& x);} namespace cradle { 

#line 145 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_named_type_reference { string app;  string name;  api_named_type_reference() {} api_named_type_reference(string const& app, string const& name) : app(app), name(name) {} };  inline api_named_type_reference make_api_named_type_reference(  string app, string name ) { return api_named_type_reference(  std::move(app), std::move(name) ); }template<> struct definitive_type_info_query<api_named_type_reference> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_named_type_reference> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_named_type_reference> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_named_type_reference const& a, api_named_type_reference const& b); bool operator!=(api_named_type_reference const& a, api_named_type_reference const& b); bool operator<(api_named_type_reference const& a, api_named_type_reference const& b); void swap(api_named_type_reference& a, api_named_type_reference& b); size_t deep_sizeof(api_named_type_reference const& x); void write_fields_to_record(cradle::dynamic_map& record, api_named_type_reference const& x); void to_dynamic(cradle::dynamic* v, api_named_type_reference const& x); void read_fields_from_record(api_named_type_reference& x, cradle::dynamic_map const& record); void from_dynamic(api_named_type_reference* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_named_type_reference const& x);std::ostream& operator<<(std::ostream& s, api_named_type_reference const& x);size_t hash_value(api_named_type_reference const& x);} namespace cradle { 

#line 152 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_record_type_info { api_type_info schema;  api_record_type_info() {} explicit api_record_type_info(api_type_info const& schema) : schema(schema) {} };  inline api_record_type_info make_api_record_type_info(  api_type_info schema ) { return api_record_type_info(  std::move(schema) ); }template<> struct definitive_type_info_query<api_record_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_record_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_record_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_record_type_info const& a, api_record_type_info const& b); bool operator!=(api_record_type_info const& a, api_record_type_info const& b); bool operator<(api_record_type_info const& a, api_record_type_info const& b); void swap(api_record_type_info& a, api_record_type_info& b); size_t deep_sizeof(api_record_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_record_type_info const& x); void to_dynamic(cradle::dynamic* v, api_record_type_info const& x); void read_fields_from_record(api_record_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_record_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_record_type_info const& x);std::ostream& operator<<(std::ostream& s, api_record_type_info const& x);size_t hash_value(api_record_type_info const& x);} namespace cradle { 

#line 158 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_function_parameter_info { string name;  api_type_info schema;  string description;  api_function_parameter_info() {} api_function_parameter_info(string const& name, api_type_info const& schema, string const& description) : name(name), schema(schema), description(description) {} };  inline api_function_parameter_info make_api_function_parameter_info(  string name, api_type_info schema, string description ) { return api_function_parameter_info(  std::move(name), std::move(schema), std::move(description) ); }template<> struct definitive_type_info_query<api_function_parameter_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_function_parameter_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_function_parameter_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_function_parameter_info const& a, api_function_parameter_info const& b); bool operator!=(api_function_parameter_info const& a, api_function_parameter_info const& b); bool operator<(api_function_parameter_info const& a, api_function_parameter_info const& b); void swap(api_function_parameter_info& a, api_function_parameter_info& b); size_t deep_sizeof(api_function_parameter_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_function_parameter_info const& x); void to_dynamic(cradle::dynamic* v, api_function_parameter_info const& x); void read_fields_from_record(api_function_parameter_info& x, cradle::dynamic_map const& record); void from_dynamic(api_function_parameter_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_function_parameter_info const& x);std::ostream& operator<<(std::ostream& s, api_function_parameter_info const& x);size_t hash_value(api_function_parameter_info const& x);} namespace cradle { 

#line 166 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_function_result_info { api_type_info schema;  string description;  api_function_result_info() {} api_function_result_info(api_type_info const& schema, string const& description) : schema(schema), description(description) {} };  inline api_function_result_info make_api_function_result_info(  api_type_info schema, string description ) { return api_function_result_info(  std::move(schema), std::move(description) ); }template<> struct definitive_type_info_query<api_function_result_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_function_result_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_function_result_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_function_result_info const& a, api_function_result_info const& b); bool operator!=(api_function_result_info const& a, api_function_result_info const& b); bool operator<(api_function_result_info const& a, api_function_result_info const& b); void swap(api_function_result_info& a, api_function_result_info& b); size_t deep_sizeof(api_function_result_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_function_result_info const& x); void to_dynamic(cradle::dynamic* v, api_function_result_info const& x); void read_fields_from_record(api_function_result_info& x, cradle::dynamic_map const& record); void from_dynamic(api_function_result_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_function_result_info const& x);std::ostream& operator<<(std::ostream& s, api_function_result_info const& x);size_t hash_value(api_function_result_info const& x);} namespace cradle { 

#line 173 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_function_type_info { std::vector<api_function_parameter_info > parameters;  api_function_result_info returns;  api_function_type_info() {} api_function_type_info(std::vector<api_function_parameter_info > const& parameters, api_function_result_info const& returns) : parameters(parameters), returns(returns) {} };  inline api_function_type_info make_api_function_type_info(  std::vector<api_function_parameter_info > parameters, api_function_result_info returns ) { return api_function_type_info(  std::move(parameters), std::move(returns) ); }template<> struct definitive_type_info_query<api_function_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_function_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_function_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_function_type_info const& a, api_function_type_info const& b); bool operator!=(api_function_type_info const& a, api_function_type_info const& b); bool operator<(api_function_type_info const& a, api_function_type_info const& b); void swap(api_function_type_info& a, api_function_type_info& b); size_t deep_sizeof(api_function_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_function_type_info const& x); void to_dynamic(cradle::dynamic* v, api_function_type_info const& x); void read_fields_from_record(api_function_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_function_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_function_type_info const& x);std::ostream& operator<<(std::ostream& s, api_function_type_info const& x);size_t hash_value(api_function_type_info const& x);} namespace cradle { 

#line 180 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_function_upgrade_type_info { string version;  string type;  string function;  api_function_upgrade_type_info() {} api_function_upgrade_type_info(string const& version, string const& type, string const& function) : version(version), type(type), function(function) {} };  inline api_function_upgrade_type_info make_api_function_upgrade_type_info(  string version, string type, string function ) { return api_function_upgrade_type_info(  std::move(version), std::move(type), std::move(function) ); }template<> struct definitive_type_info_query<api_function_upgrade_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_function_upgrade_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_function_upgrade_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_function_upgrade_type_info const& a, api_function_upgrade_type_info const& b); bool operator!=(api_function_upgrade_type_info const& a, api_function_upgrade_type_info const& b); bool operator<(api_function_upgrade_type_info const& a, api_function_upgrade_type_info const& b); void swap(api_function_upgrade_type_info& a, api_function_upgrade_type_info& b); size_t deep_sizeof(api_function_upgrade_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_function_upgrade_type_info const& x); void to_dynamic(cradle::dynamic* v, api_function_upgrade_type_info const& x); void read_fields_from_record(api_function_upgrade_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_function_upgrade_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_function_upgrade_type_info const& x);std::ostream& operator<<(std::ostream& s, api_function_upgrade_type_info const& x);size_t hash_value(api_function_upgrade_type_info const& x);} namespace cradle { 

#line 186 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_function_info { string name;  string description;  string execution_class;  api_type_info schema;  api_function_info() {} api_function_info(string const& name, string const& description, string const& execution_class, api_type_info const& schema) : name(name), description(description), execution_class(execution_class), schema(schema) {} };  inline api_function_info make_api_function_info(  string name, string description, string execution_class, api_type_info schema ) { return api_function_info(  std::move(name), std::move(description), std::move(execution_class), std::move(schema) ); }template<> struct definitive_type_info_query<api_function_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_function_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_function_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_function_info const& a, api_function_info const& b); bool operator!=(api_function_info const& a, api_function_info const& b); bool operator<(api_function_info const& a, api_function_info const& b); void swap(api_function_info& a, api_function_info& b); size_t deep_sizeof(api_function_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_function_info const& x); void to_dynamic(cradle::dynamic* v, api_function_info const& x); void read_fields_from_record(api_function_info& x, cradle::dynamic_map const& record); void from_dynamic(api_function_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_function_info const& x);std::ostream& operator<<(std::ostream& s, api_function_info const& x);size_t hash_value(api_function_info const& x);} namespace cradle { 

#line 196 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_upgrade_function_info { string version;  string type;  string function;  api_upgrade_function_info() {} api_upgrade_function_info(string const& version, string const& type, string const& function) : version(version), type(type), function(function) {} };  inline api_upgrade_function_info make_api_upgrade_function_info(  string version, string type, string function ) { return api_upgrade_function_info(  std::move(version), std::move(type), std::move(function) ); }template<> struct definitive_type_info_query<api_upgrade_function_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_upgrade_function_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_upgrade_function_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_upgrade_function_info const& a, api_upgrade_function_info const& b); bool operator!=(api_upgrade_function_info const& a, api_upgrade_function_info const& b); bool operator<(api_upgrade_function_info const& a, api_upgrade_function_info const& b); void swap(api_upgrade_function_info& a, api_upgrade_function_info& b); size_t deep_sizeof(api_upgrade_function_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_upgrade_function_info const& x); void to_dynamic(cradle::dynamic* v, api_upgrade_function_info const& x); void read_fields_from_record(api_upgrade_function_info& x, cradle::dynamic_map const& record); void from_dynamic(api_upgrade_function_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_upgrade_function_info const& x);std::ostream& operator<<(std::ostream& s, api_upgrade_function_info const& x);size_t hash_value(api_upgrade_function_info const& x);} namespace cradle { 

#line 202 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
CRADLE_DEFINE_FLAG_TYPE(api_function)

#line 204 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
struct api_function_implementation_info
{
    string account_id;
    string app_id;
    api_function_flag_set flags;
    string uid;
    string upgrade_version;
    int level;
};

#line 214 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// api_function_interface defines the run-time interface to a C++ function
// that's necessary to provide documentation and make it available for
// external invocation (e.g., over a network or via a scripting language).
struct api_function_interface
{
    virtual ~api_function_interface()
    {
    }

    api_function_info api_info;
    api_function_implementation_info implementation_info;

    virtual dynamic
    execute(
        check_in_interface& check_in,
        progress_reporter_interface& reporter,
        dynamic_array const& args) const
        = 0;
    virtual dynamic
    execute(
        check_in_interface& check_in,
        progress_reporter_interface& reporter,
        dynamic_map const& args) const
        = 0;
    virtual untyped_immutable
    execute(
        check_in_interface& check_in,
        progress_reporter_interface& reporter,
        std::vector<untyped_immutable> const& args) const
        = 0;
};

#line 246 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// If this flag is set, the function will actually use the check in and
// progress reporting interfaces.
CRADLE_DEFINE_FLAG(api_function, 0x0001, FUNCTION_HAS_MONITORING)

#line 250 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
static inline bool
has_monitor(api_function_interface const& f)
{
    return f.implementation_info.flags & FUNCTION_HAS_MONITORING;
}

#line 256 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// If this flag is set, the function is marked as trivial and won't be
// dispatched to a separate thread.
CRADLE_DEFINE_FLAG(api_function, 0x0002, FUNCTION_IS_TRIVIAL)

#line 260 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
static inline bool
is_trivial(api_function_interface const& f)
{
    return f.implementation_info.flags & FUNCTION_IS_TRIVIAL;
}

#line 266 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// If this flag is set, the function is only available remotely.
CRADLE_DEFINE_FLAG(api_function, 0x0004, FUNCTION_IS_REMOTE)

#line 269 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
static inline bool
is_remote(api_function_interface const& f)
{
    return f.implementation_info.flags & FUNCTION_IS_REMOTE;
}

#line 275 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// If this flag is set, results from the function are cached to disk.
CRADLE_DEFINE_FLAG(api_function, 0x0008, FUNCTION_IS_DISK_CACHED)

#line 278 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
static inline bool
is_disk_cached(api_function_interface const& f)
{
    return f.implementation_info.flags & FUNCTION_IS_DISK_CACHED;
}

#line 284 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// If this flag is set, this function is an upgrade function.
CRADLE_DEFINE_FLAG(api_function, 0x0010, FUNCTION_IS_UPGRADE)

#line 287 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
static inline bool
is_upgrade(api_function_implementation_info const& f)
{
    return (f.flags & FUNCTION_IS_UPGRADE) && f.upgrade_version != "0.0.0";
}

#line 293 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// If this flag is set, the progress of this function should be reported to
// the user.
CRADLE_DEFINE_FLAG(api_function, 0x0020, FUNCTION_IS_REPORTED)

#line 297 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
static inline bool
is_reported(api_function_interface const& f)
{
    return f.implementation_info.flags & FUNCTION_IS_REPORTED;
}

#line 303 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
typedef std::shared_ptr<api_function_interface> api_function_ptr;

#line 305 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_named_type_info { string name;  string description;  api_type_info schema;  api_named_type_info() {} api_named_type_info(string const& name, string const& description, api_type_info const& schema) : name(name), description(description), schema(schema) {} };  inline api_named_type_info make_api_named_type_info(  string name, string description, api_type_info schema ) { return api_named_type_info(  std::move(name), std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<api_named_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_named_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_named_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_named_type_info const& a, api_named_type_info const& b); bool operator!=(api_named_type_info const& a, api_named_type_info const& b); bool operator<(api_named_type_info const& a, api_named_type_info const& b); void swap(api_named_type_info& a, api_named_type_info& b); size_t deep_sizeof(api_named_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_named_type_info const& x); void to_dynamic(cradle::dynamic* v, api_named_type_info const& x); void read_fields_from_record(api_named_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_named_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_named_type_info const& x);std::ostream& operator<<(std::ostream& s, api_named_type_info const& x);size_t hash_value(api_named_type_info const& x);} namespace cradle { 

#line 313 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_named_type_implementation_info { string name;  string description;  upgrade_type upgrade;  api_type_info schema;  api_named_type_implementation_info() {} api_named_type_implementation_info(string const& name, string const& description, upgrade_type const& upgrade, api_type_info const& schema) : name(name), description(description), upgrade(upgrade), schema(schema) {} };  inline api_named_type_implementation_info make_api_named_type_implementation_info(  string name, string description, upgrade_type upgrade, api_type_info schema ) { return api_named_type_implementation_info(  std::move(name), std::move(description), std::move(upgrade), std::move(schema) ); }template<> struct definitive_type_info_query<api_named_type_implementation_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_named_type_implementation_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_named_type_implementation_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_named_type_implementation_info const& a, api_named_type_implementation_info const& b); bool operator!=(api_named_type_implementation_info const& a, api_named_type_implementation_info const& b); bool operator<(api_named_type_implementation_info const& a, api_named_type_implementation_info const& b); void swap(api_named_type_implementation_info& a, api_named_type_implementation_info& b); size_t deep_sizeof(api_named_type_implementation_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_named_type_implementation_info const& x); void to_dynamic(cradle::dynamic* v, api_named_type_implementation_info const& x); void read_fields_from_record(api_named_type_implementation_info& x, cradle::dynamic_map const& record); void from_dynamic(api_named_type_implementation_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_named_type_implementation_info const& x);std::ostream& operator<<(std::ostream& s, api_named_type_implementation_info const& x);size_t hash_value(api_named_type_implementation_info const& x);} namespace cradle { 

#line 322 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_mutation_type_info { string version;  string type;  string body;  api_mutation_type_info() {} api_mutation_type_info(string const& version, string const& type, string const& body) : version(version), type(type), body(body) {} };  inline api_mutation_type_info make_api_mutation_type_info(  string version, string type, string body ) { return api_mutation_type_info(  std::move(version), std::move(type), std::move(body) ); }template<> struct definitive_type_info_query<api_mutation_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_mutation_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_mutation_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_mutation_type_info const& a, api_mutation_type_info const& b); bool operator!=(api_mutation_type_info const& a, api_mutation_type_info const& b); bool operator<(api_mutation_type_info const& a, api_mutation_type_info const& b); void swap(api_mutation_type_info& a, api_mutation_type_info& b); size_t deep_sizeof(api_mutation_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_mutation_type_info const& x); void to_dynamic(cradle::dynamic* v, api_mutation_type_info const& x); void read_fields_from_record(api_mutation_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_mutation_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_mutation_type_info const& x);std::ostream& operator<<(std::ostream& s, api_mutation_type_info const& x);size_t hash_value(api_mutation_type_info const& x);} namespace cradle { 


#ifdef MUTATION_TYPE 
    #undef MUTATION_TYPE 
#endif 

#ifdef UPGRADE_TYPE 
    #undef UPGRADE_TYPE 
#endif 
#line 330 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
enum class upgrade_type_info_tag { MUTATION_TYPE,UPGRADE_TYPE }; template<> struct definitive_type_info_query<upgrade_type_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<upgrade_type_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<upgrade_type_info_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(upgrade_type_info_tag) { return sizeof(upgrade_type_info_tag); } inline size_t hash_value(upgrade_type_info_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(upgrade_type_info_tag) { return 2; } char const* get_value_id(upgrade_type_info_tag value); void to_dynamic(     cradle::dynamic* v,     upgrade_type_info_tag x); void from_dynamic(     upgrade_type_info_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      upgrade_type_info_tag const& x); struct upgrade_type_info { upgrade_type_info_tag type; std::any contents_; upgrade_type_info() {} upgrade_type_info(upgrade_type_info const& other) : type(other.type), contents_(other.contents_) {} upgrade_type_info(upgrade_type_info&& other) : type(other.type), contents_(std::move(other.contents_)) {} upgrade_type_info& operator=(upgrade_type_info const& other) { type = other.type; contents_ = other.contents_; return *this; } upgrade_type_info& operator=(upgrade_type_info&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<upgrade_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<upgrade_type_info> {     static void     get(cradle::api_type_info*); }; upgrade_type_info make_upgrade_type_info_with_mutation_type(dynamic const& x); upgrade_type_info make_upgrade_type_info_with_mutation_type(dynamic&& x); upgrade_type_info make_upgrade_type_info_with_upgrade_type(api_upgrade_function_info const& x); upgrade_type_info make_upgrade_type_info_with_upgrade_type(api_upgrade_function_info&& x); static inline upgrade_type_info_tag  get_tag(upgrade_type_info const& x) { return x.type; } bool static inline is_mutation_type(upgrade_type_info const& x) { return x.type == upgrade_type_info_tag::MUTATION_TYPE; } bool static inline is_upgrade_type(upgrade_type_info const& x) { return x.type == upgrade_type_info_tag::UPGRADE_TYPE; } dynamic const& as_mutation_type(upgrade_type_info const& x); api_upgrade_function_info const& as_upgrade_type(upgrade_type_info const& x); dynamic& as_mutation_type(upgrade_type_info& x); api_upgrade_function_info& as_upgrade_type(upgrade_type_info& x); void set_to_mutation_type(upgrade_type_info& x, dynamic const& y); void set_to_mutation_type(upgrade_type_info& x, dynamic&& y); void set_to_upgrade_type(upgrade_type_info& x, api_upgrade_function_info const& y); void set_to_upgrade_type(upgrade_type_info& x, api_upgrade_function_info&& y); bool operator==(upgrade_type_info const& a, upgrade_type_info const& b); bool operator!=(upgrade_type_info const& a, upgrade_type_info const& b); bool operator<(upgrade_type_info const& a, upgrade_type_info const& b); size_t hash_value(upgrade_type_info const& x);void swap(upgrade_type_info& a, upgrade_type_info& b); void to_dynamic(cradle::dynamic* v, upgrade_type_info const& x); void from_dynamic(upgrade_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, upgrade_type_info const& x); size_t deep_sizeof(upgrade_type_info const& x); 

#line 337 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_upgrade_type_info { string name;  string description;  upgrade_type_info schema;  api_upgrade_type_info() {} api_upgrade_type_info(string const& name, string const& description, upgrade_type_info const& schema) : name(name), description(description), schema(schema) {} };  inline api_upgrade_type_info make_api_upgrade_type_info(  string name, string description, upgrade_type_info schema ) { return api_upgrade_type_info(  std::move(name), std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<api_upgrade_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_upgrade_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_upgrade_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_upgrade_type_info const& a, api_upgrade_type_info const& b); bool operator!=(api_upgrade_type_info const& a, api_upgrade_type_info const& b); bool operator<(api_upgrade_type_info const& a, api_upgrade_type_info const& b); void swap(api_upgrade_type_info& a, api_upgrade_type_info& b); size_t deep_sizeof(api_upgrade_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_upgrade_type_info const& x); void to_dynamic(cradle::dynamic* v, api_upgrade_type_info const& x); void read_fields_from_record(api_upgrade_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_upgrade_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_upgrade_type_info const& x);std::ostream& operator<<(std::ostream& s, api_upgrade_type_info const& x);size_t hash_value(api_upgrade_type_info const& x);} namespace cradle { 

#line 345 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_dependency_type_info { string account;  string app;  string version;  api_dependency_type_info() {} api_dependency_type_info(string const& account, string const& app, string const& version) : account(account), app(app), version(version) {} };  inline api_dependency_type_info make_api_dependency_type_info(  string account, string app, string version ) { return api_dependency_type_info(  std::move(account), std::move(app), std::move(version) ); }template<> struct definitive_type_info_query<api_dependency_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_dependency_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_dependency_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_dependency_type_info const& a, api_dependency_type_info const& b); bool operator!=(api_dependency_type_info const& a, api_dependency_type_info const& b); bool operator<(api_dependency_type_info const& a, api_dependency_type_info const& b); void swap(api_dependency_type_info& a, api_dependency_type_info& b); size_t deep_sizeof(api_dependency_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_dependency_type_info const& x); void to_dynamic(cradle::dynamic* v, api_dependency_type_info const& x); void read_fields_from_record(api_dependency_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_dependency_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_dependency_type_info const& x);std::ostream& operator<<(std::ostream& s, api_dependency_type_info const& x);size_t hash_value(api_dependency_type_info const& x);} namespace cradle { 

#line 353 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_record_named_type_info { string name;  omissible<string > app;  omissible<string > account;  api_record_named_type_info() {} api_record_named_type_info(string const& name, omissible<string > const& app, omissible<string > const& account) : name(name), app(app), account(account) {} };  inline api_record_named_type_info make_api_record_named_type_info(  string name, omissible<string > app, omissible<string > account ) { return api_record_named_type_info(  std::move(name), std::move(app), std::move(account) ); }template<> struct definitive_type_info_query<api_record_named_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_record_named_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_record_named_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_record_named_type_info const& a, api_record_named_type_info const& b); bool operator!=(api_record_named_type_info const& a, api_record_named_type_info const& b); bool operator<(api_record_named_type_info const& a, api_record_named_type_info const& b); void swap(api_record_named_type_info& a, api_record_named_type_info& b); size_t deep_sizeof(api_record_named_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_record_named_type_info const& x); void to_dynamic(cradle::dynamic* v, api_record_named_type_info const& x); void read_fields_from_record(api_record_named_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_record_named_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_record_named_type_info const& x);std::ostream& operator<<(std::ostream& s, api_record_named_type_info const& x);size_t hash_value(api_record_named_type_info const& x);} namespace cradle { 

#line 361 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_record_named_type_schema { api_record_named_type_info named_type;  api_record_named_type_schema() {} explicit api_record_named_type_schema(api_record_named_type_info const& named_type) : named_type(named_type) {} };  inline api_record_named_type_schema make_api_record_named_type_schema(  api_record_named_type_info named_type ) { return api_record_named_type_schema(  std::move(named_type) ); }template<> struct definitive_type_info_query<api_record_named_type_schema> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_record_named_type_schema> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_record_named_type_schema> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_record_named_type_schema const& a, api_record_named_type_schema const& b); bool operator!=(api_record_named_type_schema const& a, api_record_named_type_schema const& b); bool operator<(api_record_named_type_schema const& a, api_record_named_type_schema const& b); void swap(api_record_named_type_schema& a, api_record_named_type_schema& b); size_t deep_sizeof(api_record_named_type_schema const& x); void write_fields_to_record(cradle::dynamic_map& record, api_record_named_type_schema const& x); void to_dynamic(cradle::dynamic* v, api_record_named_type_schema const& x); void read_fields_from_record(api_record_named_type_schema& x, cradle::dynamic_map const& record); void from_dynamic(api_record_named_type_schema* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_record_named_type_schema const& x);std::ostream& operator<<(std::ostream& s, api_record_named_type_schema const& x);size_t hash_value(api_record_named_type_schema const& x);} namespace cradle { 

#line 367 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_record_info { api_record_named_type_schema schema;  api_record_info() {} explicit api_record_info(api_record_named_type_schema const& schema) : schema(schema) {} };  inline api_record_info make_api_record_info(  api_record_named_type_schema schema ) { return api_record_info(  std::move(schema) ); }template<> struct definitive_type_info_query<api_record_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_record_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_record_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_record_info const& a, api_record_info const& b); bool operator!=(api_record_info const& a, api_record_info const& b); bool operator<(api_record_info const& a, api_record_info const& b); void swap(api_record_info& a, api_record_info& b); size_t deep_sizeof(api_record_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_record_info const& x); void to_dynamic(cradle::dynamic* v, api_record_info const& x); void read_fields_from_record(api_record_info& x, cradle::dynamic_map const& record); void from_dynamic(api_record_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_record_info const& x);std::ostream& operator<<(std::ostream& s, api_record_info const& x);size_t hash_value(api_record_info const& x);} namespace cradle { 

#line 373 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_named_record_type_info { string name;  string description;  api_type_info schema;  api_named_record_type_info() {} api_named_record_type_info(string const& name, string const& description, api_type_info const& schema) : name(name), description(description), schema(schema) {} };  inline api_named_record_type_info make_api_named_record_type_info(  string name, string description, api_type_info schema ) { return api_named_record_type_info(  std::move(name), std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<api_named_record_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_named_record_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_named_record_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_named_record_type_info const& a, api_named_record_type_info const& b); bool operator!=(api_named_record_type_info const& a, api_named_record_type_info const& b); bool operator<(api_named_record_type_info const& a, api_named_record_type_info const& b); void swap(api_named_record_type_info& a, api_named_record_type_info& b); size_t deep_sizeof(api_named_record_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, api_named_record_type_info const& x); void to_dynamic(cradle::dynamic* v, api_named_record_type_info const& x); void read_fields_from_record(api_named_record_type_info& x, cradle::dynamic_map const& record); void from_dynamic(api_named_record_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_named_record_type_info const& x);std::ostream& operator<<(std::ostream& s, api_named_record_type_info const& x);size_t hash_value(api_named_record_type_info const& x);} namespace cradle { 

#line 381 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
struct api_implementation
{
    std::vector<api_named_type_implementation_info> types;

    // functions are indexed by UID
    std::map<string, api_function_ptr> functions;

    std::vector<api_upgrade_type_info> upgrades;

    std::vector<api_named_record_type_info> records;
};

#line 393 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
void
register_api_named_type(
    api_implementation& api,
    string const& name,
    unsigned version,
    string const& description,
    api_type_info const& form,
    upgrade_type upgrade = upgrade_type::NONE);

#line 402 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
void
register_api_record_type(
    api_implementation& api,
    string const& record_name,
    string const& description,
    string const& account,
    string const& app,
    string const& name);

#line 411 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
void
register_api_mutation_type(
    api_implementation& api,
    string const& description,
    string const& upgrade_version,
    string const& upgrade_type,
    string const& body);

#line 419 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
std::vector<api_upgrade_type_info>
generate_api_upgrades(api_implementation const& api);

#line 422 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
void
register_api_function(api_implementation& api, api_function_ptr const& f);

#line 425 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_function_uid_contents { string name;  std::vector<api_function_parameter_info > parameters;  unsigned revision;  api_function_uid_contents() {} api_function_uid_contents(string const& name, std::vector<api_function_parameter_info > const& parameters, unsigned const& revision) : name(name), parameters(parameters), revision(revision) {} };  inline api_function_uid_contents make_api_function_uid_contents(  string name, std::vector<api_function_parameter_info > parameters, unsigned revision ) { return api_function_uid_contents(  std::move(name), std::move(parameters), std::move(revision) ); }template<> struct definitive_type_info_query<api_function_uid_contents> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_function_uid_contents> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_function_uid_contents> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_function_uid_contents const& a, api_function_uid_contents const& b); bool operator!=(api_function_uid_contents const& a, api_function_uid_contents const& b); bool operator<(api_function_uid_contents const& a, api_function_uid_contents const& b); void swap(api_function_uid_contents& a, api_function_uid_contents& b); size_t deep_sizeof(api_function_uid_contents const& x); void write_fields_to_record(cradle::dynamic_map& record, api_function_uid_contents const& x); void to_dynamic(cradle::dynamic* v, api_function_uid_contents const& x); void read_fields_from_record(api_function_uid_contents& x, cradle::dynamic_map const& record); void from_dynamic(api_function_uid_contents* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_function_uid_contents const& x);std::ostream& operator<<(std::ostream& s, api_function_uid_contents const& x);size_t hash_value(api_function_uid_contents const& x);} namespace cradle { 

#line 433 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// Given a function's name, its parameter info, and a revision number, this
// generates a UID for the function.
string
generate_function_uid(
    string const& name,
    std::vector<api_function_parameter_info> const& parameters,
    unsigned revision);

#line 441 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_documentation { std::vector<api_named_type_info > types;  std::vector<api_function_info > functions;  std::vector<api_upgrade_type_info > upgrades;  std::vector<api_dependency_type_info > dependencies;  std::vector<api_named_record_type_info > records;  api_documentation() {} api_documentation(std::vector<api_named_type_info > const& types, std::vector<api_function_info > const& functions, std::vector<api_upgrade_type_info > const& upgrades, std::vector<api_dependency_type_info > const& dependencies, std::vector<api_named_record_type_info > const& records) : types(types), functions(functions), upgrades(upgrades), dependencies(dependencies), records(records) {} };  inline api_documentation make_api_documentation(  std::vector<api_named_type_info > types, std::vector<api_function_info > functions, std::vector<api_upgrade_type_info > upgrades, std::vector<api_dependency_type_info > dependencies, std::vector<api_named_record_type_info > records ) { return api_documentation(  std::move(types), std::move(functions), std::move(upgrades), std::move(dependencies), std::move(records) ); }template<> struct definitive_type_info_query<api_documentation> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_documentation> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_documentation> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(api_documentation const& a, api_documentation const& b); bool operator!=(api_documentation const& a, api_documentation const& b); bool operator<(api_documentation const& a, api_documentation const& b); void swap(api_documentation& a, api_documentation& b); size_t deep_sizeof(api_documentation const& x); void write_fields_to_record(cradle::dynamic_map& record, api_documentation const& x); void to_dynamic(cradle::dynamic* v, api_documentation const& x); void read_fields_from_record(api_documentation& x, cradle::dynamic_map const& record); void from_dynamic(api_documentation* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_documentation const& x);std::ostream& operator<<(std::ostream& s, api_documentation const& x);size_t hash_value(api_documentation const& x);} namespace cradle { 

#line 455 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { struct api_manifest : api_documentation { string var1;  api_manifest() {} explicit api_manifest(api_documentation const& super, string const& var1) : api_documentation(super), var1(var1) {} };  inline api_manifest make_api_manifest( api_documentation super,  string var1 ) { return api_manifest( std::move(super),  std::move(var1) ); }template<> struct definitive_type_info_query<api_manifest> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<api_manifest> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<api_manifest> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; inline static api_documentation const& as_api_documentation(api_manifest const& x) {     return static_cast<api_documentation const&>(x); } inline static api_documentation& as_api_documentation(api_manifest& x) {     return static_cast<api_documentation&>(x); } bool operator==(api_manifest const& a, api_manifest const& b); bool operator!=(api_manifest const& a, api_manifest const& b); bool operator<(api_manifest const& a, api_manifest const& b); void swap(api_manifest& a, api_manifest& b); size_t deep_sizeof(api_manifest const& x); void write_fields_to_record(cradle::dynamic_map& record, api_manifest const& x); void to_dynamic(cradle::dynamic* v, api_manifest const& x); void read_fields_from_record(api_manifest& x, cradle::dynamic_map const& record); void from_dynamic(api_manifest* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, api_manifest const& x);std::ostream& operator<<(std::ostream& s, api_manifest const& x);size_t hash_value(api_manifest const& x);} namespace cradle { 

#line 461 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
api_documentation
get_api_documentation(
    api_implementation const& api, bool include_upgrade_functions = false);

#line 465 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
string
get_api_implementation_documentation(api_implementation const& api);

#line 468 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
string
get_manifest_json(api_implementation const& api);

#line 471 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// Returns only functions that are upgrade functions
string
get_manifest_json_with_upgrades(api_implementation const& api);

#line 475 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// Returns only functions that are upgrade functions
api_documentation
get_api_upgrade_documentation(api_implementation const& api);

#line 479 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// struct undefined_function : exception
// {
//     undefined_function(string const& name)
//         : exception("undefined function: " + name), name_(new string(name))
//     {
//     }
//     string const&
//     name()
//     {
//         return *name_;
//     }
//     ~undefined_function() throw()
//     {
//     }

//  private:
//     std::shared_ptr<string> name_;
// };

#line 498 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
api_function_interface const&
find_function_by_name(api_implementation const& api, string const& name);

#line 501 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
api_function_interface const&
find_function_by_uid(api_implementation const& api, string const& uid);

#line 504 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// struct undefined_type : exception
// {
//     undefined_type(string const& name)
//         : exception("undefined type: " + name), name_(new string(name))
//     {
//     }
//     string const&
//     name()
//     {
//         return *name_;
//     }
//     ~undefined_type() throw()
//     {
//     }

//  private:
//     std::shared_ptr<string> name_;
// };

#line 523 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// // Merge two APIs together.
// //
// // The resulting API will contain all the types, records, functions, and
// // upgrades from both apps. It does *not* try to reconcile the two lists, so
// // there should be no overlap between the two.
// //
// api_implementation
// merge_apis(api_implementation const& a, api_implementation const& b);

#line 532 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// // THE CRADLE API

#line 534 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// api_implementation
// get_cradle_api();

#line 537 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
// api_documentation
// get_api_documentation();

#line 540 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
} // namespace cradle

#line 542 "/home/runner/work/cradle/cradle/src/cradle/typing/core/api_types.hpp"
#endif
