// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#include <algorithm>
#include <typeinfo>
#include "http_requests.hpp"
#include <cradle/typing/core/preprocessed.h>
#include <boost/algorithm/string/case_conv.hpp>

namespace cradle {

#line 9 "C:/dev/open-cradle/cradle/src/cradle/typing/io/http_requests.hpp"
void definitive_type_info_query<prep_http_request_method>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<prep_http_request_method>()); } void type_info_query<prep_http_request_method>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "prep_http_request_method")); } void enum_type_info_query<prep_http_request_method>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["post"] =  cradle::api_enum_value_info( "");values["get"] =  cradle::api_enum_value_info( "");values["put"] =  cradle::api_enum_value_info( "");values["delete"] =  cradle::api_enum_value_info( "");values["patch"] =  cradle::api_enum_value_info( "");values["head"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(prep_http_request_method value) {     switch (value)     { case prep_http_request_method::POST: return "post";case prep_http_request_method::GET: return "get";case prep_http_request_method::PUT: return "put";case prep_http_request_method::DELETE: return "delete";case prep_http_request_method::PATCH: return "patch";case prep_http_request_method::HEAD: return "head";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("prep_http_request_method") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     prep_http_request_method x) {     *v = get_value_id(x); } void from_dynamic(     prep_http_request_method* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "post")     {         *x = prep_http_request_method::POST;         return;     };    if (boost::to_lower_copy(s) == "get")     {         *x = prep_http_request_method::GET;         return;     };    if (boost::to_lower_copy(s) == "put")     {         *x = prep_http_request_method::PUT;         return;     };    if (boost::to_lower_copy(s) == "delete")     {         *x = prep_http_request_method::DELETE;         return;     };    if (boost::to_lower_copy(s) == "patch")     {         *x = prep_http_request_method::PATCH;         return;     };    if (boost::to_lower_copy(s) == "head")     {         *x = prep_http_request_method::HEAD;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("prep_http_request_method") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, prep_http_request_method const& x) {     s << get_value_id(x);     return s; } 

#line 22 "C:/dev/open-cradle/cradle/src/cradle/typing/io/http_requests.hpp"
} namespace cradle { void definitive_type_info_query<prep_http_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<prep_http_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<prep_http_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "prep_http_request")); } void structure_field_type_info_adder<prep_http_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["method"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_request>().method)>(),             none);    (*fields)["url"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_request>().url)>(),             none);    (*fields)["headers"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_request>().headers)>(),             none);    (*fields)["body"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_request>().body)>(),             none);    (*fields)["socket"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_request>().socket)>(),             none); } bool operator==(prep_http_request const& a, prep_http_request const& b) { return a.method == b.method && a.url == b.url && a.headers == b.headers && a.body == b.body && a.socket == b.socket; } bool operator!=(prep_http_request const& a, prep_http_request const& b) { return !(a == b); } bool operator<(prep_http_request const& a, prep_http_request const& b) { if (a.method < b.method) return true; if (b.method < a.method) return false; if (a.url < b.url) return true; if (b.url < a.url) return false; if (a.headers < b.headers) return true; if (b.headers < a.headers) return false; if (a.body < b.body) return true; if (b.body < a.body) return false; if (a.socket < b.socket) return true; if (b.socket < a.socket) return false;     return false; } void swap(prep_http_request& a, prep_http_request& b) {     using std::swap;     swap(a.method, b.method);     swap(a.url, b.url);     swap(a.headers, b.headers);     swap(a.body, b.body);     swap(a.socket, b.socket); } size_t deep_sizeof(prep_http_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.method) + deep_sizeof(x.url) + deep_sizeof(x.headers) + deep_sizeof(x.body) + deep_sizeof(x.socket) ; } void write_fields_to_record(cradle::dynamic_map& record, prep_http_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "method", x.method); write_field_to_record(record, "url", x.url); write_field_to_record(record, "headers", x.headers); write_field_to_record(record, "body", x.body); write_field_to_record(record, "socket", x.socket); } void to_dynamic(cradle::dynamic* v, prep_http_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(prep_http_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.method, record, "method"); read_field_from_record(&x.url, record, "url"); read_field_from_record(&x.headers, record, "headers"); read_field_from_record(&x.body, record, "body"); read_field_from_record(&x.socket, record, "socket"); } void from_dynamic(prep_http_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, prep_http_request const& x) { return s << to_dynamic(x); } size_t hash_value(prep_http_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.method)); boost::hash_combine(h, cradle::invoke_hash(x.url)); boost::hash_combine(h, cradle::invoke_hash(x.headers)); boost::hash_combine(h, cradle::invoke_hash(x.body)); boost::hash_combine(h, cradle::invoke_hash(x.socket));  return h; }} namespace cradle { 

#line 36 "C:/dev/open-cradle/cradle/src/cradle/typing/io/http_requests.hpp"
} namespace cradle { void definitive_type_info_query<prep_http_response>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<prep_http_response>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<prep_http_response>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "prep_http_response")); } void structure_field_type_info_adder<prep_http_response>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["status_code"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_response>().status_code)>(),             none);    (*fields)["headers"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_response>().headers)>(),             none);    (*fields)["body"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<prep_http_response>().body)>(),             none); } bool operator==(prep_http_response const& a, prep_http_response const& b) { return a.status_code == b.status_code && a.headers == b.headers && a.body == b.body; } bool operator!=(prep_http_response const& a, prep_http_response const& b) { return !(a == b); } bool operator<(prep_http_response const& a, prep_http_response const& b) { if (a.status_code < b.status_code) return true; if (b.status_code < a.status_code) return false; if (a.headers < b.headers) return true; if (b.headers < a.headers) return false; if (a.body < b.body) return true; if (b.body < a.body) return false;     return false; } void swap(prep_http_response& a, prep_http_response& b) {     using std::swap;     swap(a.status_code, b.status_code);     swap(a.headers, b.headers);     swap(a.body, b.body); } size_t deep_sizeof(prep_http_response const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.status_code) + deep_sizeof(x.headers) + deep_sizeof(x.body) ; } void write_fields_to_record(cradle::dynamic_map& record, prep_http_response const& x) { using cradle::write_field_to_record; write_field_to_record(record, "status_code", x.status_code); write_field_to_record(record, "headers", x.headers); write_field_to_record(record, "body", x.body); } void to_dynamic(cradle::dynamic* v, prep_http_response const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(prep_http_response& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.status_code, record, "status_code"); read_field_from_record(&x.headers, record, "headers"); read_field_from_record(&x.body, record, "body"); } void from_dynamic(prep_http_response* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, prep_http_response const& x) { return s << to_dynamic(x); } size_t hash_value(prep_http_response const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.status_code)); boost::hash_combine(h, cradle::invoke_hash(x.headers)); boost::hash_combine(h, cradle::invoke_hash(x.body));  return h; }} namespace cradle { 

}

namespace cradle {
void add_src_cradle_typing_io_http_requests_api(cradle::api_implementation& api)
{

}

}
