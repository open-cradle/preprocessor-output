// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#include <algorithm>
#include <typeinfo>
#include "types.hpp"
#include <cradle/typing/core/preprocessed.h>
#include <boost/algorithm/string/case_conv.hpp>

namespace cradle {

#line 20 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
void definitive_type_info_query<calculation_request_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<calculation_request_tag>()); } void type_info_query<calculation_request_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_request_tag")); } void enum_type_info_query<calculation_request_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["reference"] =  cradle::api_enum_value_info( "");values["value"] =  cradle::api_enum_value_info( "");values["lambda"] =  cradle::api_enum_value_info( "");values["function"] =  cradle::api_enum_value_info( "");values["array"] =  cradle::api_enum_value_info( "");values["item"] =  cradle::api_enum_value_info( "");values["object"] =  cradle::api_enum_value_info( "");values["property"] =  cradle::api_enum_value_info( "");values["let"] =  cradle::api_enum_value_info( "");values["variable"] =  cradle::api_enum_value_info( "");values["meta"] =  cradle::api_enum_value_info( "");values["cast"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(calculation_request_tag value) {     switch (value)     { case calculation_request_tag::REFERENCE: return "reference";case calculation_request_tag::VALUE: return "value";case calculation_request_tag::LAMBDA: return "lambda";case calculation_request_tag::FUNCTION: return "function";case calculation_request_tag::ARRAY: return "array";case calculation_request_tag::ITEM: return "item";case calculation_request_tag::OBJECT: return "object";case calculation_request_tag::PROPERTY: return "property";case calculation_request_tag::LET: return "let";case calculation_request_tag::VARIABLE: return "variable";case calculation_request_tag::META: return "meta";case calculation_request_tag::CAST: return "cast";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("calculation_request_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     calculation_request_tag x) {     *v = get_value_id(x); } void from_dynamic(     calculation_request_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "reference")     {         *x = calculation_request_tag::REFERENCE;         return;     };    if (boost::to_lower_copy(s) == "value")     {         *x = calculation_request_tag::VALUE;         return;     };    if (boost::to_lower_copy(s) == "lambda")     {         *x = calculation_request_tag::LAMBDA;         return;     };    if (boost::to_lower_copy(s) == "function")     {         *x = calculation_request_tag::FUNCTION;         return;     };    if (boost::to_lower_copy(s) == "array")     {         *x = calculation_request_tag::ARRAY;         return;     };    if (boost::to_lower_copy(s) == "item")     {         *x = calculation_request_tag::ITEM;         return;     };    if (boost::to_lower_copy(s) == "object")     {         *x = calculation_request_tag::OBJECT;         return;     };    if (boost::to_lower_copy(s) == "property")     {         *x = calculation_request_tag::PROPERTY;         return;     };    if (boost::to_lower_copy(s) == "let")     {         *x = calculation_request_tag::LET;         return;     };    if (boost::to_lower_copy(s) == "variable")     {         *x = calculation_request_tag::VARIABLE;         return;     };    if (boost::to_lower_copy(s) == "meta")     {         *x = calculation_request_tag::META;         return;     };    if (boost::to_lower_copy(s) == "cast")     {         *x = calculation_request_tag::CAST;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("calculation_request_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, calculation_request_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<calculation_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["reference"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<std::string>());    members["value"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<dynamic>());    members["lambda"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<lambda_calculation>());    members["function"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<function_application>());    members["array"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<array_calc_request>());    members["item"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<item_calc_request>());    members["object"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<object_calc_request>());    members["property"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<property_calc_request>());    members["let"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<let_calc_request>());    members["variable"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<std::string>());    members["meta"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<meta_calc_request>());    members["cast"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<cast_calc_request>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<calculation_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_request")); } calculation_request make_calculation_request_with_reference(std::string const& x) { calculation_request s; s.type = calculation_request_tag::REFERENCE; s.contents_ = x; return s; } calculation_request make_calculation_request_with_reference(std::string&& x) { calculation_request s; s.type = calculation_request_tag::REFERENCE; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_value(dynamic const& x) { calculation_request s; s.type = calculation_request_tag::VALUE; s.contents_ = x; return s; } calculation_request make_calculation_request_with_value(dynamic&& x) { calculation_request s; s.type = calculation_request_tag::VALUE; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_lambda(lambda_calculation const& x) { calculation_request s; s.type = calculation_request_tag::LAMBDA; s.contents_ = x; return s; } calculation_request make_calculation_request_with_lambda(lambda_calculation&& x) { calculation_request s; s.type = calculation_request_tag::LAMBDA; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_function(function_application const& x) { calculation_request s; s.type = calculation_request_tag::FUNCTION; s.contents_ = x; return s; } calculation_request make_calculation_request_with_function(function_application&& x) { calculation_request s; s.type = calculation_request_tag::FUNCTION; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_array(array_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::ARRAY; s.contents_ = x; return s; } calculation_request make_calculation_request_with_array(array_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::ARRAY; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_item(item_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::ITEM; s.contents_ = x; return s; } calculation_request make_calculation_request_with_item(item_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::ITEM; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_object(object_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::OBJECT; s.contents_ = x; return s; } calculation_request make_calculation_request_with_object(object_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::OBJECT; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_property(property_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::PROPERTY; s.contents_ = x; return s; } calculation_request make_calculation_request_with_property(property_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::PROPERTY; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_let(let_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::LET; s.contents_ = x; return s; } calculation_request make_calculation_request_with_let(let_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::LET; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_variable(std::string const& x) { calculation_request s; s.type = calculation_request_tag::VARIABLE; s.contents_ = x; return s; } calculation_request make_calculation_request_with_variable(std::string&& x) { calculation_request s; s.type = calculation_request_tag::VARIABLE; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_meta(meta_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::META; s.contents_ = x; return s; } calculation_request make_calculation_request_with_meta(meta_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::META; s.contents_ = std::move(x); return s; } calculation_request make_calculation_request_with_cast(cast_calc_request const& x) { calculation_request s; s.type = calculation_request_tag::CAST; s.contents_ = x; return s; } calculation_request make_calculation_request_with_cast(cast_calc_request&& x) { calculation_request s; s.type = calculation_request_tag::CAST; s.contents_ = std::move(x); return s; } std::string const& as_reference(calculation_request const& x) { assert(x.type == calculation_request_tag::REFERENCE); return std::any_cast<std::string const& >(x.contents_); } dynamic const& as_value(calculation_request const& x) { assert(x.type == calculation_request_tag::VALUE); return std::any_cast<dynamic const& >(x.contents_); } lambda_calculation const& as_lambda(calculation_request const& x) { assert(x.type == calculation_request_tag::LAMBDA); return std::any_cast<lambda_calculation const& >(x.contents_); } function_application const& as_function(calculation_request const& x) { assert(x.type == calculation_request_tag::FUNCTION); return std::any_cast<function_application const& >(x.contents_); } array_calc_request const& as_array(calculation_request const& x) { assert(x.type == calculation_request_tag::ARRAY); return std::any_cast<array_calc_request const& >(x.contents_); } item_calc_request const& as_item(calculation_request const& x) { assert(x.type == calculation_request_tag::ITEM); return std::any_cast<item_calc_request const& >(x.contents_); } object_calc_request const& as_object(calculation_request const& x) { assert(x.type == calculation_request_tag::OBJECT); return std::any_cast<object_calc_request const& >(x.contents_); } property_calc_request const& as_property(calculation_request const& x) { assert(x.type == calculation_request_tag::PROPERTY); return std::any_cast<property_calc_request const& >(x.contents_); } let_calc_request const& as_let(calculation_request const& x) { assert(x.type == calculation_request_tag::LET); return std::any_cast<let_calc_request const& >(x.contents_); } std::string const& as_variable(calculation_request const& x) { assert(x.type == calculation_request_tag::VARIABLE); return std::any_cast<std::string const& >(x.contents_); } meta_calc_request const& as_meta(calculation_request const& x) { assert(x.type == calculation_request_tag::META); return std::any_cast<meta_calc_request const& >(x.contents_); } cast_calc_request const& as_cast(calculation_request const& x) { assert(x.type == calculation_request_tag::CAST); return std::any_cast<cast_calc_request const& >(x.contents_); } std::string& as_reference(calculation_request& x) { assert(x.type == calculation_request_tag::REFERENCE); return std::any_cast<std::string&>(x.contents_); } dynamic& as_value(calculation_request& x) { assert(x.type == calculation_request_tag::VALUE); return std::any_cast<dynamic&>(x.contents_); } lambda_calculation& as_lambda(calculation_request& x) { assert(x.type == calculation_request_tag::LAMBDA); return std::any_cast<lambda_calculation&>(x.contents_); } function_application& as_function(calculation_request& x) { assert(x.type == calculation_request_tag::FUNCTION); return std::any_cast<function_application&>(x.contents_); } array_calc_request& as_array(calculation_request& x) { assert(x.type == calculation_request_tag::ARRAY); return std::any_cast<array_calc_request&>(x.contents_); } item_calc_request& as_item(calculation_request& x) { assert(x.type == calculation_request_tag::ITEM); return std::any_cast<item_calc_request&>(x.contents_); } object_calc_request& as_object(calculation_request& x) { assert(x.type == calculation_request_tag::OBJECT); return std::any_cast<object_calc_request&>(x.contents_); } property_calc_request& as_property(calculation_request& x) { assert(x.type == calculation_request_tag::PROPERTY); return std::any_cast<property_calc_request&>(x.contents_); } let_calc_request& as_let(calculation_request& x) { assert(x.type == calculation_request_tag::LET); return std::any_cast<let_calc_request&>(x.contents_); } std::string& as_variable(calculation_request& x) { assert(x.type == calculation_request_tag::VARIABLE); return std::any_cast<std::string&>(x.contents_); } meta_calc_request& as_meta(calculation_request& x) { assert(x.type == calculation_request_tag::META); return std::any_cast<meta_calc_request&>(x.contents_); } cast_calc_request& as_cast(calculation_request& x) { assert(x.type == calculation_request_tag::CAST); return std::any_cast<cast_calc_request&>(x.contents_); } void set_to_reference(calculation_request& x, std::string const& y) { x.type = calculation_request_tag::REFERENCE; x.contents_ = y; } void set_to_reference(calculation_request& x, std::string&& y) { x.type = calculation_request_tag::REFERENCE; x.contents_ = std::move(y); } void set_to_value(calculation_request& x, dynamic const& y) { x.type = calculation_request_tag::VALUE; x.contents_ = y; } void set_to_value(calculation_request& x, dynamic&& y) { x.type = calculation_request_tag::VALUE; x.contents_ = std::move(y); } void set_to_lambda(calculation_request& x, lambda_calculation const& y) { x.type = calculation_request_tag::LAMBDA; x.contents_ = y; } void set_to_lambda(calculation_request& x, lambda_calculation&& y) { x.type = calculation_request_tag::LAMBDA; x.contents_ = std::move(y); } void set_to_function(calculation_request& x, function_application const& y) { x.type = calculation_request_tag::FUNCTION; x.contents_ = y; } void set_to_function(calculation_request& x, function_application&& y) { x.type = calculation_request_tag::FUNCTION; x.contents_ = std::move(y); } void set_to_array(calculation_request& x, array_calc_request const& y) { x.type = calculation_request_tag::ARRAY; x.contents_ = y; } void set_to_array(calculation_request& x, array_calc_request&& y) { x.type = calculation_request_tag::ARRAY; x.contents_ = std::move(y); } void set_to_item(calculation_request& x, item_calc_request const& y) { x.type = calculation_request_tag::ITEM; x.contents_ = y; } void set_to_item(calculation_request& x, item_calc_request&& y) { x.type = calculation_request_tag::ITEM; x.contents_ = std::move(y); } void set_to_object(calculation_request& x, object_calc_request const& y) { x.type = calculation_request_tag::OBJECT; x.contents_ = y; } void set_to_object(calculation_request& x, object_calc_request&& y) { x.type = calculation_request_tag::OBJECT; x.contents_ = std::move(y); } void set_to_property(calculation_request& x, property_calc_request const& y) { x.type = calculation_request_tag::PROPERTY; x.contents_ = y; } void set_to_property(calculation_request& x, property_calc_request&& y) { x.type = calculation_request_tag::PROPERTY; x.contents_ = std::move(y); } void set_to_let(calculation_request& x, let_calc_request const& y) { x.type = calculation_request_tag::LET; x.contents_ = y; } void set_to_let(calculation_request& x, let_calc_request&& y) { x.type = calculation_request_tag::LET; x.contents_ = std::move(y); } void set_to_variable(calculation_request& x, std::string const& y) { x.type = calculation_request_tag::VARIABLE; x.contents_ = y; } void set_to_variable(calculation_request& x, std::string&& y) { x.type = calculation_request_tag::VARIABLE; x.contents_ = std::move(y); } void set_to_meta(calculation_request& x, meta_calc_request const& y) { x.type = calculation_request_tag::META; x.contents_ = y; } void set_to_meta(calculation_request& x, meta_calc_request&& y) { x.type = calculation_request_tag::META; x.contents_ = std::move(y); } void set_to_cast(calculation_request& x, cast_calc_request const& y) { x.type = calculation_request_tag::CAST; x.contents_ = y; } void set_to_cast(calculation_request& x, cast_calc_request&& y) { x.type = calculation_request_tag::CAST; x.contents_ = std::move(y); } bool operator==(calculation_request const& a, calculation_request const& b) { if (a.type != b.type) return false; switch (a.type) { case calculation_request_tag::REFERENCE: return as_reference(a) == as_reference(b); case calculation_request_tag::VALUE: return as_value(a) == as_value(b); case calculation_request_tag::LAMBDA: return as_lambda(a) == as_lambda(b); case calculation_request_tag::FUNCTION: return as_function(a) == as_function(b); case calculation_request_tag::ARRAY: return as_array(a) == as_array(b); case calculation_request_tag::ITEM: return as_item(a) == as_item(b); case calculation_request_tag::OBJECT: return as_object(a) == as_object(b); case calculation_request_tag::PROPERTY: return as_property(a) == as_property(b); case calculation_request_tag::LET: return as_let(a) == as_let(b); case calculation_request_tag::VARIABLE: return as_variable(a) == as_variable(b); case calculation_request_tag::META: return as_meta(a) == as_meta(b); case calculation_request_tag::CAST: return as_cast(a) == as_cast(b); } return true; } bool operator!=(calculation_request const& a, calculation_request const& b) { return !(a == b); } bool operator<(calculation_request const& a, calculation_request const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case calculation_request_tag::REFERENCE: return as_reference(a) < as_reference(b); case calculation_request_tag::VALUE: return as_value(a) < as_value(b); case calculation_request_tag::LAMBDA: return as_lambda(a) < as_lambda(b); case calculation_request_tag::FUNCTION: return as_function(a) < as_function(b); case calculation_request_tag::ARRAY: return as_array(a) < as_array(b); case calculation_request_tag::ITEM: return as_item(a) < as_item(b); case calculation_request_tag::OBJECT: return as_object(a) < as_object(b); case calculation_request_tag::PROPERTY: return as_property(a) < as_property(b); case calculation_request_tag::LET: return as_let(a) < as_let(b); case calculation_request_tag::VARIABLE: return as_variable(a) < as_variable(b); case calculation_request_tag::META: return as_meta(a) < as_meta(b); case calculation_request_tag::CAST: return as_cast(a) < as_cast(b); } return false; } size_t hash_value(calculation_request const& x) {     switch (x.type)     { case calculation_request_tag::REFERENCE: return cradle::invoke_hash(as_reference(x)); case calculation_request_tag::VALUE: return cradle::invoke_hash(as_value(x)); case calculation_request_tag::LAMBDA: return cradle::invoke_hash(as_lambda(x)); case calculation_request_tag::FUNCTION: return cradle::invoke_hash(as_function(x)); case calculation_request_tag::ARRAY: return cradle::invoke_hash(as_array(x)); case calculation_request_tag::ITEM: return cradle::invoke_hash(as_item(x)); case calculation_request_tag::OBJECT: return cradle::invoke_hash(as_object(x)); case calculation_request_tag::PROPERTY: return cradle::invoke_hash(as_property(x)); case calculation_request_tag::LET: return cradle::invoke_hash(as_let(x)); case calculation_request_tag::VARIABLE: return cradle::invoke_hash(as_variable(x)); case calculation_request_tag::META: return cradle::invoke_hash(as_meta(x)); case calculation_request_tag::CAST: return cradle::invoke_hash(as_cast(x));      } assert(0); return 0; }void swap(calculation_request& a, calculation_request& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, calculation_request const& x) { cradle::dynamic_map s; switch (x.type) { case calculation_request_tag::REFERENCE: to_dynamic(&s[dynamic("reference")], as_reference(x)); break; case calculation_request_tag::VALUE: to_dynamic(&s[dynamic("value")], as_value(x)); break; case calculation_request_tag::LAMBDA: to_dynamic(&s[dynamic("lambda")], as_lambda(x)); break; case calculation_request_tag::FUNCTION: to_dynamic(&s[dynamic("function")], as_function(x)); break; case calculation_request_tag::ARRAY: to_dynamic(&s[dynamic("array")], as_array(x)); break; case calculation_request_tag::ITEM: to_dynamic(&s[dynamic("item")], as_item(x)); break; case calculation_request_tag::OBJECT: to_dynamic(&s[dynamic("object")], as_object(x)); break; case calculation_request_tag::PROPERTY: to_dynamic(&s[dynamic("property")], as_property(x)); break; case calculation_request_tag::LET: to_dynamic(&s[dynamic("let")], as_let(x)); break; case calculation_request_tag::VARIABLE: to_dynamic(&s[dynamic("variable")], as_variable(x)); break; case calculation_request_tag::META: to_dynamic(&s[dynamic("meta")], as_meta(x)); break; case calculation_request_tag::CAST: to_dynamic(&s[dynamic("cast")], as_cast(x)); break; } *v = std::move(s); } void from_dynamic(calculation_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case calculation_request_tag::REFERENCE:  { std::string tmp; from_dynamic(&tmp, get_field(s, "reference")); x->contents_ = tmp; break;  } case calculation_request_tag::VALUE:  { dynamic tmp; from_dynamic(&tmp, get_field(s, "value")); x->contents_ = tmp; break;  } case calculation_request_tag::LAMBDA:  { lambda_calculation tmp; from_dynamic(&tmp, get_field(s, "lambda")); x->contents_ = tmp; break;  } case calculation_request_tag::FUNCTION:  { function_application tmp; from_dynamic(&tmp, get_field(s, "function")); x->contents_ = tmp; break;  } case calculation_request_tag::ARRAY:  { array_calc_request tmp; from_dynamic(&tmp, get_field(s, "array")); x->contents_ = tmp; break;  } case calculation_request_tag::ITEM:  { item_calc_request tmp; from_dynamic(&tmp, get_field(s, "item")); x->contents_ = tmp; break;  } case calculation_request_tag::OBJECT:  { object_calc_request tmp; from_dynamic(&tmp, get_field(s, "object")); x->contents_ = tmp; break;  } case calculation_request_tag::PROPERTY:  { property_calc_request tmp; from_dynamic(&tmp, get_field(s, "property")); x->contents_ = tmp; break;  } case calculation_request_tag::LET:  { let_calc_request tmp; from_dynamic(&tmp, get_field(s, "let")); x->contents_ = tmp; break;  } case calculation_request_tag::VARIABLE:  { std::string tmp; from_dynamic(&tmp, get_field(s, "variable")); x->contents_ = tmp; break;  } case calculation_request_tag::META:  { meta_calc_request tmp; from_dynamic(&tmp, get_field(s, "meta")); x->contents_ = tmp; break;  } case calculation_request_tag::CAST:  { cast_calc_request tmp; from_dynamic(&tmp, get_field(s, "cast")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, calculation_request const& x) { return s << to_dynamic(x); } size_t deep_sizeof(calculation_request const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case calculation_request_tag::REFERENCE: size += deep_sizeof(as_reference(x)); break; case calculation_request_tag::VALUE: size += deep_sizeof(as_value(x)); break; case calculation_request_tag::LAMBDA: size += deep_sizeof(as_lambda(x)); break; case calculation_request_tag::FUNCTION: size += deep_sizeof(as_function(x)); break; case calculation_request_tag::ARRAY: size += deep_sizeof(as_array(x)); break; case calculation_request_tag::ITEM: size += deep_sizeof(as_item(x)); break; case calculation_request_tag::OBJECT: size += deep_sizeof(as_object(x)); break; case calculation_request_tag::PROPERTY: size += deep_sizeof(as_property(x)); break; case calculation_request_tag::LET: size += deep_sizeof(as_let(x)); break; case calculation_request_tag::VARIABLE: size += deep_sizeof(as_variable(x)); break; case calculation_request_tag::META: size += deep_sizeof(as_meta(x)); break; case calculation_request_tag::CAST: size += deep_sizeof(as_cast(x)); break; } return size; } 

#line 37 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
void definitive_type_info_query<execution_host_selection>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<execution_host_selection>()); } void type_info_query<execution_host_selection>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "execution_host_selection")); } void enum_type_info_query<execution_host_selection>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["any"] =  cradle::api_enum_value_info( "");values["thinknode"] =  cradle::api_enum_value_info( "");values["local"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(execution_host_selection value) {     switch (value)     { case execution_host_selection::ANY: return "any";case execution_host_selection::THINKNODE: return "thinknode";case execution_host_selection::LOCAL: return "local";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("execution_host_selection") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     execution_host_selection x) {     *v = get_value_id(x); } void from_dynamic(     execution_host_selection* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "any")     {         *x = execution_host_selection::ANY;         return;     };    if (boost::to_lower_copy(s) == "thinknode")     {         *x = execution_host_selection::THINKNODE;         return;     };    if (boost::to_lower_copy(s) == "local")     {         *x = execution_host_selection::LOCAL;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("execution_host_selection") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, execution_host_selection const& x) {     s << get_value_id(x);     return s; } 

#line 46 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<function_application>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<function_application>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<function_application>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "function_application")); } void structure_field_type_info_adder<function_application>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["account"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<function_application>().account)>(),             none);    (*fields)["app"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<function_application>().app)>(),             none);    (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<function_application>().name)>(),             none);    (*fields)["host"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<function_application>().host)>(),             none);    (*fields)["level"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<function_application>().level)>(),             none);    (*fields)["args"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<function_application>().args)>(),             none); } bool operator==(function_application const& a, function_application const& b) { return a.account == b.account && a.app == b.app && a.name == b.name && a.host == b.host && a.level == b.level && a.args == b.args; } bool operator!=(function_application const& a, function_application const& b) { return !(a == b); } bool operator<(function_application const& a, function_application const& b) { if (a.account < b.account) return true; if (b.account < a.account) return false; if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.host < b.host) return true; if (b.host < a.host) return false; if (a.level < b.level) return true; if (b.level < a.level) return false; if (a.args < b.args) return true; if (b.args < a.args) return false;     return false; } void swap(function_application& a, function_application& b) {     using std::swap;     swap(a.account, b.account);     swap(a.app, b.app);     swap(a.name, b.name);     swap(a.host, b.host);     swap(a.level, b.level);     swap(a.args, b.args); } size_t deep_sizeof(function_application const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.account) + deep_sizeof(x.app) + deep_sizeof(x.name) + deep_sizeof(x.host) + deep_sizeof(x.level) + deep_sizeof(x.args) ; } void write_fields_to_record(cradle::dynamic_map& record, function_application const& x) { using cradle::write_field_to_record; write_field_to_record(record, "account", x.account); write_field_to_record(record, "app", x.app); write_field_to_record(record, "name", x.name); write_field_to_record(record, "host", x.host); write_field_to_record(record, "level", x.level); write_field_to_record(record, "args", x.args); } void to_dynamic(cradle::dynamic* v, function_application const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(function_application& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.account, record, "account"); read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.host, record, "host"); read_field_from_record(&x.level, record, "level"); read_field_from_record(&x.args, record, "args"); } void from_dynamic(function_application* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, function_application const& x) { return s << to_dynamic(x); } size_t hash_value(function_application const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.account)); boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.host)); boost::hash_combine(h, cradle::invoke_hash(x.level)); boost::hash_combine(h, cradle::invoke_hash(x.args));  return h; }} namespace cradle { 

#line 103 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<lambda_calculation>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<lambda_calculation>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<lambda_calculation>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "lambda_calculation")); } void structure_field_type_info_adder<lambda_calculation>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["function"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<lambda_calculation>().function)>(),             none);    (*fields)["args"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<lambda_calculation>().args)>(),             none); } bool operator==(lambda_calculation const& a, lambda_calculation const& b) { return a.function == b.function && a.args == b.args; } bool operator!=(lambda_calculation const& a, lambda_calculation const& b) { return !(a == b); } bool operator<(lambda_calculation const& a, lambda_calculation const& b) { if (a.function < b.function) return true; if (b.function < a.function) return false; if (a.args < b.args) return true; if (b.args < a.args) return false;     return false; } void swap(lambda_calculation& a, lambda_calculation& b) {     using std::swap;     swap(a.function, b.function);     swap(a.args, b.args); } size_t deep_sizeof(lambda_calculation const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.function) + deep_sizeof(x.args) ; } void write_fields_to_record(cradle::dynamic_map& record, lambda_calculation const& x) { using cradle::write_field_to_record; write_field_to_record(record, "function", x.function); write_field_to_record(record, "args", x.args); } void to_dynamic(cradle::dynamic* v, lambda_calculation const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(lambda_calculation& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.function, record, "function"); read_field_from_record(&x.args, record, "args"); } void from_dynamic(lambda_calculation* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, lambda_calculation const& x) { return s << to_dynamic(x); } size_t hash_value(lambda_calculation const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.function)); boost::hash_combine(h, cradle::invoke_hash(x.args));  return h; }} namespace cradle { 

#line 110 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<array_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<array_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<array_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "array_calc_request")); } void structure_field_type_info_adder<array_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["items"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<array_calc_request>().items)>(),             none);    (*fields)["item_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<array_calc_request>().item_schema)>(),             none); } bool operator==(array_calc_request const& a, array_calc_request const& b) { return a.items == b.items && a.item_schema == b.item_schema; } bool operator!=(array_calc_request const& a, array_calc_request const& b) { return !(a == b); } bool operator<(array_calc_request const& a, array_calc_request const& b) { if (a.items < b.items) return true; if (b.items < a.items) return false; if (a.item_schema < b.item_schema) return true; if (b.item_schema < a.item_schema) return false;     return false; } void swap(array_calc_request& a, array_calc_request& b) {     using std::swap;     swap(a.items, b.items);     swap(a.item_schema, b.item_schema); } size_t deep_sizeof(array_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.items) + deep_sizeof(x.item_schema) ; } void write_fields_to_record(cradle::dynamic_map& record, array_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "items", x.items); write_field_to_record(record, "item_schema", x.item_schema); } void to_dynamic(cradle::dynamic* v, array_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(array_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.items, record, "items"); read_field_from_record(&x.item_schema, record, "item_schema"); } void from_dynamic(array_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, array_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(array_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.items)); boost::hash_combine(h, cradle::invoke_hash(x.item_schema));  return h; }} namespace cradle { 

#line 117 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<object_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<object_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<object_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "object_calc_request")); } void structure_field_type_info_adder<object_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["properties"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<object_calc_request>().properties)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<object_calc_request>().schema)>(),             none); } bool operator==(object_calc_request const& a, object_calc_request const& b) { return a.properties == b.properties && a.schema == b.schema; } bool operator!=(object_calc_request const& a, object_calc_request const& b) { return !(a == b); } bool operator<(object_calc_request const& a, object_calc_request const& b) { if (a.properties < b.properties) return true; if (b.properties < a.properties) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(object_calc_request& a, object_calc_request& b) {     using std::swap;     swap(a.properties, b.properties);     swap(a.schema, b.schema); } size_t deep_sizeof(object_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.properties) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, object_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "properties", x.properties); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, object_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(object_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.properties, record, "properties"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(object_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, object_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(object_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.properties)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 124 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<item_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<item_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<item_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "item_calc_request")); } void structure_field_type_info_adder<item_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["array"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<item_calc_request>().array)>(),             none);    (*fields)["index"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<item_calc_request>().index)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<item_calc_request>().schema)>(),             none); } bool operator==(item_calc_request const& a, item_calc_request const& b) { return a.array == b.array && a.index == b.index && a.schema == b.schema; } bool operator!=(item_calc_request const& a, item_calc_request const& b) { return !(a == b); } bool operator<(item_calc_request const& a, item_calc_request const& b) { if (a.array < b.array) return true; if (b.array < a.array) return false; if (a.index < b.index) return true; if (b.index < a.index) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(item_calc_request& a, item_calc_request& b) {     using std::swap;     swap(a.array, b.array);     swap(a.index, b.index);     swap(a.schema, b.schema); } size_t deep_sizeof(item_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.array) + deep_sizeof(x.index) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, item_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "array", x.array); write_field_to_record(record, "index", x.index); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, item_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(item_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.array, record, "array"); read_field_from_record(&x.index, record, "index"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(item_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, item_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(item_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.array)); boost::hash_combine(h, cradle::invoke_hash(x.index)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 132 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<property_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<property_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<property_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "property_calc_request")); } void structure_field_type_info_adder<property_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["object"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<property_calc_request>().object)>(),             none);    (*fields)["field"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<property_calc_request>().field)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<property_calc_request>().schema)>(),             none); } bool operator==(property_calc_request const& a, property_calc_request const& b) { return a.object == b.object && a.field == b.field && a.schema == b.schema; } bool operator!=(property_calc_request const& a, property_calc_request const& b) { return !(a == b); } bool operator<(property_calc_request const& a, property_calc_request const& b) { if (a.object < b.object) return true; if (b.object < a.object) return false; if (a.field < b.field) return true; if (b.field < a.field) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(property_calc_request& a, property_calc_request& b) {     using std::swap;     swap(a.object, b.object);     swap(a.field, b.field);     swap(a.schema, b.schema); } size_t deep_sizeof(property_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.object) + deep_sizeof(x.field) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, property_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "object", x.object); write_field_to_record(record, "field", x.field); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, property_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(property_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.object, record, "object"); read_field_from_record(&x.field, record, "field"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(property_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, property_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(property_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.object)); boost::hash_combine(h, cradle::invoke_hash(x.field)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 140 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<meta_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<meta_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<meta_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "meta_calc_request")); } void structure_field_type_info_adder<meta_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["generator"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<meta_calc_request>().generator)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<meta_calc_request>().schema)>(),             none); } bool operator==(meta_calc_request const& a, meta_calc_request const& b) { return a.generator == b.generator && a.schema == b.schema; } bool operator!=(meta_calc_request const& a, meta_calc_request const& b) { return !(a == b); } bool operator<(meta_calc_request const& a, meta_calc_request const& b) { if (a.generator < b.generator) return true; if (b.generator < a.generator) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(meta_calc_request& a, meta_calc_request& b) {     using std::swap;     swap(a.generator, b.generator);     swap(a.schema, b.schema); } size_t deep_sizeof(meta_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.generator) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, meta_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "generator", x.generator); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, meta_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(meta_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.generator, record, "generator"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(meta_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, meta_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(meta_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.generator)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 147 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<cast_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<cast_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<cast_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "cast_calc_request")); } void structure_field_type_info_adder<cast_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<cast_calc_request>().schema)>(),             none);    (*fields)["object"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<cast_calc_request>().object)>(),             none); } bool operator==(cast_calc_request const& a, cast_calc_request const& b) { return a.schema == b.schema && a.object == b.object; } bool operator!=(cast_calc_request const& a, cast_calc_request const& b) { return !(a == b); } bool operator<(cast_calc_request const& a, cast_calc_request const& b) { if (a.schema < b.schema) return true; if (b.schema < a.schema) return false; if (a.object < b.object) return true; if (b.object < a.object) return false;     return false; } void swap(cast_calc_request& a, cast_calc_request& b) {     using std::swap;     swap(a.schema, b.schema);     swap(a.object, b.object); } size_t deep_sizeof(cast_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.schema) + deep_sizeof(x.object) ; } void write_fields_to_record(cradle::dynamic_map& record, cast_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "schema", x.schema); write_field_to_record(record, "object", x.object); } void to_dynamic(cradle::dynamic* v, cast_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(cast_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.schema, record, "schema"); read_field_from_record(&x.object, record, "object"); } void from_dynamic(cast_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, cast_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(cast_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.schema)); boost::hash_combine(h, cradle::invoke_hash(x.object));  return h; }} namespace cradle { 

#line 154 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<let_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<let_calc_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<let_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "let_calc_request")); } void structure_field_type_info_adder<let_calc_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["variables"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<let_calc_request>().variables)>(),             none);    (*fields)["in"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<let_calc_request>().in)>(),             none); } bool operator==(let_calc_request const& a, let_calc_request const& b) { return a.variables == b.variables && a.in == b.in; } bool operator!=(let_calc_request const& a, let_calc_request const& b) { return !(a == b); } bool operator<(let_calc_request const& a, let_calc_request const& b) { if (a.variables < b.variables) return true; if (b.variables < a.variables) return false; if (a.in < b.in) return true; if (b.in < a.in) return false;     return false; } void swap(let_calc_request& a, let_calc_request& b) {     using std::swap;     swap(a.variables, b.variables);     swap(a.in, b.in); } size_t deep_sizeof(let_calc_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.variables) + deep_sizeof(x.in) ; } void write_fields_to_record(cradle::dynamic_map& record, let_calc_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "variables", x.variables); write_field_to_record(record, "in", x.in); } void to_dynamic(cradle::dynamic* v, let_calc_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(let_calc_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.variables, record, "variables"); read_field_from_record(&x.in, record, "in"); } void from_dynamic(let_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, let_calc_request const& x) { return s << to_dynamic(x); } size_t hash_value(let_calc_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.variables)); boost::hash_combine(h, cradle::invoke_hash(x.in));  return h; }} namespace cradle { 

#line 161 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { void definitive_type_info_query<results_api_generated_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<results_api_generated_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<results_api_generated_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "results_api_generated_request")); } void structure_field_type_info_adder<results_api_generated_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["context_id"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<results_api_generated_request>().context_id)>(),             none);    (*fields)["request"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<results_api_generated_request>().request)>(),             none); } bool operator==(results_api_generated_request const& a, results_api_generated_request const& b) { return a.context_id == b.context_id && a.request == b.request; } bool operator!=(results_api_generated_request const& a, results_api_generated_request const& b) { return !(a == b); } bool operator<(results_api_generated_request const& a, results_api_generated_request const& b) { if (a.context_id < b.context_id) return true; if (b.context_id < a.context_id) return false; if (a.request < b.request) return true; if (b.request < a.request) return false;     return false; } void swap(results_api_generated_request& a, results_api_generated_request& b) {     using std::swap;     swap(a.context_id, b.context_id);     swap(a.request, b.request); } size_t deep_sizeof(results_api_generated_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.context_id) + deep_sizeof(x.request) ; } void write_fields_to_record(cradle::dynamic_map& record, results_api_generated_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "context_id", x.context_id); write_field_to_record(record, "request", x.request); } void to_dynamic(cradle::dynamic* v, results_api_generated_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(results_api_generated_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.context_id, record, "context_id"); read_field_from_record(&x.request, record, "request"); } void from_dynamic(results_api_generated_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, results_api_generated_request const& x) { return s << to_dynamic(x); } size_t hash_value(results_api_generated_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.context_id)); boost::hash_combine(h, cradle::invoke_hash(x.request));  return h; }} namespace cradle { 

}

namespace cradle {
void add_src_cradle_websocket_types_api(cradle::api_implementation& api)
{
register_api_named_type(     api,     "calculation_request",     0,     "",     get_definitive_type_info<calculation_request>());register_api_named_type(     api,     "execution_host_selection",     0,     "TODO: Maybe come up with a better name for this.",     get_definitive_type_info<execution_host_selection>());register_api_named_type(     api,     "function_application",     0,     "",     get_definitive_type_info<function_application>());register_api_named_type(     api,     "lambda_calculation",     0,     "",     get_definitive_type_info<lambda_calculation>());register_api_named_type(     api,     "array_calc_request",     0,     "",     get_definitive_type_info<array_calc_request>());register_api_named_type(     api,     "object_calc_request",     0,     "",     get_definitive_type_info<object_calc_request>());register_api_named_type(     api,     "item_calc_request",     0,     "",     get_definitive_type_info<item_calc_request>());register_api_named_type(     api,     "property_calc_request",     0,     "",     get_definitive_type_info<property_calc_request>());register_api_named_type(     api,     "meta_calc_request",     0,     "",     get_definitive_type_info<meta_calc_request>());register_api_named_type(     api,     "cast_calc_request",     0,     "",     get_definitive_type_info<cast_calc_request>());register_api_named_type(     api,     "let_calc_request",     0,     "",     get_definitive_type_info<let_calc_request>());register_api_named_type(     api,     "results_api_generated_request",     0,     "",     get_definitive_type_info<results_api_generated_request>());
}

}
