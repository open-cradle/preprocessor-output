// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#include <algorithm>
#include <typeinfo>
#include "types.hpp"
#include <cradle/typing/core/preprocessed.h>
#include <boost/algorithm/string/case_conv.hpp>

namespace cradle {

#line 10 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_service_id>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_service_id>()); } void type_info_query<thinknode_service_id>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_service_id")); } void enum_type_info_query<thinknode_service_id>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["iam"] =  cradle::api_enum_value_info( "");values["apm"] =  cradle::api_enum_value_info( "");values["iss"] =  cradle::api_enum_value_info( "");values["calc"] =  cradle::api_enum_value_info( "");values["cas"] =  cradle::api_enum_value_info( "");values["rks"] =  cradle::api_enum_value_info( "");values["immutable"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_service_id value) {     switch (value)     { case thinknode_service_id::IAM: return "iam";case thinknode_service_id::APM: return "apm";case thinknode_service_id::ISS: return "iss";case thinknode_service_id::CALC: return "calc";case thinknode_service_id::CAS: return "cas";case thinknode_service_id::RKS: return "rks";case thinknode_service_id::IMMUTABLE: return "immutable";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_service_id") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_service_id x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_service_id* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "iam")     {         *x = thinknode_service_id::IAM;         return;     };    if (boost::to_lower_copy(s) == "apm")     {         *x = thinknode_service_id::APM;         return;     };    if (boost::to_lower_copy(s) == "iss")     {         *x = thinknode_service_id::ISS;         return;     };    if (boost::to_lower_copy(s) == "calc")     {         *x = thinknode_service_id::CALC;         return;     };    if (boost::to_lower_copy(s) == "cas")     {         *x = thinknode_service_id::CAS;         return;     };    if (boost::to_lower_copy(s) == "rks")     {         *x = thinknode_service_id::RKS;         return;     };    if (boost::to_lower_copy(s) == "immutable")     {         *x = thinknode_service_id::IMMUTABLE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_service_id") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_service_id const& x) {     s << get_value_id(x);     return s; } 

#line 22 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_session>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_session>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_session>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_session")); } void structure_field_type_info_adder<thinknode_session>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["api_url"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_session>().api_url)>(),             none);    (*fields)["access_token"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_session>().access_token)>(),             none); } bool operator==(thinknode_session const& a, thinknode_session const& b) { return a.api_url == b.api_url && a.access_token == b.access_token; } bool operator!=(thinknode_session const& a, thinknode_session const& b) { return !(a == b); } bool operator<(thinknode_session const& a, thinknode_session const& b) { if (a.api_url < b.api_url) return true; if (b.api_url < a.api_url) return false; if (a.access_token < b.access_token) return true; if (b.access_token < a.access_token) return false;     return false; } void swap(thinknode_session& a, thinknode_session& b) {     using std::swap;     swap(a.api_url, b.api_url);     swap(a.access_token, b.access_token); } size_t deep_sizeof(thinknode_session const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.api_url) + deep_sizeof(x.access_token) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_session const& x) { using cradle::write_field_to_record; write_field_to_record(record, "api_url", x.api_url); write_field_to_record(record, "access_token", x.access_token); } void to_dynamic(cradle::dynamic* v, thinknode_session const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_session& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.api_url, record, "api_url"); read_field_from_record(&x.access_token, record, "access_token"); } void from_dynamic(thinknode_session* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_session const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_session const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.api_url)); boost::hash_combine(h, cradle::invoke_hash(x.access_token));  return h; }} namespace cradle { 

#line 45 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_type_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_type_info_tag>()); } void type_info_query<thinknode_type_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_type_info_tag")); } void enum_type_info_query<thinknode_type_info_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["array_type"] =  cradle::api_enum_value_info( "");values["blob_type"] =  cradle::api_enum_value_info( "");values["boolean_type"] =  cradle::api_enum_value_info( "");values["datetime_type"] =  cradle::api_enum_value_info( "");values["dynamic_type"] =  cradle::api_enum_value_info( "");values["enum_type"] =  cradle::api_enum_value_info( "");values["float_type"] =  cradle::api_enum_value_info( "");values["integer_type"] =  cradle::api_enum_value_info( "");values["map_type"] =  cradle::api_enum_value_info( "");values["named_type"] =  cradle::api_enum_value_info( "");values["nil_type"] =  cradle::api_enum_value_info( "");values["optional_type"] =  cradle::api_enum_value_info( "");values["reference_type"] =  cradle::api_enum_value_info( "");values["string_type"] =  cradle::api_enum_value_info( "");values["structure_type"] =  cradle::api_enum_value_info( "");values["union_type"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_type_info_tag value) {     switch (value)     { case thinknode_type_info_tag::ARRAY_TYPE: return "array_type";case thinknode_type_info_tag::BLOB_TYPE: return "blob_type";case thinknode_type_info_tag::BOOLEAN_TYPE: return "boolean_type";case thinknode_type_info_tag::DATETIME_TYPE: return "datetime_type";case thinknode_type_info_tag::DYNAMIC_TYPE: return "dynamic_type";case thinknode_type_info_tag::ENUM_TYPE: return "enum_type";case thinknode_type_info_tag::FLOAT_TYPE: return "float_type";case thinknode_type_info_tag::INTEGER_TYPE: return "integer_type";case thinknode_type_info_tag::MAP_TYPE: return "map_type";case thinknode_type_info_tag::NAMED_TYPE: return "named_type";case thinknode_type_info_tag::NIL_TYPE: return "nil_type";case thinknode_type_info_tag::OPTIONAL_TYPE: return "optional_type";case thinknode_type_info_tag::REFERENCE_TYPE: return "reference_type";case thinknode_type_info_tag::STRING_TYPE: return "string_type";case thinknode_type_info_tag::STRUCTURE_TYPE: return "structure_type";case thinknode_type_info_tag::UNION_TYPE: return "union_type";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_type_info_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_type_info_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_type_info_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "array_type")     {         *x = thinknode_type_info_tag::ARRAY_TYPE;         return;     };    if (boost::to_lower_copy(s) == "blob_type")     {         *x = thinknode_type_info_tag::BLOB_TYPE;         return;     };    if (boost::to_lower_copy(s) == "boolean_type")     {         *x = thinknode_type_info_tag::BOOLEAN_TYPE;         return;     };    if (boost::to_lower_copy(s) == "datetime_type")     {         *x = thinknode_type_info_tag::DATETIME_TYPE;         return;     };    if (boost::to_lower_copy(s) == "dynamic_type")     {         *x = thinknode_type_info_tag::DYNAMIC_TYPE;         return;     };    if (boost::to_lower_copy(s) == "enum_type")     {         *x = thinknode_type_info_tag::ENUM_TYPE;         return;     };    if (boost::to_lower_copy(s) == "float_type")     {         *x = thinknode_type_info_tag::FLOAT_TYPE;         return;     };    if (boost::to_lower_copy(s) == "integer_type")     {         *x = thinknode_type_info_tag::INTEGER_TYPE;         return;     };    if (boost::to_lower_copy(s) == "map_type")     {         *x = thinknode_type_info_tag::MAP_TYPE;         return;     };    if (boost::to_lower_copy(s) == "named_type")     {         *x = thinknode_type_info_tag::NAMED_TYPE;         return;     };    if (boost::to_lower_copy(s) == "nil_type")     {         *x = thinknode_type_info_tag::NIL_TYPE;         return;     };    if (boost::to_lower_copy(s) == "optional_type")     {         *x = thinknode_type_info_tag::OPTIONAL_TYPE;         return;     };    if (boost::to_lower_copy(s) == "reference_type")     {         *x = thinknode_type_info_tag::REFERENCE_TYPE;         return;     };    if (boost::to_lower_copy(s) == "string_type")     {         *x = thinknode_type_info_tag::STRING_TYPE;         return;     };    if (boost::to_lower_copy(s) == "structure_type")     {         *x = thinknode_type_info_tag::STRUCTURE_TYPE;         return;     };    if (boost::to_lower_copy(s) == "union_type")     {         *x = thinknode_type_info_tag::UNION_TYPE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_type_info_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_type_info_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["array_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_array_info>());    members["blob_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_blob_type>());    members["boolean_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_boolean_type>());    members["datetime_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_datetime_type>());    members["dynamic_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_dynamic_type>());    members["enum_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_enum_info>());    members["float_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_float_type>());    members["integer_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_integer_type>());    members["map_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_map_info>());    members["named_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_named_type_reference>());    members["nil_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_nil_type>());    members["optional_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_type_info>());    members["reference_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_type_info>());    members["string_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_string_type>());    members["structure_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_structure_info>());    members["union_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_union_info>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_type_info")); } thinknode_type_info make_thinknode_type_info_with_array_type(thinknode_array_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::ARRAY_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_array_type(thinknode_array_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::ARRAY_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_blob_type(thinknode_blob_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::BLOB_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_blob_type(thinknode_blob_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::BLOB_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_boolean_type(thinknode_boolean_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::BOOLEAN_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_boolean_type(thinknode_boolean_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::BOOLEAN_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_datetime_type(thinknode_datetime_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::DATETIME_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_datetime_type(thinknode_datetime_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::DATETIME_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_dynamic_type(thinknode_dynamic_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::DYNAMIC_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_dynamic_type(thinknode_dynamic_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::DYNAMIC_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_enum_type(thinknode_enum_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::ENUM_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_enum_type(thinknode_enum_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::ENUM_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_float_type(thinknode_float_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::FLOAT_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_float_type(thinknode_float_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::FLOAT_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_integer_type(thinknode_integer_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::INTEGER_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_integer_type(thinknode_integer_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::INTEGER_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_map_type(thinknode_map_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::MAP_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_map_type(thinknode_map_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::MAP_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_named_type(thinknode_named_type_reference const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::NAMED_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_named_type(thinknode_named_type_reference&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::NAMED_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_nil_type(thinknode_nil_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::NIL_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_nil_type(thinknode_nil_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::NIL_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_optional_type(thinknode_type_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::OPTIONAL_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_optional_type(thinknode_type_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::OPTIONAL_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_reference_type(thinknode_type_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::REFERENCE_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_reference_type(thinknode_type_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::REFERENCE_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_string_type(thinknode_string_type const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::STRING_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_string_type(thinknode_string_type&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::STRING_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_structure_type(thinknode_structure_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::STRUCTURE_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_structure_type(thinknode_structure_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::STRUCTURE_TYPE; s.contents_ = std::move(x); return s; } thinknode_type_info make_thinknode_type_info_with_union_type(thinknode_union_info const& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::UNION_TYPE; s.contents_ = x; return s; } thinknode_type_info make_thinknode_type_info_with_union_type(thinknode_union_info&& x) { thinknode_type_info s; s.type = thinknode_type_info_tag::UNION_TYPE; s.contents_ = std::move(x); return s; } thinknode_array_info const& as_array_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::ARRAY_TYPE); return std::any_cast<thinknode_array_info const& >(x.contents_); } thinknode_blob_type const& as_blob_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::BLOB_TYPE); return std::any_cast<thinknode_blob_type const& >(x.contents_); } thinknode_boolean_type const& as_boolean_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::BOOLEAN_TYPE); return std::any_cast<thinknode_boolean_type const& >(x.contents_); } thinknode_datetime_type const& as_datetime_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::DATETIME_TYPE); return std::any_cast<thinknode_datetime_type const& >(x.contents_); } thinknode_dynamic_type const& as_dynamic_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::DYNAMIC_TYPE); return std::any_cast<thinknode_dynamic_type const& >(x.contents_); } thinknode_enum_info const& as_enum_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::ENUM_TYPE); return std::any_cast<thinknode_enum_info const& >(x.contents_); } thinknode_float_type const& as_float_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::FLOAT_TYPE); return std::any_cast<thinknode_float_type const& >(x.contents_); } thinknode_integer_type const& as_integer_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::INTEGER_TYPE); return std::any_cast<thinknode_integer_type const& >(x.contents_); } thinknode_map_info const& as_map_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::MAP_TYPE); return std::any_cast<thinknode_map_info const& >(x.contents_); } thinknode_named_type_reference const& as_named_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::NAMED_TYPE); return std::any_cast<thinknode_named_type_reference const& >(x.contents_); } thinknode_nil_type const& as_nil_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::NIL_TYPE); return std::any_cast<thinknode_nil_type const& >(x.contents_); } thinknode_type_info const& as_optional_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::OPTIONAL_TYPE); return std::any_cast<thinknode_type_info const& >(x.contents_); } thinknode_type_info const& as_reference_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::REFERENCE_TYPE); return std::any_cast<thinknode_type_info const& >(x.contents_); } thinknode_string_type const& as_string_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::STRING_TYPE); return std::any_cast<thinknode_string_type const& >(x.contents_); } thinknode_structure_info const& as_structure_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::STRUCTURE_TYPE); return std::any_cast<thinknode_structure_info const& >(x.contents_); } thinknode_union_info const& as_union_type(thinknode_type_info const& x) { assert(x.type == thinknode_type_info_tag::UNION_TYPE); return std::any_cast<thinknode_union_info const& >(x.contents_); } thinknode_array_info& as_array_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::ARRAY_TYPE); return std::any_cast<thinknode_array_info&>(x.contents_); } thinknode_blob_type& as_blob_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::BLOB_TYPE); return std::any_cast<thinknode_blob_type&>(x.contents_); } thinknode_boolean_type& as_boolean_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::BOOLEAN_TYPE); return std::any_cast<thinknode_boolean_type&>(x.contents_); } thinknode_datetime_type& as_datetime_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::DATETIME_TYPE); return std::any_cast<thinknode_datetime_type&>(x.contents_); } thinknode_dynamic_type& as_dynamic_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::DYNAMIC_TYPE); return std::any_cast<thinknode_dynamic_type&>(x.contents_); } thinknode_enum_info& as_enum_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::ENUM_TYPE); return std::any_cast<thinknode_enum_info&>(x.contents_); } thinknode_float_type& as_float_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::FLOAT_TYPE); return std::any_cast<thinknode_float_type&>(x.contents_); } thinknode_integer_type& as_integer_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::INTEGER_TYPE); return std::any_cast<thinknode_integer_type&>(x.contents_); } thinknode_map_info& as_map_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::MAP_TYPE); return std::any_cast<thinknode_map_info&>(x.contents_); } thinknode_named_type_reference& as_named_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::NAMED_TYPE); return std::any_cast<thinknode_named_type_reference&>(x.contents_); } thinknode_nil_type& as_nil_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::NIL_TYPE); return std::any_cast<thinknode_nil_type&>(x.contents_); } thinknode_type_info& as_optional_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::OPTIONAL_TYPE); return std::any_cast<thinknode_type_info&>(x.contents_); } thinknode_type_info& as_reference_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::REFERENCE_TYPE); return std::any_cast<thinknode_type_info&>(x.contents_); } thinknode_string_type& as_string_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::STRING_TYPE); return std::any_cast<thinknode_string_type&>(x.contents_); } thinknode_structure_info& as_structure_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::STRUCTURE_TYPE); return std::any_cast<thinknode_structure_info&>(x.contents_); } thinknode_union_info& as_union_type(thinknode_type_info& x) { assert(x.type == thinknode_type_info_tag::UNION_TYPE); return std::any_cast<thinknode_union_info&>(x.contents_); } void set_to_array_type(thinknode_type_info& x, thinknode_array_info const& y) { x.type = thinknode_type_info_tag::ARRAY_TYPE; x.contents_ = y; } void set_to_array_type(thinknode_type_info& x, thinknode_array_info&& y) { x.type = thinknode_type_info_tag::ARRAY_TYPE; x.contents_ = std::move(y); } void set_to_blob_type(thinknode_type_info& x, thinknode_blob_type const& y) { x.type = thinknode_type_info_tag::BLOB_TYPE; x.contents_ = y; } void set_to_blob_type(thinknode_type_info& x, thinknode_blob_type&& y) { x.type = thinknode_type_info_tag::BLOB_TYPE; x.contents_ = std::move(y); } void set_to_boolean_type(thinknode_type_info& x, thinknode_boolean_type const& y) { x.type = thinknode_type_info_tag::BOOLEAN_TYPE; x.contents_ = y; } void set_to_boolean_type(thinknode_type_info& x, thinknode_boolean_type&& y) { x.type = thinknode_type_info_tag::BOOLEAN_TYPE; x.contents_ = std::move(y); } void set_to_datetime_type(thinknode_type_info& x, thinknode_datetime_type const& y) { x.type = thinknode_type_info_tag::DATETIME_TYPE; x.contents_ = y; } void set_to_datetime_type(thinknode_type_info& x, thinknode_datetime_type&& y) { x.type = thinknode_type_info_tag::DATETIME_TYPE; x.contents_ = std::move(y); } void set_to_dynamic_type(thinknode_type_info& x, thinknode_dynamic_type const& y) { x.type = thinknode_type_info_tag::DYNAMIC_TYPE; x.contents_ = y; } void set_to_dynamic_type(thinknode_type_info& x, thinknode_dynamic_type&& y) { x.type = thinknode_type_info_tag::DYNAMIC_TYPE; x.contents_ = std::move(y); } void set_to_enum_type(thinknode_type_info& x, thinknode_enum_info const& y) { x.type = thinknode_type_info_tag::ENUM_TYPE; x.contents_ = y; } void set_to_enum_type(thinknode_type_info& x, thinknode_enum_info&& y) { x.type = thinknode_type_info_tag::ENUM_TYPE; x.contents_ = std::move(y); } void set_to_float_type(thinknode_type_info& x, thinknode_float_type const& y) { x.type = thinknode_type_info_tag::FLOAT_TYPE; x.contents_ = y; } void set_to_float_type(thinknode_type_info& x, thinknode_float_type&& y) { x.type = thinknode_type_info_tag::FLOAT_TYPE; x.contents_ = std::move(y); } void set_to_integer_type(thinknode_type_info& x, thinknode_integer_type const& y) { x.type = thinknode_type_info_tag::INTEGER_TYPE; x.contents_ = y; } void set_to_integer_type(thinknode_type_info& x, thinknode_integer_type&& y) { x.type = thinknode_type_info_tag::INTEGER_TYPE; x.contents_ = std::move(y); } void set_to_map_type(thinknode_type_info& x, thinknode_map_info const& y) { x.type = thinknode_type_info_tag::MAP_TYPE; x.contents_ = y; } void set_to_map_type(thinknode_type_info& x, thinknode_map_info&& y) { x.type = thinknode_type_info_tag::MAP_TYPE; x.contents_ = std::move(y); } void set_to_named_type(thinknode_type_info& x, thinknode_named_type_reference const& y) { x.type = thinknode_type_info_tag::NAMED_TYPE; x.contents_ = y; } void set_to_named_type(thinknode_type_info& x, thinknode_named_type_reference&& y) { x.type = thinknode_type_info_tag::NAMED_TYPE; x.contents_ = std::move(y); } void set_to_nil_type(thinknode_type_info& x, thinknode_nil_type const& y) { x.type = thinknode_type_info_tag::NIL_TYPE; x.contents_ = y; } void set_to_nil_type(thinknode_type_info& x, thinknode_nil_type&& y) { x.type = thinknode_type_info_tag::NIL_TYPE; x.contents_ = std::move(y); } void set_to_optional_type(thinknode_type_info& x, thinknode_type_info const& y) { x.type = thinknode_type_info_tag::OPTIONAL_TYPE; x.contents_ = y; } void set_to_optional_type(thinknode_type_info& x, thinknode_type_info&& y) { x.type = thinknode_type_info_tag::OPTIONAL_TYPE; x.contents_ = std::move(y); } void set_to_reference_type(thinknode_type_info& x, thinknode_type_info const& y) { x.type = thinknode_type_info_tag::REFERENCE_TYPE; x.contents_ = y; } void set_to_reference_type(thinknode_type_info& x, thinknode_type_info&& y) { x.type = thinknode_type_info_tag::REFERENCE_TYPE; x.contents_ = std::move(y); } void set_to_string_type(thinknode_type_info& x, thinknode_string_type const& y) { x.type = thinknode_type_info_tag::STRING_TYPE; x.contents_ = y; } void set_to_string_type(thinknode_type_info& x, thinknode_string_type&& y) { x.type = thinknode_type_info_tag::STRING_TYPE; x.contents_ = std::move(y); } void set_to_structure_type(thinknode_type_info& x, thinknode_structure_info const& y) { x.type = thinknode_type_info_tag::STRUCTURE_TYPE; x.contents_ = y; } void set_to_structure_type(thinknode_type_info& x, thinknode_structure_info&& y) { x.type = thinknode_type_info_tag::STRUCTURE_TYPE; x.contents_ = std::move(y); } void set_to_union_type(thinknode_type_info& x, thinknode_union_info const& y) { x.type = thinknode_type_info_tag::UNION_TYPE; x.contents_ = y; } void set_to_union_type(thinknode_type_info& x, thinknode_union_info&& y) { x.type = thinknode_type_info_tag::UNION_TYPE; x.contents_ = std::move(y); } bool operator==(thinknode_type_info const& a, thinknode_type_info const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_type_info_tag::ARRAY_TYPE: return as_array_type(a) == as_array_type(b); case thinknode_type_info_tag::BLOB_TYPE: return as_blob_type(a) == as_blob_type(b); case thinknode_type_info_tag::BOOLEAN_TYPE: return as_boolean_type(a) == as_boolean_type(b); case thinknode_type_info_tag::DATETIME_TYPE: return as_datetime_type(a) == as_datetime_type(b); case thinknode_type_info_tag::DYNAMIC_TYPE: return as_dynamic_type(a) == as_dynamic_type(b); case thinknode_type_info_tag::ENUM_TYPE: return as_enum_type(a) == as_enum_type(b); case thinknode_type_info_tag::FLOAT_TYPE: return as_float_type(a) == as_float_type(b); case thinknode_type_info_tag::INTEGER_TYPE: return as_integer_type(a) == as_integer_type(b); case thinknode_type_info_tag::MAP_TYPE: return as_map_type(a) == as_map_type(b); case thinknode_type_info_tag::NAMED_TYPE: return as_named_type(a) == as_named_type(b); case thinknode_type_info_tag::NIL_TYPE: return as_nil_type(a) == as_nil_type(b); case thinknode_type_info_tag::OPTIONAL_TYPE: return as_optional_type(a) == as_optional_type(b); case thinknode_type_info_tag::REFERENCE_TYPE: return as_reference_type(a) == as_reference_type(b); case thinknode_type_info_tag::STRING_TYPE: return as_string_type(a) == as_string_type(b); case thinknode_type_info_tag::STRUCTURE_TYPE: return as_structure_type(a) == as_structure_type(b); case thinknode_type_info_tag::UNION_TYPE: return as_union_type(a) == as_union_type(b); } return true; } bool operator!=(thinknode_type_info const& a, thinknode_type_info const& b) { return !(a == b); } bool operator<(thinknode_type_info const& a, thinknode_type_info const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_type_info_tag::ARRAY_TYPE: return as_array_type(a) < as_array_type(b); case thinknode_type_info_tag::BLOB_TYPE: return as_blob_type(a) < as_blob_type(b); case thinknode_type_info_tag::BOOLEAN_TYPE: return as_boolean_type(a) < as_boolean_type(b); case thinknode_type_info_tag::DATETIME_TYPE: return as_datetime_type(a) < as_datetime_type(b); case thinknode_type_info_tag::DYNAMIC_TYPE: return as_dynamic_type(a) < as_dynamic_type(b); case thinknode_type_info_tag::ENUM_TYPE: return as_enum_type(a) < as_enum_type(b); case thinknode_type_info_tag::FLOAT_TYPE: return as_float_type(a) < as_float_type(b); case thinknode_type_info_tag::INTEGER_TYPE: return as_integer_type(a) < as_integer_type(b); case thinknode_type_info_tag::MAP_TYPE: return as_map_type(a) < as_map_type(b); case thinknode_type_info_tag::NAMED_TYPE: return as_named_type(a) < as_named_type(b); case thinknode_type_info_tag::NIL_TYPE: return as_nil_type(a) < as_nil_type(b); case thinknode_type_info_tag::OPTIONAL_TYPE: return as_optional_type(a) < as_optional_type(b); case thinknode_type_info_tag::REFERENCE_TYPE: return as_reference_type(a) < as_reference_type(b); case thinknode_type_info_tag::STRING_TYPE: return as_string_type(a) < as_string_type(b); case thinknode_type_info_tag::STRUCTURE_TYPE: return as_structure_type(a) < as_structure_type(b); case thinknode_type_info_tag::UNION_TYPE: return as_union_type(a) < as_union_type(b); } return false; } size_t hash_value(thinknode_type_info const& x) {     switch (x.type)     { case thinknode_type_info_tag::ARRAY_TYPE: return cradle::invoke_hash(as_array_type(x)); case thinknode_type_info_tag::BLOB_TYPE: return cradle::invoke_hash(as_blob_type(x)); case thinknode_type_info_tag::BOOLEAN_TYPE: return cradle::invoke_hash(as_boolean_type(x)); case thinknode_type_info_tag::DATETIME_TYPE: return cradle::invoke_hash(as_datetime_type(x)); case thinknode_type_info_tag::DYNAMIC_TYPE: return cradle::invoke_hash(as_dynamic_type(x)); case thinknode_type_info_tag::ENUM_TYPE: return cradle::invoke_hash(as_enum_type(x)); case thinknode_type_info_tag::FLOAT_TYPE: return cradle::invoke_hash(as_float_type(x)); case thinknode_type_info_tag::INTEGER_TYPE: return cradle::invoke_hash(as_integer_type(x)); case thinknode_type_info_tag::MAP_TYPE: return cradle::invoke_hash(as_map_type(x)); case thinknode_type_info_tag::NAMED_TYPE: return cradle::invoke_hash(as_named_type(x)); case thinknode_type_info_tag::NIL_TYPE: return cradle::invoke_hash(as_nil_type(x)); case thinknode_type_info_tag::OPTIONAL_TYPE: return cradle::invoke_hash(as_optional_type(x)); case thinknode_type_info_tag::REFERENCE_TYPE: return cradle::invoke_hash(as_reference_type(x)); case thinknode_type_info_tag::STRING_TYPE: return cradle::invoke_hash(as_string_type(x)); case thinknode_type_info_tag::STRUCTURE_TYPE: return cradle::invoke_hash(as_structure_type(x)); case thinknode_type_info_tag::UNION_TYPE: return cradle::invoke_hash(as_union_type(x));      } assert(0); return 0; }void swap(thinknode_type_info& a, thinknode_type_info& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_type_info const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_type_info_tag::ARRAY_TYPE: to_dynamic(&s[dynamic("array_type")], as_array_type(x)); break; case thinknode_type_info_tag::BLOB_TYPE: to_dynamic(&s[dynamic("blob_type")], as_blob_type(x)); break; case thinknode_type_info_tag::BOOLEAN_TYPE: to_dynamic(&s[dynamic("boolean_type")], as_boolean_type(x)); break; case thinknode_type_info_tag::DATETIME_TYPE: to_dynamic(&s[dynamic("datetime_type")], as_datetime_type(x)); break; case thinknode_type_info_tag::DYNAMIC_TYPE: to_dynamic(&s[dynamic("dynamic_type")], as_dynamic_type(x)); break; case thinknode_type_info_tag::ENUM_TYPE: to_dynamic(&s[dynamic("enum_type")], as_enum_type(x)); break; case thinknode_type_info_tag::FLOAT_TYPE: to_dynamic(&s[dynamic("float_type")], as_float_type(x)); break; case thinknode_type_info_tag::INTEGER_TYPE: to_dynamic(&s[dynamic("integer_type")], as_integer_type(x)); break; case thinknode_type_info_tag::MAP_TYPE: to_dynamic(&s[dynamic("map_type")], as_map_type(x)); break; case thinknode_type_info_tag::NAMED_TYPE: to_dynamic(&s[dynamic("named_type")], as_named_type(x)); break; case thinknode_type_info_tag::NIL_TYPE: to_dynamic(&s[dynamic("nil_type")], as_nil_type(x)); break; case thinknode_type_info_tag::OPTIONAL_TYPE: to_dynamic(&s[dynamic("optional_type")], as_optional_type(x)); break; case thinknode_type_info_tag::REFERENCE_TYPE: to_dynamic(&s[dynamic("reference_type")], as_reference_type(x)); break; case thinknode_type_info_tag::STRING_TYPE: to_dynamic(&s[dynamic("string_type")], as_string_type(x)); break; case thinknode_type_info_tag::STRUCTURE_TYPE: to_dynamic(&s[dynamic("structure_type")], as_structure_type(x)); break; case thinknode_type_info_tag::UNION_TYPE: to_dynamic(&s[dynamic("union_type")], as_union_type(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_type_info_tag::ARRAY_TYPE:  { thinknode_array_info tmp; from_dynamic(&tmp, get_field(s, "array_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::BLOB_TYPE:  { thinknode_blob_type tmp; from_dynamic(&tmp, get_field(s, "blob_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::BOOLEAN_TYPE:  { thinknode_boolean_type tmp; from_dynamic(&tmp, get_field(s, "boolean_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::DATETIME_TYPE:  { thinknode_datetime_type tmp; from_dynamic(&tmp, get_field(s, "datetime_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::DYNAMIC_TYPE:  { thinknode_dynamic_type tmp; from_dynamic(&tmp, get_field(s, "dynamic_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::ENUM_TYPE:  { thinknode_enum_info tmp; from_dynamic(&tmp, get_field(s, "enum_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::FLOAT_TYPE:  { thinknode_float_type tmp; from_dynamic(&tmp, get_field(s, "float_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::INTEGER_TYPE:  { thinknode_integer_type tmp; from_dynamic(&tmp, get_field(s, "integer_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::MAP_TYPE:  { thinknode_map_info tmp; from_dynamic(&tmp, get_field(s, "map_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::NAMED_TYPE:  { thinknode_named_type_reference tmp; from_dynamic(&tmp, get_field(s, "named_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::NIL_TYPE:  { thinknode_nil_type tmp; from_dynamic(&tmp, get_field(s, "nil_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::OPTIONAL_TYPE:  { thinknode_type_info tmp; from_dynamic(&tmp, get_field(s, "optional_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::REFERENCE_TYPE:  { thinknode_type_info tmp; from_dynamic(&tmp, get_field(s, "reference_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::STRING_TYPE:  { thinknode_string_type tmp; from_dynamic(&tmp, get_field(s, "string_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::STRUCTURE_TYPE:  { thinknode_structure_info tmp; from_dynamic(&tmp, get_field(s, "structure_type")); x->contents_ = tmp; break;  } case thinknode_type_info_tag::UNION_TYPE:  { thinknode_union_info tmp; from_dynamic(&tmp, get_field(s, "union_type")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_type_info const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_type_info const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_type_info_tag::ARRAY_TYPE: size += deep_sizeof(as_array_type(x)); break; case thinknode_type_info_tag::BLOB_TYPE: size += deep_sizeof(as_blob_type(x)); break; case thinknode_type_info_tag::BOOLEAN_TYPE: size += deep_sizeof(as_boolean_type(x)); break; case thinknode_type_info_tag::DATETIME_TYPE: size += deep_sizeof(as_datetime_type(x)); break; case thinknode_type_info_tag::DYNAMIC_TYPE: size += deep_sizeof(as_dynamic_type(x)); break; case thinknode_type_info_tag::ENUM_TYPE: size += deep_sizeof(as_enum_type(x)); break; case thinknode_type_info_tag::FLOAT_TYPE: size += deep_sizeof(as_float_type(x)); break; case thinknode_type_info_tag::INTEGER_TYPE: size += deep_sizeof(as_integer_type(x)); break; case thinknode_type_info_tag::MAP_TYPE: size += deep_sizeof(as_map_type(x)); break; case thinknode_type_info_tag::NAMED_TYPE: size += deep_sizeof(as_named_type(x)); break; case thinknode_type_info_tag::NIL_TYPE: size += deep_sizeof(as_nil_type(x)); break; case thinknode_type_info_tag::OPTIONAL_TYPE: size += deep_sizeof(as_optional_type(x)); break; case thinknode_type_info_tag::REFERENCE_TYPE: size += deep_sizeof(as_reference_type(x)); break; case thinknode_type_info_tag::STRING_TYPE: size += deep_sizeof(as_string_type(x)); break; case thinknode_type_info_tag::STRUCTURE_TYPE: size += deep_sizeof(as_structure_type(x)); break; case thinknode_type_info_tag::UNION_TYPE: size += deep_sizeof(as_union_type(x)); break; } return size; } 

#line 75 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_calc_request_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_calc_request_tag>()); } void type_info_query<thinknode_calc_request_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_calc_request_tag")); } void enum_type_info_query<thinknode_calc_request_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["reference"] =  cradle::api_enum_value_info( "");values["value"] =  cradle::api_enum_value_info( "");values["function"] =  cradle::api_enum_value_info( "");values["array"] =  cradle::api_enum_value_info( "");values["item"] =  cradle::api_enum_value_info( "");values["object"] =  cradle::api_enum_value_info( "");values["property"] =  cradle::api_enum_value_info( "");values["let"] =  cradle::api_enum_value_info( "");values["variable"] =  cradle::api_enum_value_info( "");values["meta"] =  cradle::api_enum_value_info( "");values["cast"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_calc_request_tag value) {     switch (value)     { case thinknode_calc_request_tag::REFERENCE: return "reference";case thinknode_calc_request_tag::VALUE: return "value";case thinknode_calc_request_tag::FUNCTION: return "function";case thinknode_calc_request_tag::ARRAY: return "array";case thinknode_calc_request_tag::ITEM: return "item";case thinknode_calc_request_tag::OBJECT: return "object";case thinknode_calc_request_tag::PROPERTY: return "property";case thinknode_calc_request_tag::LET: return "let";case thinknode_calc_request_tag::VARIABLE: return "variable";case thinknode_calc_request_tag::META: return "meta";case thinknode_calc_request_tag::CAST: return "cast";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_calc_request_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_calc_request_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_calc_request_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "reference")     {         *x = thinknode_calc_request_tag::REFERENCE;         return;     };    if (boost::to_lower_copy(s) == "value")     {         *x = thinknode_calc_request_tag::VALUE;         return;     };    if (boost::to_lower_copy(s) == "function")     {         *x = thinknode_calc_request_tag::FUNCTION;         return;     };    if (boost::to_lower_copy(s) == "array")     {         *x = thinknode_calc_request_tag::ARRAY;         return;     };    if (boost::to_lower_copy(s) == "item")     {         *x = thinknode_calc_request_tag::ITEM;         return;     };    if (boost::to_lower_copy(s) == "object")     {         *x = thinknode_calc_request_tag::OBJECT;         return;     };    if (boost::to_lower_copy(s) == "property")     {         *x = thinknode_calc_request_tag::PROPERTY;         return;     };    if (boost::to_lower_copy(s) == "let")     {         *x = thinknode_calc_request_tag::LET;         return;     };    if (boost::to_lower_copy(s) == "variable")     {         *x = thinknode_calc_request_tag::VARIABLE;         return;     };    if (boost::to_lower_copy(s) == "meta")     {         *x = thinknode_calc_request_tag::META;         return;     };    if (boost::to_lower_copy(s) == "cast")     {         *x = thinknode_calc_request_tag::CAST;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_calc_request_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_calc_request_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_calc_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["reference"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<std::string>());    members["value"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<dynamic>());    members["function"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_function_application>());    members["array"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_array_calc>());    members["item"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_item_calc>());    members["object"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_object_calc>());    members["property"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_property_calc>());    members["let"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_let_calc>());    members["variable"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<std::string>());    members["meta"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_meta_calc>());    members["cast"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_cast_request>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_calc_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_calc_request")); } thinknode_calc_request make_thinknode_calc_request_with_reference(std::string const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::REFERENCE; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_reference(std::string&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::REFERENCE; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_value(dynamic const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::VALUE; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_value(dynamic&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::VALUE; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_function(thinknode_function_application const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::FUNCTION; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_function(thinknode_function_application&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::FUNCTION; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_array(thinknode_array_calc const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::ARRAY; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_array(thinknode_array_calc&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::ARRAY; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_item(thinknode_item_calc const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::ITEM; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_item(thinknode_item_calc&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::ITEM; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_object(thinknode_object_calc const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::OBJECT; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_object(thinknode_object_calc&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::OBJECT; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_property(thinknode_property_calc const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::PROPERTY; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_property(thinknode_property_calc&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::PROPERTY; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_let(thinknode_let_calc const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::LET; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_let(thinknode_let_calc&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::LET; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_variable(std::string const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::VARIABLE; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_variable(std::string&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::VARIABLE; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_meta(thinknode_meta_calc const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::META; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_meta(thinknode_meta_calc&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::META; s.contents_ = std::move(x); return s; } thinknode_calc_request make_thinknode_calc_request_with_cast(thinknode_cast_request const& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::CAST; s.contents_ = x; return s; } thinknode_calc_request make_thinknode_calc_request_with_cast(thinknode_cast_request&& x) { thinknode_calc_request s; s.type = thinknode_calc_request_tag::CAST; s.contents_ = std::move(x); return s; } std::string const& as_reference(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::REFERENCE); return std::any_cast<std::string const& >(x.contents_); } dynamic const& as_value(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::VALUE); return std::any_cast<dynamic const& >(x.contents_); } thinknode_function_application const& as_function(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::FUNCTION); return std::any_cast<thinknode_function_application const& >(x.contents_); } thinknode_array_calc const& as_array(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::ARRAY); return std::any_cast<thinknode_array_calc const& >(x.contents_); } thinknode_item_calc const& as_item(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::ITEM); return std::any_cast<thinknode_item_calc const& >(x.contents_); } thinknode_object_calc const& as_object(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::OBJECT); return std::any_cast<thinknode_object_calc const& >(x.contents_); } thinknode_property_calc const& as_property(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::PROPERTY); return std::any_cast<thinknode_property_calc const& >(x.contents_); } thinknode_let_calc const& as_let(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::LET); return std::any_cast<thinknode_let_calc const& >(x.contents_); } std::string const& as_variable(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::VARIABLE); return std::any_cast<std::string const& >(x.contents_); } thinknode_meta_calc const& as_meta(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::META); return std::any_cast<thinknode_meta_calc const& >(x.contents_); } thinknode_cast_request const& as_cast(thinknode_calc_request const& x) { assert(x.type == thinknode_calc_request_tag::CAST); return std::any_cast<thinknode_cast_request const& >(x.contents_); } std::string& as_reference(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::REFERENCE); return std::any_cast<std::string&>(x.contents_); } dynamic& as_value(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::VALUE); return std::any_cast<dynamic&>(x.contents_); } thinknode_function_application& as_function(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::FUNCTION); return std::any_cast<thinknode_function_application&>(x.contents_); } thinknode_array_calc& as_array(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::ARRAY); return std::any_cast<thinknode_array_calc&>(x.contents_); } thinknode_item_calc& as_item(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::ITEM); return std::any_cast<thinknode_item_calc&>(x.contents_); } thinknode_object_calc& as_object(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::OBJECT); return std::any_cast<thinknode_object_calc&>(x.contents_); } thinknode_property_calc& as_property(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::PROPERTY); return std::any_cast<thinknode_property_calc&>(x.contents_); } thinknode_let_calc& as_let(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::LET); return std::any_cast<thinknode_let_calc&>(x.contents_); } std::string& as_variable(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::VARIABLE); return std::any_cast<std::string&>(x.contents_); } thinknode_meta_calc& as_meta(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::META); return std::any_cast<thinknode_meta_calc&>(x.contents_); } thinknode_cast_request& as_cast(thinknode_calc_request& x) { assert(x.type == thinknode_calc_request_tag::CAST); return std::any_cast<thinknode_cast_request&>(x.contents_); } void set_to_reference(thinknode_calc_request& x, std::string const& y) { x.type = thinknode_calc_request_tag::REFERENCE; x.contents_ = y; } void set_to_reference(thinknode_calc_request& x, std::string&& y) { x.type = thinknode_calc_request_tag::REFERENCE; x.contents_ = std::move(y); } void set_to_value(thinknode_calc_request& x, dynamic const& y) { x.type = thinknode_calc_request_tag::VALUE; x.contents_ = y; } void set_to_value(thinknode_calc_request& x, dynamic&& y) { x.type = thinknode_calc_request_tag::VALUE; x.contents_ = std::move(y); } void set_to_function(thinknode_calc_request& x, thinknode_function_application const& y) { x.type = thinknode_calc_request_tag::FUNCTION; x.contents_ = y; } void set_to_function(thinknode_calc_request& x, thinknode_function_application&& y) { x.type = thinknode_calc_request_tag::FUNCTION; x.contents_ = std::move(y); } void set_to_array(thinknode_calc_request& x, thinknode_array_calc const& y) { x.type = thinknode_calc_request_tag::ARRAY; x.contents_ = y; } void set_to_array(thinknode_calc_request& x, thinknode_array_calc&& y) { x.type = thinknode_calc_request_tag::ARRAY; x.contents_ = std::move(y); } void set_to_item(thinknode_calc_request& x, thinknode_item_calc const& y) { x.type = thinknode_calc_request_tag::ITEM; x.contents_ = y; } void set_to_item(thinknode_calc_request& x, thinknode_item_calc&& y) { x.type = thinknode_calc_request_tag::ITEM; x.contents_ = std::move(y); } void set_to_object(thinknode_calc_request& x, thinknode_object_calc const& y) { x.type = thinknode_calc_request_tag::OBJECT; x.contents_ = y; } void set_to_object(thinknode_calc_request& x, thinknode_object_calc&& y) { x.type = thinknode_calc_request_tag::OBJECT; x.contents_ = std::move(y); } void set_to_property(thinknode_calc_request& x, thinknode_property_calc const& y) { x.type = thinknode_calc_request_tag::PROPERTY; x.contents_ = y; } void set_to_property(thinknode_calc_request& x, thinknode_property_calc&& y) { x.type = thinknode_calc_request_tag::PROPERTY; x.contents_ = std::move(y); } void set_to_let(thinknode_calc_request& x, thinknode_let_calc const& y) { x.type = thinknode_calc_request_tag::LET; x.contents_ = y; } void set_to_let(thinknode_calc_request& x, thinknode_let_calc&& y) { x.type = thinknode_calc_request_tag::LET; x.contents_ = std::move(y); } void set_to_variable(thinknode_calc_request& x, std::string const& y) { x.type = thinknode_calc_request_tag::VARIABLE; x.contents_ = y; } void set_to_variable(thinknode_calc_request& x, std::string&& y) { x.type = thinknode_calc_request_tag::VARIABLE; x.contents_ = std::move(y); } void set_to_meta(thinknode_calc_request& x, thinknode_meta_calc const& y) { x.type = thinknode_calc_request_tag::META; x.contents_ = y; } void set_to_meta(thinknode_calc_request& x, thinknode_meta_calc&& y) { x.type = thinknode_calc_request_tag::META; x.contents_ = std::move(y); } void set_to_cast(thinknode_calc_request& x, thinknode_cast_request const& y) { x.type = thinknode_calc_request_tag::CAST; x.contents_ = y; } void set_to_cast(thinknode_calc_request& x, thinknode_cast_request&& y) { x.type = thinknode_calc_request_tag::CAST; x.contents_ = std::move(y); } bool operator==(thinknode_calc_request const& a, thinknode_calc_request const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_calc_request_tag::REFERENCE: return as_reference(a) == as_reference(b); case thinknode_calc_request_tag::VALUE: return as_value(a) == as_value(b); case thinknode_calc_request_tag::FUNCTION: return as_function(a) == as_function(b); case thinknode_calc_request_tag::ARRAY: return as_array(a) == as_array(b); case thinknode_calc_request_tag::ITEM: return as_item(a) == as_item(b); case thinknode_calc_request_tag::OBJECT: return as_object(a) == as_object(b); case thinknode_calc_request_tag::PROPERTY: return as_property(a) == as_property(b); case thinknode_calc_request_tag::LET: return as_let(a) == as_let(b); case thinknode_calc_request_tag::VARIABLE: return as_variable(a) == as_variable(b); case thinknode_calc_request_tag::META: return as_meta(a) == as_meta(b); case thinknode_calc_request_tag::CAST: return as_cast(a) == as_cast(b); } return true; } bool operator!=(thinknode_calc_request const& a, thinknode_calc_request const& b) { return !(a == b); } bool operator<(thinknode_calc_request const& a, thinknode_calc_request const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_calc_request_tag::REFERENCE: return as_reference(a) < as_reference(b); case thinknode_calc_request_tag::VALUE: return as_value(a) < as_value(b); case thinknode_calc_request_tag::FUNCTION: return as_function(a) < as_function(b); case thinknode_calc_request_tag::ARRAY: return as_array(a) < as_array(b); case thinknode_calc_request_tag::ITEM: return as_item(a) < as_item(b); case thinknode_calc_request_tag::OBJECT: return as_object(a) < as_object(b); case thinknode_calc_request_tag::PROPERTY: return as_property(a) < as_property(b); case thinknode_calc_request_tag::LET: return as_let(a) < as_let(b); case thinknode_calc_request_tag::VARIABLE: return as_variable(a) < as_variable(b); case thinknode_calc_request_tag::META: return as_meta(a) < as_meta(b); case thinknode_calc_request_tag::CAST: return as_cast(a) < as_cast(b); } return false; } size_t hash_value(thinknode_calc_request const& x) {     switch (x.type)     { case thinknode_calc_request_tag::REFERENCE: return cradle::invoke_hash(as_reference(x)); case thinknode_calc_request_tag::VALUE: return cradle::invoke_hash(as_value(x)); case thinknode_calc_request_tag::FUNCTION: return cradle::invoke_hash(as_function(x)); case thinknode_calc_request_tag::ARRAY: return cradle::invoke_hash(as_array(x)); case thinknode_calc_request_tag::ITEM: return cradle::invoke_hash(as_item(x)); case thinknode_calc_request_tag::OBJECT: return cradle::invoke_hash(as_object(x)); case thinknode_calc_request_tag::PROPERTY: return cradle::invoke_hash(as_property(x)); case thinknode_calc_request_tag::LET: return cradle::invoke_hash(as_let(x)); case thinknode_calc_request_tag::VARIABLE: return cradle::invoke_hash(as_variable(x)); case thinknode_calc_request_tag::META: return cradle::invoke_hash(as_meta(x)); case thinknode_calc_request_tag::CAST: return cradle::invoke_hash(as_cast(x));      } assert(0); return 0; }void swap(thinknode_calc_request& a, thinknode_calc_request& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_calc_request const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_calc_request_tag::REFERENCE: to_dynamic(&s[dynamic("reference")], as_reference(x)); break; case thinknode_calc_request_tag::VALUE: to_dynamic(&s[dynamic("value")], as_value(x)); break; case thinknode_calc_request_tag::FUNCTION: to_dynamic(&s[dynamic("function")], as_function(x)); break; case thinknode_calc_request_tag::ARRAY: to_dynamic(&s[dynamic("array")], as_array(x)); break; case thinknode_calc_request_tag::ITEM: to_dynamic(&s[dynamic("item")], as_item(x)); break; case thinknode_calc_request_tag::OBJECT: to_dynamic(&s[dynamic("object")], as_object(x)); break; case thinknode_calc_request_tag::PROPERTY: to_dynamic(&s[dynamic("property")], as_property(x)); break; case thinknode_calc_request_tag::LET: to_dynamic(&s[dynamic("let")], as_let(x)); break; case thinknode_calc_request_tag::VARIABLE: to_dynamic(&s[dynamic("variable")], as_variable(x)); break; case thinknode_calc_request_tag::META: to_dynamic(&s[dynamic("meta")], as_meta(x)); break; case thinknode_calc_request_tag::CAST: to_dynamic(&s[dynamic("cast")], as_cast(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_calc_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_calc_request_tag::REFERENCE:  { std::string tmp; from_dynamic(&tmp, get_field(s, "reference")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::VALUE:  { dynamic tmp; from_dynamic(&tmp, get_field(s, "value")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::FUNCTION:  { thinknode_function_application tmp; from_dynamic(&tmp, get_field(s, "function")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::ARRAY:  { thinknode_array_calc tmp; from_dynamic(&tmp, get_field(s, "array")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::ITEM:  { thinknode_item_calc tmp; from_dynamic(&tmp, get_field(s, "item")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::OBJECT:  { thinknode_object_calc tmp; from_dynamic(&tmp, get_field(s, "object")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::PROPERTY:  { thinknode_property_calc tmp; from_dynamic(&tmp, get_field(s, "property")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::LET:  { thinknode_let_calc tmp; from_dynamic(&tmp, get_field(s, "let")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::VARIABLE:  { std::string tmp; from_dynamic(&tmp, get_field(s, "variable")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::META:  { thinknode_meta_calc tmp; from_dynamic(&tmp, get_field(s, "meta")); x->contents_ = tmp; break;  } case thinknode_calc_request_tag::CAST:  { thinknode_cast_request tmp; from_dynamic(&tmp, get_field(s, "cast")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_calc_request const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_calc_request const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_calc_request_tag::REFERENCE: size += deep_sizeof(as_reference(x)); break; case thinknode_calc_request_tag::VALUE: size += deep_sizeof(as_value(x)); break; case thinknode_calc_request_tag::FUNCTION: size += deep_sizeof(as_function(x)); break; case thinknode_calc_request_tag::ARRAY: size += deep_sizeof(as_array(x)); break; case thinknode_calc_request_tag::ITEM: size += deep_sizeof(as_item(x)); break; case thinknode_calc_request_tag::OBJECT: size += deep_sizeof(as_object(x)); break; case thinknode_calc_request_tag::PROPERTY: size += deep_sizeof(as_property(x)); break; case thinknode_calc_request_tag::LET: size += deep_sizeof(as_let(x)); break; case thinknode_calc_request_tag::VARIABLE: size += deep_sizeof(as_variable(x)); break; case thinknode_calc_request_tag::META: size += deep_sizeof(as_meta(x)); break; case thinknode_calc_request_tag::CAST: size += deep_sizeof(as_cast(x)); break; } return size; } 

#line 91 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_function_application>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_function_application>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_function_application>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_application")); } void structure_field_type_info_adder<thinknode_function_application>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["account"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_application>().account)>(),             none);    (*fields)["app"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_application>().app)>(),             none);    (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_application>().name)>(),             none);    (*fields)["level"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_application>().level)>(),             none);    (*fields)["args"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_application>().args)>(),             none); } bool operator==(thinknode_function_application const& a, thinknode_function_application const& b) { return a.account == b.account && a.app == b.app && a.name == b.name && a.level == b.level && a.args == b.args; } bool operator!=(thinknode_function_application const& a, thinknode_function_application const& b) { return !(a == b); } bool operator<(thinknode_function_application const& a, thinknode_function_application const& b) { if (a.account < b.account) return true; if (b.account < a.account) return false; if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.level < b.level) return true; if (b.level < a.level) return false; if (a.args < b.args) return true; if (b.args < a.args) return false;     return false; } void swap(thinknode_function_application& a, thinknode_function_application& b) {     using std::swap;     swap(a.account, b.account);     swap(a.app, b.app);     swap(a.name, b.name);     swap(a.level, b.level);     swap(a.args, b.args); } size_t deep_sizeof(thinknode_function_application const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.account) + deep_sizeof(x.app) + deep_sizeof(x.name) + deep_sizeof(x.level) + deep_sizeof(x.args) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_application const& x) { using cradle::write_field_to_record; write_field_to_record(record, "account", x.account); write_field_to_record(record, "app", x.app); write_field_to_record(record, "name", x.name); write_field_to_record(record, "level", x.level); write_field_to_record(record, "args", x.args); } void to_dynamic(cradle::dynamic* v, thinknode_function_application const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_function_application& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.account, record, "account"); read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.level, record, "level"); read_field_from_record(&x.args, record, "args"); } void from_dynamic(thinknode_function_application* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_function_application const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_function_application const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.account)); boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.level)); boost::hash_combine(h, cradle::invoke_hash(x.args));  return h; }} namespace cradle { 

#line 101 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_array_calc>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_array_calc>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_array_calc>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_array_calc")); } void structure_field_type_info_adder<thinknode_array_calc>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["items"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_array_calc>().items)>(),             none);    (*fields)["item_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_array_calc>().item_schema)>(),             none); } bool operator==(thinknode_array_calc const& a, thinknode_array_calc const& b) { return a.items == b.items && a.item_schema == b.item_schema; } bool operator!=(thinknode_array_calc const& a, thinknode_array_calc const& b) { return !(a == b); } bool operator<(thinknode_array_calc const& a, thinknode_array_calc const& b) { if (a.items < b.items) return true; if (b.items < a.items) return false; if (a.item_schema < b.item_schema) return true; if (b.item_schema < a.item_schema) return false;     return false; } void swap(thinknode_array_calc& a, thinknode_array_calc& b) {     using std::swap;     swap(a.items, b.items);     swap(a.item_schema, b.item_schema); } size_t deep_sizeof(thinknode_array_calc const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.items) + deep_sizeof(x.item_schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_array_calc const& x) { using cradle::write_field_to_record; write_field_to_record(record, "items", x.items); write_field_to_record(record, "item_schema", x.item_schema); } void to_dynamic(cradle::dynamic* v, thinknode_array_calc const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_array_calc& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.items, record, "items"); read_field_from_record(&x.item_schema, record, "item_schema"); } void from_dynamic(thinknode_array_calc* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_array_calc const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_array_calc const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.items)); boost::hash_combine(h, cradle::invoke_hash(x.item_schema));  return h; }} namespace cradle { 

#line 108 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_object_calc>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_object_calc>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_object_calc>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_object_calc")); } void structure_field_type_info_adder<thinknode_object_calc>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["properties"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_object_calc>().properties)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_object_calc>().schema)>(),             none); } bool operator==(thinknode_object_calc const& a, thinknode_object_calc const& b) { return a.properties == b.properties && a.schema == b.schema; } bool operator!=(thinknode_object_calc const& a, thinknode_object_calc const& b) { return !(a == b); } bool operator<(thinknode_object_calc const& a, thinknode_object_calc const& b) { if (a.properties < b.properties) return true; if (b.properties < a.properties) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_object_calc& a, thinknode_object_calc& b) {     using std::swap;     swap(a.properties, b.properties);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_object_calc const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.properties) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_object_calc const& x) { using cradle::write_field_to_record; write_field_to_record(record, "properties", x.properties); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_object_calc const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_object_calc& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.properties, record, "properties"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_object_calc* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_object_calc const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_object_calc const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.properties)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 115 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_item_calc>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_item_calc>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_item_calc>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_item_calc")); } void structure_field_type_info_adder<thinknode_item_calc>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["array"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_item_calc>().array)>(),             none);    (*fields)["index"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_item_calc>().index)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_item_calc>().schema)>(),             none); } bool operator==(thinknode_item_calc const& a, thinknode_item_calc const& b) { return a.array == b.array && a.index == b.index && a.schema == b.schema; } bool operator!=(thinknode_item_calc const& a, thinknode_item_calc const& b) { return !(a == b); } bool operator<(thinknode_item_calc const& a, thinknode_item_calc const& b) { if (a.array < b.array) return true; if (b.array < a.array) return false; if (a.index < b.index) return true; if (b.index < a.index) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_item_calc& a, thinknode_item_calc& b) {     using std::swap;     swap(a.array, b.array);     swap(a.index, b.index);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_item_calc const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.array) + deep_sizeof(x.index) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_item_calc const& x) { using cradle::write_field_to_record; write_field_to_record(record, "array", x.array); write_field_to_record(record, "index", x.index); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_item_calc const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_item_calc& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.array, record, "array"); read_field_from_record(&x.index, record, "index"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_item_calc* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_item_calc const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_item_calc const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.array)); boost::hash_combine(h, cradle::invoke_hash(x.index)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 123 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_property_calc>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_property_calc>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_property_calc>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_property_calc")); } void structure_field_type_info_adder<thinknode_property_calc>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["object"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_property_calc>().object)>(),             none);    (*fields)["field"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_property_calc>().field)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_property_calc>().schema)>(),             none); } bool operator==(thinknode_property_calc const& a, thinknode_property_calc const& b) { return a.object == b.object && a.field == b.field && a.schema == b.schema; } bool operator!=(thinknode_property_calc const& a, thinknode_property_calc const& b) { return !(a == b); } bool operator<(thinknode_property_calc const& a, thinknode_property_calc const& b) { if (a.object < b.object) return true; if (b.object < a.object) return false; if (a.field < b.field) return true; if (b.field < a.field) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_property_calc& a, thinknode_property_calc& b) {     using std::swap;     swap(a.object, b.object);     swap(a.field, b.field);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_property_calc const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.object) + deep_sizeof(x.field) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_property_calc const& x) { using cradle::write_field_to_record; write_field_to_record(record, "object", x.object); write_field_to_record(record, "field", x.field); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_property_calc const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_property_calc& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.object, record, "object"); read_field_from_record(&x.field, record, "field"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_property_calc* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_property_calc const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_property_calc const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.object)); boost::hash_combine(h, cradle::invoke_hash(x.field)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 131 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_meta_calc>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_meta_calc>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_meta_calc>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_meta_calc")); } void structure_field_type_info_adder<thinknode_meta_calc>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["generator"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_meta_calc>().generator)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_meta_calc>().schema)>(),             none); } bool operator==(thinknode_meta_calc const& a, thinknode_meta_calc const& b) { return a.generator == b.generator && a.schema == b.schema; } bool operator!=(thinknode_meta_calc const& a, thinknode_meta_calc const& b) { return !(a == b); } bool operator<(thinknode_meta_calc const& a, thinknode_meta_calc const& b) { if (a.generator < b.generator) return true; if (b.generator < a.generator) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_meta_calc& a, thinknode_meta_calc& b) {     using std::swap;     swap(a.generator, b.generator);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_meta_calc const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.generator) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_meta_calc const& x) { using cradle::write_field_to_record; write_field_to_record(record, "generator", x.generator); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_meta_calc const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_meta_calc& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.generator, record, "generator"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_meta_calc* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_meta_calc const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_meta_calc const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.generator)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 138 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_cast_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_cast_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_cast_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_cast_request")); } void structure_field_type_info_adder<thinknode_cast_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_cast_request>().schema)>(),             none);    (*fields)["object"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_cast_request>().object)>(),             none); } bool operator==(thinknode_cast_request const& a, thinknode_cast_request const& b) { return a.schema == b.schema && a.object == b.object; } bool operator!=(thinknode_cast_request const& a, thinknode_cast_request const& b) { return !(a == b); } bool operator<(thinknode_cast_request const& a, thinknode_cast_request const& b) { if (a.schema < b.schema) return true; if (b.schema < a.schema) return false; if (a.object < b.object) return true; if (b.object < a.object) return false;     return false; } void swap(thinknode_cast_request& a, thinknode_cast_request& b) {     using std::swap;     swap(a.schema, b.schema);     swap(a.object, b.object); } size_t deep_sizeof(thinknode_cast_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.schema) + deep_sizeof(x.object) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_cast_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "schema", x.schema); write_field_to_record(record, "object", x.object); } void to_dynamic(cradle::dynamic* v, thinknode_cast_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_cast_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.schema, record, "schema"); read_field_from_record(&x.object, record, "object"); } void from_dynamic(thinknode_cast_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_cast_request const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_cast_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.schema)); boost::hash_combine(h, cradle::invoke_hash(x.object));  return h; }} namespace cradle { 

#line 145 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_let_calc>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_let_calc>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_let_calc>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_let_calc")); } void structure_field_type_info_adder<thinknode_let_calc>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["variables"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_let_calc>().variables)>(),             none);    (*fields)["in"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_let_calc>().in)>(),             none); } bool operator==(thinknode_let_calc const& a, thinknode_let_calc const& b) { return a.variables == b.variables && a.in == b.in; } bool operator!=(thinknode_let_calc const& a, thinknode_let_calc const& b) { return !(a == b); } bool operator<(thinknode_let_calc const& a, thinknode_let_calc const& b) { if (a.variables < b.variables) return true; if (b.variables < a.variables) return false; if (a.in < b.in) return true; if (b.in < a.in) return false;     return false; } void swap(thinknode_let_calc& a, thinknode_let_calc& b) {     using std::swap;     swap(a.variables, b.variables);     swap(a.in, b.in); } size_t deep_sizeof(thinknode_let_calc const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.variables) + deep_sizeof(x.in) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_let_calc const& x) { using cradle::write_field_to_record; write_field_to_record(record, "variables", x.variables); write_field_to_record(record, "in", x.in); } void to_dynamic(cradle::dynamic* v, thinknode_let_calc const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_let_calc& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.variables, record, "variables"); read_field_from_record(&x.in, record, "in"); } void from_dynamic(thinknode_let_calc* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_let_calc const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_let_calc const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.variables)); boost::hash_combine(h, cradle::invoke_hash(x.in));  return h; }} namespace cradle { 

#line 152 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<id_response>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<id_response>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<id_response>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "id_response")); } void structure_field_type_info_adder<id_response>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["id"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<id_response>().id)>(),             none); } bool operator==(id_response const& a, id_response const& b) { return a.id == b.id; } bool operator!=(id_response const& a, id_response const& b) { return !(a == b); } bool operator<(id_response const& a, id_response const& b) { if (a.id < b.id) return true; if (b.id < a.id) return false;     return false; } void swap(id_response& a, id_response& b) {     using std::swap;     swap(a.id, b.id); } size_t deep_sizeof(id_response const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.id) ; } void write_fields_to_record(cradle::dynamic_map& record, id_response const& x) { using cradle::write_field_to_record; write_field_to_record(record, "id", x.id); } void to_dynamic(cradle::dynamic* v, id_response const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(id_response& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.id, record, "id"); } void from_dynamic(id_response* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, id_response const& x) { return s << to_dynamic(x); } size_t hash_value(id_response const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.id));  return h; }} namespace cradle { 

#line 159 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<reported_calculation_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<reported_calculation_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<reported_calculation_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "reported_calculation_info")); } void structure_field_type_info_adder<reported_calculation_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["id"] =         cradle::api_structure_field_info(             "the Thinknode ID of the calculation",             cradle::get_type_info<decltype(std::declval<reported_calculation_info>().id)>(),             none);    (*fields)["label"] =         cradle::api_structure_field_info(             "a label for the calculation - Currently, this is just the function name.",             cradle::get_type_info<decltype(std::declval<reported_calculation_info>().label)>(),             none); } bool operator==(reported_calculation_info const& a, reported_calculation_info const& b) { return a.id == b.id && a.label == b.label; } bool operator!=(reported_calculation_info const& a, reported_calculation_info const& b) { return !(a == b); } bool operator<(reported_calculation_info const& a, reported_calculation_info const& b) { if (a.id < b.id) return true; if (b.id < a.id) return false; if (a.label < b.label) return true; if (b.label < a.label) return false;     return false; } void swap(reported_calculation_info& a, reported_calculation_info& b) {     using std::swap;     swap(a.id, b.id);     swap(a.label, b.label); } size_t deep_sizeof(reported_calculation_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.id) + deep_sizeof(x.label) ; } void write_fields_to_record(cradle::dynamic_map& record, reported_calculation_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "id", x.id); write_field_to_record(record, "label", x.label); } void to_dynamic(cradle::dynamic* v, reported_calculation_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(reported_calculation_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.id, record, "id"); read_field_from_record(&x.label, record, "label"); } void from_dynamic(reported_calculation_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, reported_calculation_info const& x) { return s << to_dynamic(x); } size_t hash_value(reported_calculation_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.id)); boost::hash_combine(h, cradle::invoke_hash(x.label));  return h; }} namespace cradle { 

#line 168 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<let_calculation_submission_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<let_calculation_submission_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<let_calculation_submission_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "let_calculation_submission_info")); } void structure_field_type_info_adder<let_calculation_submission_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["main_calc_id"] =         cradle::api_structure_field_info(             "the ID of the top-level calculation",             cradle::get_type_info<decltype(std::declval<let_calculation_submission_info>().main_calc_id)>(),             none);    (*fields)["reported_subcalcs"] =         cradle::api_structure_field_info(             "info on any subcalculations whose progress we're interested in",             cradle::get_type_info<decltype(std::declval<let_calculation_submission_info>().reported_subcalcs)>(),             none);    (*fields)["other_subcalc_ids"] =         cradle::api_structure_field_info(             "IDs of any other subcalculations",             cradle::get_type_info<decltype(std::declval<let_calculation_submission_info>().other_subcalc_ids)>(),             none); } bool operator==(let_calculation_submission_info const& a, let_calculation_submission_info const& b) { return a.main_calc_id == b.main_calc_id && a.reported_subcalcs == b.reported_subcalcs && a.other_subcalc_ids == b.other_subcalc_ids; } bool operator!=(let_calculation_submission_info const& a, let_calculation_submission_info const& b) { return !(a == b); } bool operator<(let_calculation_submission_info const& a, let_calculation_submission_info const& b) { if (a.main_calc_id < b.main_calc_id) return true; if (b.main_calc_id < a.main_calc_id) return false; if (a.reported_subcalcs < b.reported_subcalcs) return true; if (b.reported_subcalcs < a.reported_subcalcs) return false; if (a.other_subcalc_ids < b.other_subcalc_ids) return true; if (b.other_subcalc_ids < a.other_subcalc_ids) return false;     return false; } void swap(let_calculation_submission_info& a, let_calculation_submission_info& b) {     using std::swap;     swap(a.main_calc_id, b.main_calc_id);     swap(a.reported_subcalcs, b.reported_subcalcs);     swap(a.other_subcalc_ids, b.other_subcalc_ids); } size_t deep_sizeof(let_calculation_submission_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.main_calc_id) + deep_sizeof(x.reported_subcalcs) + deep_sizeof(x.other_subcalc_ids) ; } void write_fields_to_record(cradle::dynamic_map& record, let_calculation_submission_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "main_calc_id", x.main_calc_id); write_field_to_record(record, "reported_subcalcs", x.reported_subcalcs); write_field_to_record(record, "other_subcalc_ids", x.other_subcalc_ids); } void to_dynamic(cradle::dynamic* v, let_calculation_submission_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(let_calculation_submission_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.main_calc_id, record, "main_calc_id"); read_field_from_record(&x.reported_subcalcs, record, "reported_subcalcs"); read_field_from_record(&x.other_subcalc_ids, record, "other_subcalc_ids"); } void from_dynamic(let_calculation_submission_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, let_calculation_submission_info const& x) { return s << to_dynamic(x); } size_t hash_value(let_calculation_submission_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.main_calc_id)); boost::hash_combine(h, cradle::invoke_hash(x.reported_subcalcs)); boost::hash_combine(h, cradle::invoke_hash(x.other_subcalc_ids));  return h; }} namespace cradle { 

#line 179 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<augmented_calculation_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<augmented_calculation_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<augmented_calculation_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "augmented_calculation_request")); } void structure_field_type_info_adder<augmented_calculation_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["request"] =         cradle::api_structure_field_info(             "the underlying request",             cradle::get_type_info<decltype(std::declval<augmented_calculation_request>().request)>(),             none);    (*fields)["reported_variables"] =         cradle::api_structure_field_info(             "any variables that should be reported on",             cradle::get_type_info<decltype(std::declval<augmented_calculation_request>().reported_variables)>(),             none); } bool operator==(augmented_calculation_request const& a, augmented_calculation_request const& b) { return a.request == b.request && a.reported_variables == b.reported_variables; } bool operator!=(augmented_calculation_request const& a, augmented_calculation_request const& b) { return !(a == b); } bool operator<(augmented_calculation_request const& a, augmented_calculation_request const& b) { if (a.request < b.request) return true; if (b.request < a.request) return false; if (a.reported_variables < b.reported_variables) return true; if (b.reported_variables < a.reported_variables) return false;     return false; } void swap(augmented_calculation_request& a, augmented_calculation_request& b) {     using std::swap;     swap(a.request, b.request);     swap(a.reported_variables, b.reported_variables); } size_t deep_sizeof(augmented_calculation_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.request) + deep_sizeof(x.reported_variables) ; } void write_fields_to_record(cradle::dynamic_map& record, augmented_calculation_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "request", x.request); write_field_to_record(record, "reported_variables", x.reported_variables); } void to_dynamic(cradle::dynamic* v, augmented_calculation_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(augmented_calculation_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.request, record, "request"); read_field_from_record(&x.reported_variables, record, "reported_variables"); } void from_dynamic(augmented_calculation_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, augmented_calculation_request const& x) { return s << to_dynamic(x); } size_t hash_value(augmented_calculation_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.request)); boost::hash_combine(h, cradle::invoke_hash(x.reported_variables));  return h; }} namespace cradle { 

#line 190 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<calculation_queue_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<calculation_queue_type>()); } void type_info_query<calculation_queue_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_queue_type")); } void enum_type_info_query<calculation_queue_type>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["pending"] =  cradle::api_enum_value_info( "");values["ready"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(calculation_queue_type value) {     switch (value)     { case calculation_queue_type::PENDING: return "pending";case calculation_queue_type::READY: return "ready";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("calculation_queue_type") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     calculation_queue_type x) {     *v = get_value_id(x); } void from_dynamic(     calculation_queue_type* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "pending")     {         *x = calculation_queue_type::PENDING;         return;     };    if (boost::to_lower_copy(s) == "ready")     {         *x = calculation_queue_type::READY;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("calculation_queue_type") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, calculation_queue_type const& x) {     s << get_value_id(x);     return s; } 

#line 197 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<calculation_calculating_status>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<calculation_calculating_status>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<calculation_calculating_status>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_calculating_status")); } void structure_field_type_info_adder<calculation_calculating_status>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["progress"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<calculation_calculating_status>().progress)>(),             none); } bool operator==(calculation_calculating_status const& a, calculation_calculating_status const& b) { return a.progress == b.progress; } bool operator!=(calculation_calculating_status const& a, calculation_calculating_status const& b) { return !(a == b); } bool operator<(calculation_calculating_status const& a, calculation_calculating_status const& b) { if (a.progress < b.progress) return true; if (b.progress < a.progress) return false;     return false; } void swap(calculation_calculating_status& a, calculation_calculating_status& b) {     using std::swap;     swap(a.progress, b.progress); } size_t deep_sizeof(calculation_calculating_status const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.progress) ; } void write_fields_to_record(cradle::dynamic_map& record, calculation_calculating_status const& x) { using cradle::write_field_to_record; write_field_to_record(record, "progress", x.progress); } void to_dynamic(cradle::dynamic* v, calculation_calculating_status const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(calculation_calculating_status& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.progress, record, "progress"); } void from_dynamic(calculation_calculating_status* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, calculation_calculating_status const& x) { return s << to_dynamic(x); } size_t hash_value(calculation_calculating_status const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.progress));  return h; }} namespace cradle { 

#line 203 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<calculation_uploading_status>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<calculation_uploading_status>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<calculation_uploading_status>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_uploading_status")); } void structure_field_type_info_adder<calculation_uploading_status>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["progress"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<calculation_uploading_status>().progress)>(),             none); } bool operator==(calculation_uploading_status const& a, calculation_uploading_status const& b) { return a.progress == b.progress; } bool operator!=(calculation_uploading_status const& a, calculation_uploading_status const& b) { return !(a == b); } bool operator<(calculation_uploading_status const& a, calculation_uploading_status const& b) { if (a.progress < b.progress) return true; if (b.progress < a.progress) return false;     return false; } void swap(calculation_uploading_status& a, calculation_uploading_status& b) {     using std::swap;     swap(a.progress, b.progress); } size_t deep_sizeof(calculation_uploading_status const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.progress) ; } void write_fields_to_record(cradle::dynamic_map& record, calculation_uploading_status const& x) { using cradle::write_field_to_record; write_field_to_record(record, "progress", x.progress); } void to_dynamic(cradle::dynamic* v, calculation_uploading_status const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(calculation_uploading_status& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.progress, record, "progress"); } void from_dynamic(calculation_uploading_status* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, calculation_uploading_status const& x) { return s << to_dynamic(x); } size_t hash_value(calculation_uploading_status const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.progress));  return h; }} namespace cradle { 

#line 209 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<calculation_failure_status>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<calculation_failure_status>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<calculation_failure_status>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_failure_status")); } void structure_field_type_info_adder<calculation_failure_status>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["code"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<calculation_failure_status>().code)>(),             none);    (*fields)["error"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<calculation_failure_status>().error)>(),             none);    (*fields)["message"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<calculation_failure_status>().message)>(),             none); } bool operator==(calculation_failure_status const& a, calculation_failure_status const& b) { return a.code == b.code && a.error == b.error && a.message == b.message; } bool operator!=(calculation_failure_status const& a, calculation_failure_status const& b) { return !(a == b); } bool operator<(calculation_failure_status const& a, calculation_failure_status const& b) { if (a.code < b.code) return true; if (b.code < a.code) return false; if (a.error < b.error) return true; if (b.error < a.error) return false; if (a.message < b.message) return true; if (b.message < a.message) return false;     return false; } void swap(calculation_failure_status& a, calculation_failure_status& b) {     using std::swap;     swap(a.code, b.code);     swap(a.error, b.error);     swap(a.message, b.message); } size_t deep_sizeof(calculation_failure_status const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.code) + deep_sizeof(x.error) + deep_sizeof(x.message) ; } void write_fields_to_record(cradle::dynamic_map& record, calculation_failure_status const& x) { using cradle::write_field_to_record; write_field_to_record(record, "code", x.code); write_field_to_record(record, "error", x.error); write_field_to_record(record, "message", x.message); } void to_dynamic(cradle::dynamic* v, calculation_failure_status const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(calculation_failure_status& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.code, record, "code"); read_field_from_record(&x.error, record, "error"); read_field_from_record(&x.message, record, "message"); } void from_dynamic(calculation_failure_status* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, calculation_failure_status const& x) { return s << to_dynamic(x); } size_t hash_value(calculation_failure_status const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.code)); boost::hash_combine(h, cradle::invoke_hash(x.error)); boost::hash_combine(h, cradle::invoke_hash(x.message));  return h; }} namespace cradle { 

#line 217 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<calculation_status_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<calculation_status_tag>()); } void type_info_query<calculation_status_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_status_tag")); } void enum_type_info_query<calculation_status_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["calculating"] =  cradle::api_enum_value_info( "");values["canceled"] =  cradle::api_enum_value_info( "");values["completed"] =  cradle::api_enum_value_info( "");values["failed"] =  cradle::api_enum_value_info( "");values["generating"] =  cradle::api_enum_value_info( "");values["queued"] =  cradle::api_enum_value_info( "");values["uploading"] =  cradle::api_enum_value_info( "");values["waiting"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(calculation_status_tag value) {     switch (value)     { case calculation_status_tag::CALCULATING: return "calculating";case calculation_status_tag::CANCELED: return "canceled";case calculation_status_tag::COMPLETED: return "completed";case calculation_status_tag::FAILED: return "failed";case calculation_status_tag::GENERATING: return "generating";case calculation_status_tag::QUEUED: return "queued";case calculation_status_tag::UPLOADING: return "uploading";case calculation_status_tag::WAITING: return "waiting";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("calculation_status_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     calculation_status_tag x) {     *v = get_value_id(x); } void from_dynamic(     calculation_status_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "calculating")     {         *x = calculation_status_tag::CALCULATING;         return;     };    if (boost::to_lower_copy(s) == "canceled")     {         *x = calculation_status_tag::CANCELED;         return;     };    if (boost::to_lower_copy(s) == "completed")     {         *x = calculation_status_tag::COMPLETED;         return;     };    if (boost::to_lower_copy(s) == "failed")     {         *x = calculation_status_tag::FAILED;         return;     };    if (boost::to_lower_copy(s) == "generating")     {         *x = calculation_status_tag::GENERATING;         return;     };    if (boost::to_lower_copy(s) == "queued")     {         *x = calculation_status_tag::QUEUED;         return;     };    if (boost::to_lower_copy(s) == "uploading")     {         *x = calculation_status_tag::UPLOADING;         return;     };    if (boost::to_lower_copy(s) == "waiting")     {         *x = calculation_status_tag::WAITING;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("calculation_status_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, calculation_status_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<calculation_status>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["calculating"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<calculation_calculating_status>());    members["canceled"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<nil_t>());    members["completed"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<nil_t>());    members["failed"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<calculation_failure_status>());    members["generating"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<nil_t>());    members["queued"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<calculation_queue_type>());    members["uploading"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<calculation_uploading_status>());    members["waiting"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<nil_t>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<calculation_status>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "calculation_status")); } calculation_status make_calculation_status_with_calculating(calculation_calculating_status const& x) { calculation_status s; s.type = calculation_status_tag::CALCULATING; s.contents_ = x; return s; } calculation_status make_calculation_status_with_calculating(calculation_calculating_status&& x) { calculation_status s; s.type = calculation_status_tag::CALCULATING; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_canceled(nil_t const& x) { calculation_status s; s.type = calculation_status_tag::CANCELED; s.contents_ = x; return s; } calculation_status make_calculation_status_with_canceled(nil_t&& x) { calculation_status s; s.type = calculation_status_tag::CANCELED; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_completed(nil_t const& x) { calculation_status s; s.type = calculation_status_tag::COMPLETED; s.contents_ = x; return s; } calculation_status make_calculation_status_with_completed(nil_t&& x) { calculation_status s; s.type = calculation_status_tag::COMPLETED; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_failed(calculation_failure_status const& x) { calculation_status s; s.type = calculation_status_tag::FAILED; s.contents_ = x; return s; } calculation_status make_calculation_status_with_failed(calculation_failure_status&& x) { calculation_status s; s.type = calculation_status_tag::FAILED; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_generating(nil_t const& x) { calculation_status s; s.type = calculation_status_tag::GENERATING; s.contents_ = x; return s; } calculation_status make_calculation_status_with_generating(nil_t&& x) { calculation_status s; s.type = calculation_status_tag::GENERATING; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_queued(calculation_queue_type const& x) { calculation_status s; s.type = calculation_status_tag::QUEUED; s.contents_ = x; return s; } calculation_status make_calculation_status_with_queued(calculation_queue_type&& x) { calculation_status s; s.type = calculation_status_tag::QUEUED; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_uploading(calculation_uploading_status const& x) { calculation_status s; s.type = calculation_status_tag::UPLOADING; s.contents_ = x; return s; } calculation_status make_calculation_status_with_uploading(calculation_uploading_status&& x) { calculation_status s; s.type = calculation_status_tag::UPLOADING; s.contents_ = std::move(x); return s; } calculation_status make_calculation_status_with_waiting(nil_t const& x) { calculation_status s; s.type = calculation_status_tag::WAITING; s.contents_ = x; return s; } calculation_status make_calculation_status_with_waiting(nil_t&& x) { calculation_status s; s.type = calculation_status_tag::WAITING; s.contents_ = std::move(x); return s; } calculation_calculating_status const& as_calculating(calculation_status const& x) { assert(x.type == calculation_status_tag::CALCULATING); return std::any_cast<calculation_calculating_status const& >(x.contents_); } nil_t const& as_canceled(calculation_status const& x) { assert(x.type == calculation_status_tag::CANCELED); return std::any_cast<nil_t const& >(x.contents_); } nil_t const& as_completed(calculation_status const& x) { assert(x.type == calculation_status_tag::COMPLETED); return std::any_cast<nil_t const& >(x.contents_); } calculation_failure_status const& as_failed(calculation_status const& x) { assert(x.type == calculation_status_tag::FAILED); return std::any_cast<calculation_failure_status const& >(x.contents_); } nil_t const& as_generating(calculation_status const& x) { assert(x.type == calculation_status_tag::GENERATING); return std::any_cast<nil_t const& >(x.contents_); } calculation_queue_type const& as_queued(calculation_status const& x) { assert(x.type == calculation_status_tag::QUEUED); return std::any_cast<calculation_queue_type const& >(x.contents_); } calculation_uploading_status const& as_uploading(calculation_status const& x) { assert(x.type == calculation_status_tag::UPLOADING); return std::any_cast<calculation_uploading_status const& >(x.contents_); } nil_t const& as_waiting(calculation_status const& x) { assert(x.type == calculation_status_tag::WAITING); return std::any_cast<nil_t const& >(x.contents_); } calculation_calculating_status& as_calculating(calculation_status& x) { assert(x.type == calculation_status_tag::CALCULATING); return std::any_cast<calculation_calculating_status&>(x.contents_); } nil_t& as_canceled(calculation_status& x) { assert(x.type == calculation_status_tag::CANCELED); return std::any_cast<nil_t&>(x.contents_); } nil_t& as_completed(calculation_status& x) { assert(x.type == calculation_status_tag::COMPLETED); return std::any_cast<nil_t&>(x.contents_); } calculation_failure_status& as_failed(calculation_status& x) { assert(x.type == calculation_status_tag::FAILED); return std::any_cast<calculation_failure_status&>(x.contents_); } nil_t& as_generating(calculation_status& x) { assert(x.type == calculation_status_tag::GENERATING); return std::any_cast<nil_t&>(x.contents_); } calculation_queue_type& as_queued(calculation_status& x) { assert(x.type == calculation_status_tag::QUEUED); return std::any_cast<calculation_queue_type&>(x.contents_); } calculation_uploading_status& as_uploading(calculation_status& x) { assert(x.type == calculation_status_tag::UPLOADING); return std::any_cast<calculation_uploading_status&>(x.contents_); } nil_t& as_waiting(calculation_status& x) { assert(x.type == calculation_status_tag::WAITING); return std::any_cast<nil_t&>(x.contents_); } void set_to_calculating(calculation_status& x, calculation_calculating_status const& y) { x.type = calculation_status_tag::CALCULATING; x.contents_ = y; } void set_to_calculating(calculation_status& x, calculation_calculating_status&& y) { x.type = calculation_status_tag::CALCULATING; x.contents_ = std::move(y); } void set_to_canceled(calculation_status& x, nil_t const& y) { x.type = calculation_status_tag::CANCELED; x.contents_ = y; } void set_to_canceled(calculation_status& x, nil_t&& y) { x.type = calculation_status_tag::CANCELED; x.contents_ = std::move(y); } void set_to_completed(calculation_status& x, nil_t const& y) { x.type = calculation_status_tag::COMPLETED; x.contents_ = y; } void set_to_completed(calculation_status& x, nil_t&& y) { x.type = calculation_status_tag::COMPLETED; x.contents_ = std::move(y); } void set_to_failed(calculation_status& x, calculation_failure_status const& y) { x.type = calculation_status_tag::FAILED; x.contents_ = y; } void set_to_failed(calculation_status& x, calculation_failure_status&& y) { x.type = calculation_status_tag::FAILED; x.contents_ = std::move(y); } void set_to_generating(calculation_status& x, nil_t const& y) { x.type = calculation_status_tag::GENERATING; x.contents_ = y; } void set_to_generating(calculation_status& x, nil_t&& y) { x.type = calculation_status_tag::GENERATING; x.contents_ = std::move(y); } void set_to_queued(calculation_status& x, calculation_queue_type const& y) { x.type = calculation_status_tag::QUEUED; x.contents_ = y; } void set_to_queued(calculation_status& x, calculation_queue_type&& y) { x.type = calculation_status_tag::QUEUED; x.contents_ = std::move(y); } void set_to_uploading(calculation_status& x, calculation_uploading_status const& y) { x.type = calculation_status_tag::UPLOADING; x.contents_ = y; } void set_to_uploading(calculation_status& x, calculation_uploading_status&& y) { x.type = calculation_status_tag::UPLOADING; x.contents_ = std::move(y); } void set_to_waiting(calculation_status& x, nil_t const& y) { x.type = calculation_status_tag::WAITING; x.contents_ = y; } void set_to_waiting(calculation_status& x, nil_t&& y) { x.type = calculation_status_tag::WAITING; x.contents_ = std::move(y); } bool operator==(calculation_status const& a, calculation_status const& b) { if (a.type != b.type) return false; switch (a.type) { case calculation_status_tag::CALCULATING: return as_calculating(a) == as_calculating(b); case calculation_status_tag::CANCELED: return as_canceled(a) == as_canceled(b); case calculation_status_tag::COMPLETED: return as_completed(a) == as_completed(b); case calculation_status_tag::FAILED: return as_failed(a) == as_failed(b); case calculation_status_tag::GENERATING: return as_generating(a) == as_generating(b); case calculation_status_tag::QUEUED: return as_queued(a) == as_queued(b); case calculation_status_tag::UPLOADING: return as_uploading(a) == as_uploading(b); case calculation_status_tag::WAITING: return as_waiting(a) == as_waiting(b); } return true; } bool operator!=(calculation_status const& a, calculation_status const& b) { return !(a == b); } bool operator<(calculation_status const& a, calculation_status const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case calculation_status_tag::CALCULATING: return as_calculating(a) < as_calculating(b); case calculation_status_tag::CANCELED: return as_canceled(a) < as_canceled(b); case calculation_status_tag::COMPLETED: return as_completed(a) < as_completed(b); case calculation_status_tag::FAILED: return as_failed(a) < as_failed(b); case calculation_status_tag::GENERATING: return as_generating(a) < as_generating(b); case calculation_status_tag::QUEUED: return as_queued(a) < as_queued(b); case calculation_status_tag::UPLOADING: return as_uploading(a) < as_uploading(b); case calculation_status_tag::WAITING: return as_waiting(a) < as_waiting(b); } return false; } size_t hash_value(calculation_status const& x) {     switch (x.type)     { case calculation_status_tag::CALCULATING: return cradle::invoke_hash(as_calculating(x)); case calculation_status_tag::CANCELED: return cradle::invoke_hash(as_canceled(x)); case calculation_status_tag::COMPLETED: return cradle::invoke_hash(as_completed(x)); case calculation_status_tag::FAILED: return cradle::invoke_hash(as_failed(x)); case calculation_status_tag::GENERATING: return cradle::invoke_hash(as_generating(x)); case calculation_status_tag::QUEUED: return cradle::invoke_hash(as_queued(x)); case calculation_status_tag::UPLOADING: return cradle::invoke_hash(as_uploading(x)); case calculation_status_tag::WAITING: return cradle::invoke_hash(as_waiting(x));      } assert(0); return 0; }void swap(calculation_status& a, calculation_status& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, calculation_status const& x) { cradle::dynamic_map s; switch (x.type) { case calculation_status_tag::CALCULATING: to_dynamic(&s[dynamic("calculating")], as_calculating(x)); break; case calculation_status_tag::CANCELED: to_dynamic(&s[dynamic("canceled")], as_canceled(x)); break; case calculation_status_tag::COMPLETED: to_dynamic(&s[dynamic("completed")], as_completed(x)); break; case calculation_status_tag::FAILED: to_dynamic(&s[dynamic("failed")], as_failed(x)); break; case calculation_status_tag::GENERATING: to_dynamic(&s[dynamic("generating")], as_generating(x)); break; case calculation_status_tag::QUEUED: to_dynamic(&s[dynamic("queued")], as_queued(x)); break; case calculation_status_tag::UPLOADING: to_dynamic(&s[dynamic("uploading")], as_uploading(x)); break; case calculation_status_tag::WAITING: to_dynamic(&s[dynamic("waiting")], as_waiting(x)); break; } *v = std::move(s); } void from_dynamic(calculation_status* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case calculation_status_tag::CALCULATING:  { calculation_calculating_status tmp; from_dynamic(&tmp, get_field(s, "calculating")); x->contents_ = tmp; break;  } case calculation_status_tag::CANCELED:  { nil_t tmp; from_dynamic(&tmp, get_field(s, "canceled")); x->contents_ = tmp; break;  } case calculation_status_tag::COMPLETED:  { nil_t tmp; from_dynamic(&tmp, get_field(s, "completed")); x->contents_ = tmp; break;  } case calculation_status_tag::FAILED:  { calculation_failure_status tmp; from_dynamic(&tmp, get_field(s, "failed")); x->contents_ = tmp; break;  } case calculation_status_tag::GENERATING:  { nil_t tmp; from_dynamic(&tmp, get_field(s, "generating")); x->contents_ = tmp; break;  } case calculation_status_tag::QUEUED:  { calculation_queue_type tmp; from_dynamic(&tmp, get_field(s, "queued")); x->contents_ = tmp; break;  } case calculation_status_tag::UPLOADING:  { calculation_uploading_status tmp; from_dynamic(&tmp, get_field(s, "uploading")); x->contents_ = tmp; break;  } case calculation_status_tag::WAITING:  { nil_t tmp; from_dynamic(&tmp, get_field(s, "waiting")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, calculation_status const& x) { return s << to_dynamic(x); } size_t deep_sizeof(calculation_status const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case calculation_status_tag::CALCULATING: size += deep_sizeof(as_calculating(x)); break; case calculation_status_tag::CANCELED: size += deep_sizeof(as_canceled(x)); break; case calculation_status_tag::COMPLETED: size += deep_sizeof(as_completed(x)); break; case calculation_status_tag::FAILED: size += deep_sizeof(as_failed(x)); break; case calculation_status_tag::GENERATING: size += deep_sizeof(as_generating(x)); break; case calculation_status_tag::QUEUED: size += deep_sizeof(as_queued(x)); break; case calculation_status_tag::UPLOADING: size += deep_sizeof(as_uploading(x)); break; case calculation_status_tag::WAITING: size += deep_sizeof(as_waiting(x)); break; } return size; } 

#line 230 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_nil_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_nil_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_nil_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_nil_type")); } void structure_field_type_info_adder<thinknode_nil_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_nil_type const& a, thinknode_nil_type const& b) { return true;} bool operator!=(thinknode_nil_type const& a, thinknode_nil_type const& b) { return !(a == b); } bool operator<(thinknode_nil_type const& a, thinknode_nil_type const& b) {     return false; } void swap(thinknode_nil_type& a, thinknode_nil_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_nil_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_nil_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_nil_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_nil_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_nil_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_nil_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_nil_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 235 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_boolean_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_boolean_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_boolean_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_boolean_type")); } void structure_field_type_info_adder<thinknode_boolean_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_boolean_type const& a, thinknode_boolean_type const& b) { return true;} bool operator!=(thinknode_boolean_type const& a, thinknode_boolean_type const& b) { return !(a == b); } bool operator<(thinknode_boolean_type const& a, thinknode_boolean_type const& b) {     return false; } void swap(thinknode_boolean_type& a, thinknode_boolean_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_boolean_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_boolean_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_boolean_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_boolean_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_boolean_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_boolean_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_boolean_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 240 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_integer_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_integer_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_integer_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_integer_type")); } void structure_field_type_info_adder<thinknode_integer_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_integer_type const& a, thinknode_integer_type const& b) { return true;} bool operator!=(thinknode_integer_type const& a, thinknode_integer_type const& b) { return !(a == b); } bool operator<(thinknode_integer_type const& a, thinknode_integer_type const& b) {     return false; } void swap(thinknode_integer_type& a, thinknode_integer_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_integer_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_integer_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_integer_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_integer_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_integer_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_integer_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_integer_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 245 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_float_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_float_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_float_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_float_type")); } void structure_field_type_info_adder<thinknode_float_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_float_type const& a, thinknode_float_type const& b) { return true;} bool operator!=(thinknode_float_type const& a, thinknode_float_type const& b) { return !(a == b); } bool operator<(thinknode_float_type const& a, thinknode_float_type const& b) {     return false; } void swap(thinknode_float_type& a, thinknode_float_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_float_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_float_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_float_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_float_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_float_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_float_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_float_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 250 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_string_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_string_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_string_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_string_type")); } void structure_field_type_info_adder<thinknode_string_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_string_type const& a, thinknode_string_type const& b) { return true;} bool operator!=(thinknode_string_type const& a, thinknode_string_type const& b) { return !(a == b); } bool operator<(thinknode_string_type const& a, thinknode_string_type const& b) {     return false; } void swap(thinknode_string_type& a, thinknode_string_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_string_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_string_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_string_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_string_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_string_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_string_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_string_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 255 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_datetime_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_datetime_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_datetime_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_datetime_type")); } void structure_field_type_info_adder<thinknode_datetime_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_datetime_type const& a, thinknode_datetime_type const& b) { return true;} bool operator!=(thinknode_datetime_type const& a, thinknode_datetime_type const& b) { return !(a == b); } bool operator<(thinknode_datetime_type const& a, thinknode_datetime_type const& b) {     return false; } void swap(thinknode_datetime_type& a, thinknode_datetime_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_datetime_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_datetime_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_datetime_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_datetime_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_datetime_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_datetime_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_datetime_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 260 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_blob_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_blob_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_blob_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_blob_type")); } void structure_field_type_info_adder<thinknode_blob_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_blob_type const& a, thinknode_blob_type const& b) { return true;} bool operator!=(thinknode_blob_type const& a, thinknode_blob_type const& b) { return !(a == b); } bool operator<(thinknode_blob_type const& a, thinknode_blob_type const& b) {     return false; } void swap(thinknode_blob_type& a, thinknode_blob_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_blob_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_blob_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_blob_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_blob_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_blob_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_blob_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_blob_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 265 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_dynamic_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_dynamic_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_dynamic_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_dynamic_type")); } void structure_field_type_info_adder<thinknode_dynamic_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(thinknode_dynamic_type const& a, thinknode_dynamic_type const& b) { return true;} bool operator!=(thinknode_dynamic_type const& a, thinknode_dynamic_type const& b) { return !(a == b); } bool operator<(thinknode_dynamic_type const& a, thinknode_dynamic_type const& b) {     return false; } void swap(thinknode_dynamic_type& a, thinknode_dynamic_type& b) {     using std::swap; } size_t deep_sizeof(thinknode_dynamic_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_dynamic_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, thinknode_dynamic_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_dynamic_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(thinknode_dynamic_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_dynamic_type const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_dynamic_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 270 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_structure_field_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_structure_field_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_structure_field_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_structure_field_info")); } void structure_field_type_info_adder<thinknode_structure_field_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_structure_field_info>().description)>(),             none);    (*fields)["omissible"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_structure_field_info>().omissible)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_structure_field_info>().schema)>(),             none); } bool operator==(thinknode_structure_field_info const& a, thinknode_structure_field_info const& b) { return a.description == b.description && a.omissible == b.omissible && a.schema == b.schema; } bool operator!=(thinknode_structure_field_info const& a, thinknode_structure_field_info const& b) { return !(a == b); } bool operator<(thinknode_structure_field_info const& a, thinknode_structure_field_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.omissible < b.omissible) return true; if (b.omissible < a.omissible) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_structure_field_info& a, thinknode_structure_field_info& b) {     using std::swap;     swap(a.description, b.description);     swap(a.omissible, b.omissible);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_structure_field_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) + deep_sizeof(x.omissible) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_structure_field_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); write_field_to_record(record, "omissible", x.omissible); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_structure_field_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_structure_field_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.omissible, record, "omissible"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_structure_field_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_structure_field_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_structure_field_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.omissible)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 278 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_structure_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_structure_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_structure_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_structure_info")); } void structure_field_type_info_adder<thinknode_structure_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["fields"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_structure_info>().fields)>(),             none); } bool operator==(thinknode_structure_info const& a, thinknode_structure_info const& b) { return a.fields == b.fields; } bool operator!=(thinknode_structure_info const& a, thinknode_structure_info const& b) { return !(a == b); } bool operator<(thinknode_structure_info const& a, thinknode_structure_info const& b) { if (a.fields < b.fields) return true; if (b.fields < a.fields) return false;     return false; } void swap(thinknode_structure_info& a, thinknode_structure_info& b) {     using std::swap;     swap(a.fields, b.fields); } size_t deep_sizeof(thinknode_structure_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.fields) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_structure_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "fields", x.fields); } void to_dynamic(cradle::dynamic* v, thinknode_structure_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_structure_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.fields, record, "fields"); } void from_dynamic(thinknode_structure_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_structure_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_structure_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.fields));  return h; }} namespace cradle { 

#line 284 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_union_member_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_union_member_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_union_member_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_union_member_info")); } void structure_field_type_info_adder<thinknode_union_member_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_union_member_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_union_member_info>().schema)>(),             none); } bool operator==(thinknode_union_member_info const& a, thinknode_union_member_info const& b) { return a.description == b.description && a.schema == b.schema; } bool operator!=(thinknode_union_member_info const& a, thinknode_union_member_info const& b) { return !(a == b); } bool operator<(thinknode_union_member_info const& a, thinknode_union_member_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_union_member_info& a, thinknode_union_member_info& b) {     using std::swap;     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_union_member_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_union_member_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_union_member_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_union_member_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_union_member_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_union_member_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_union_member_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 291 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_union_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_union_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_union_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_union_info")); } void structure_field_type_info_adder<thinknode_union_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["members"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_union_info>().members)>(),             none); } bool operator==(thinknode_union_info const& a, thinknode_union_info const& b) { return a.members == b.members; } bool operator!=(thinknode_union_info const& a, thinknode_union_info const& b) { return !(a == b); } bool operator<(thinknode_union_info const& a, thinknode_union_info const& b) { if (a.members < b.members) return true; if (b.members < a.members) return false;     return false; } void swap(thinknode_union_info& a, thinknode_union_info& b) {     using std::swap;     swap(a.members, b.members); } size_t deep_sizeof(thinknode_union_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.members) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_union_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "members", x.members); } void to_dynamic(cradle::dynamic* v, thinknode_union_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_union_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.members, record, "members"); } void from_dynamic(thinknode_union_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_union_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_union_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.members));  return h; }} namespace cradle { 

#line 297 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_enum_value_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_enum_value_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_enum_value_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_enum_value_info")); } void structure_field_type_info_adder<thinknode_enum_value_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_enum_value_info>().description)>(),             none); } bool operator==(thinknode_enum_value_info const& a, thinknode_enum_value_info const& b) { return a.description == b.description; } bool operator!=(thinknode_enum_value_info const& a, thinknode_enum_value_info const& b) { return !(a == b); } bool operator<(thinknode_enum_value_info const& a, thinknode_enum_value_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false;     return false; } void swap(thinknode_enum_value_info& a, thinknode_enum_value_info& b) {     using std::swap;     swap(a.description, b.description); } size_t deep_sizeof(thinknode_enum_value_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_enum_value_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); } void to_dynamic(cradle::dynamic* v, thinknode_enum_value_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_enum_value_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); } void from_dynamic(thinknode_enum_value_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_enum_value_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_enum_value_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description));  return h; }} namespace cradle { 

#line 303 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_enum_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_enum_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_enum_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_enum_info")); } void structure_field_type_info_adder<thinknode_enum_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["values"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_enum_info>().values)>(),             none); } bool operator==(thinknode_enum_info const& a, thinknode_enum_info const& b) { return a.values == b.values; } bool operator!=(thinknode_enum_info const& a, thinknode_enum_info const& b) { return !(a == b); } bool operator<(thinknode_enum_info const& a, thinknode_enum_info const& b) { if (a.values < b.values) return true; if (b.values < a.values) return false;     return false; } void swap(thinknode_enum_info& a, thinknode_enum_info& b) {     using std::swap;     swap(a.values, b.values); } size_t deep_sizeof(thinknode_enum_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.values) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_enum_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "values", x.values); } void to_dynamic(cradle::dynamic* v, thinknode_enum_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_enum_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.values, record, "values"); } void from_dynamic(thinknode_enum_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_enum_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_enum_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.values));  return h; }} namespace cradle { 

#line 309 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_array_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_array_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_array_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_array_info")); } void structure_field_type_info_adder<thinknode_array_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["element_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_array_info>().element_schema)>(),             none);    (*fields)["size"] =         cradle::api_structure_field_info(             "If size is absent, any size is acceptable.",             cradle::get_type_info<decltype(std::declval<thinknode_array_info>().size)>(),             none); } bool operator==(thinknode_array_info const& a, thinknode_array_info const& b) { return a.element_schema == b.element_schema && a.size == b.size; } bool operator!=(thinknode_array_info const& a, thinknode_array_info const& b) { return !(a == b); } bool operator<(thinknode_array_info const& a, thinknode_array_info const& b) { if (a.element_schema < b.element_schema) return true; if (b.element_schema < a.element_schema) return false; if (a.size < b.size) return true; if (b.size < a.size) return false;     return false; } void swap(thinknode_array_info& a, thinknode_array_info& b) {     using std::swap;     swap(a.element_schema, b.element_schema);     swap(a.size, b.size); } size_t deep_sizeof(thinknode_array_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.element_schema) + deep_sizeof(x.size) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_array_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "element_schema", x.element_schema); write_field_to_record(record, "size", x.size); } void to_dynamic(cradle::dynamic* v, thinknode_array_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_array_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.element_schema, record, "element_schema"); read_field_from_record(&x.size, record, "size"); } void from_dynamic(thinknode_array_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_array_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_array_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.element_schema)); boost::hash_combine(h, cradle::invoke_hash(x.size));  return h; }} namespace cradle { 

#line 317 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_map_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_map_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_map_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_map_info")); } void structure_field_type_info_adder<thinknode_map_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["key_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_map_info>().key_schema)>(),             none);    (*fields)["value_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_map_info>().value_schema)>(),             none); } bool operator==(thinknode_map_info const& a, thinknode_map_info const& b) { return a.key_schema == b.key_schema && a.value_schema == b.value_schema; } bool operator!=(thinknode_map_info const& a, thinknode_map_info const& b) { return !(a == b); } bool operator<(thinknode_map_info const& a, thinknode_map_info const& b) { if (a.key_schema < b.key_schema) return true; if (b.key_schema < a.key_schema) return false; if (a.value_schema < b.value_schema) return true; if (b.value_schema < a.value_schema) return false;     return false; } void swap(thinknode_map_info& a, thinknode_map_info& b) {     using std::swap;     swap(a.key_schema, b.key_schema);     swap(a.value_schema, b.value_schema); } size_t deep_sizeof(thinknode_map_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.key_schema) + deep_sizeof(x.value_schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_map_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "key_schema", x.key_schema); write_field_to_record(record, "value_schema", x.value_schema); } void to_dynamic(cradle::dynamic* v, thinknode_map_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_map_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.key_schema, record, "key_schema"); read_field_from_record(&x.value_schema, record, "value_schema"); } void from_dynamic(thinknode_map_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_map_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_map_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.key_schema)); boost::hash_combine(h, cradle::invoke_hash(x.value_schema));  return h; }} namespace cradle { 

#line 324 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_named_type_reference>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_named_type_reference>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_named_type_reference>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_named_type_reference")); } void structure_field_type_info_adder<thinknode_named_type_reference>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["account"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_named_type_reference>().account)>(),             none);    (*fields)["app"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_named_type_reference>().app)>(),             none);    (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_named_type_reference>().name)>(),             none); } bool operator==(thinknode_named_type_reference const& a, thinknode_named_type_reference const& b) { return a.account == b.account && a.app == b.app && a.name == b.name; } bool operator!=(thinknode_named_type_reference const& a, thinknode_named_type_reference const& b) { return !(a == b); } bool operator<(thinknode_named_type_reference const& a, thinknode_named_type_reference const& b) { if (a.account < b.account) return true; if (b.account < a.account) return false; if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.name < b.name) return true; if (b.name < a.name) return false;     return false; } void swap(thinknode_named_type_reference& a, thinknode_named_type_reference& b) {     using std::swap;     swap(a.account, b.account);     swap(a.app, b.app);     swap(a.name, b.name); } size_t deep_sizeof(thinknode_named_type_reference const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.account) + deep_sizeof(x.app) + deep_sizeof(x.name) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_named_type_reference const& x) { using cradle::write_field_to_record; write_field_to_record(record, "account", x.account); write_field_to_record(record, "app", x.app); write_field_to_record(record, "name", x.name); } void to_dynamic(cradle::dynamic* v, thinknode_named_type_reference const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_named_type_reference& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.account, record, "account"); read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.name, record, "name"); } void from_dynamic(thinknode_named_type_reference* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_named_type_reference const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_named_type_reference const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.account)); boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.name));  return h; }} namespace cradle { 

#line 332 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_function_parameter_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_function_parameter_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_function_parameter_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_parameter_info")); } void structure_field_type_info_adder<thinknode_function_parameter_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_parameter_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_parameter_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_parameter_info>().schema)>(),             none); } bool operator==(thinknode_function_parameter_info const& a, thinknode_function_parameter_info const& b) { return a.name == b.name && a.description == b.description && a.schema == b.schema; } bool operator!=(thinknode_function_parameter_info const& a, thinknode_function_parameter_info const& b) { return !(a == b); } bool operator<(thinknode_function_parameter_info const& a, thinknode_function_parameter_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_function_parameter_info& a, thinknode_function_parameter_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_function_parameter_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_parameter_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_function_parameter_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_function_parameter_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_function_parameter_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_function_parameter_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_function_parameter_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 340 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_function_result_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_function_result_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_function_result_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_result_info")); } void structure_field_type_info_adder<thinknode_function_result_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_result_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_result_info>().schema)>(),             none); } bool operator==(thinknode_function_result_info const& a, thinknode_function_result_info const& b) { return a.description == b.description && a.schema == b.schema; } bool operator!=(thinknode_function_result_info const& a, thinknode_function_result_info const& b) { return !(a == b); } bool operator<(thinknode_function_result_info const& a, thinknode_function_result_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_function_result_info& a, thinknode_function_result_info& b) {     using std::swap;     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_function_result_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_result_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_function_result_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_function_result_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_function_result_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_function_result_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_function_result_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 347 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_function_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_function_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_function_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_type_info")); } void structure_field_type_info_adder<thinknode_function_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["parameters"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_type_info>().parameters)>(),             none);    (*fields)["returns"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_type_info>().returns)>(),             none); } bool operator==(thinknode_function_type_info const& a, thinknode_function_type_info const& b) { return a.parameters == b.parameters && a.returns == b.returns; } bool operator!=(thinknode_function_type_info const& a, thinknode_function_type_info const& b) { return !(a == b); } bool operator<(thinknode_function_type_info const& a, thinknode_function_type_info const& b) { if (a.parameters < b.parameters) return true; if (b.parameters < a.parameters) return false; if (a.returns < b.returns) return true; if (b.returns < a.returns) return false;     return false; } void swap(thinknode_function_type_info& a, thinknode_function_type_info& b) {     using std::swap;     swap(a.parameters, b.parameters);     swap(a.returns, b.returns); } size_t deep_sizeof(thinknode_function_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.parameters) + deep_sizeof(x.returns) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "parameters", x.parameters); write_field_to_record(record, "returns", x.returns); } void to_dynamic(cradle::dynamic* v, thinknode_function_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_function_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.parameters, record, "parameters"); read_field_from_record(&x.returns, record, "returns"); } void from_dynamic(thinknode_function_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_function_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_function_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.parameters)); boost::hash_combine(h, cradle::invoke_hash(x.returns));  return h; }} namespace cradle { 

#line 354 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_function_type_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_function_type_tag>()); } void type_info_query<thinknode_function_type_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_type_tag")); } void enum_type_info_query<thinknode_function_type_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["function_type"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_function_type_tag value) {     switch (value)     { case thinknode_function_type_tag::FUNCTION_TYPE: return "function_type";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_function_type_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_function_type_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_function_type_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "function_type")     {         *x = thinknode_function_type_tag::FUNCTION_TYPE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_function_type_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_function_type_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_function_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["function_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_function_type_info>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_function_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_type")); } thinknode_function_type make_thinknode_function_type_with_function_type(thinknode_function_type_info const& x) { thinknode_function_type s; s.type = thinknode_function_type_tag::FUNCTION_TYPE; s.contents_ = x; return s; } thinknode_function_type make_thinknode_function_type_with_function_type(thinknode_function_type_info&& x) { thinknode_function_type s; s.type = thinknode_function_type_tag::FUNCTION_TYPE; s.contents_ = std::move(x); return s; } thinknode_function_type_info const& as_function_type(thinknode_function_type const& x) { assert(x.type == thinknode_function_type_tag::FUNCTION_TYPE); return std::any_cast<thinknode_function_type_info const& >(x.contents_); } thinknode_function_type_info& as_function_type(thinknode_function_type& x) { assert(x.type == thinknode_function_type_tag::FUNCTION_TYPE); return std::any_cast<thinknode_function_type_info&>(x.contents_); } void set_to_function_type(thinknode_function_type& x, thinknode_function_type_info const& y) { x.type = thinknode_function_type_tag::FUNCTION_TYPE; x.contents_ = y; } void set_to_function_type(thinknode_function_type& x, thinknode_function_type_info&& y) { x.type = thinknode_function_type_tag::FUNCTION_TYPE; x.contents_ = std::move(y); } bool operator==(thinknode_function_type const& a, thinknode_function_type const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_function_type_tag::FUNCTION_TYPE: return as_function_type(a) == as_function_type(b); } return true; } bool operator!=(thinknode_function_type const& a, thinknode_function_type const& b) { return !(a == b); } bool operator<(thinknode_function_type const& a, thinknode_function_type const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_function_type_tag::FUNCTION_TYPE: return as_function_type(a) < as_function_type(b); } return false; } size_t hash_value(thinknode_function_type const& x) {     switch (x.type)     { case thinknode_function_type_tag::FUNCTION_TYPE: return cradle::invoke_hash(as_function_type(x));      } assert(0); return 0; }void swap(thinknode_function_type& a, thinknode_function_type& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_function_type const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_function_type_tag::FUNCTION_TYPE: to_dynamic(&s[dynamic("function_type")], as_function_type(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_function_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_function_type_tag::FUNCTION_TYPE:  { thinknode_function_type_info tmp; from_dynamic(&tmp, get_field(s, "function_type")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_function_type const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_function_type const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_function_type_tag::FUNCTION_TYPE: size += deep_sizeof(as_function_type(x)); break; } return size; } 

#line 360 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_function_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_function_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_function_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_function_info")); } void structure_field_type_info_adder<thinknode_function_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_info>().description)>(),             none);    (*fields)["execution_class"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_info>().execution_class)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_function_info>().schema)>(),             none); } bool operator==(thinknode_function_info const& a, thinknode_function_info const& b) { return a.name == b.name && a.description == b.description && a.execution_class == b.execution_class && a.schema == b.schema; } bool operator!=(thinknode_function_info const& a, thinknode_function_info const& b) { return !(a == b); } bool operator<(thinknode_function_info const& a, thinknode_function_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.execution_class < b.execution_class) return true; if (b.execution_class < a.execution_class) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_function_info& a, thinknode_function_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.execution_class, b.execution_class);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_function_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.execution_class) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "execution_class", x.execution_class); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_function_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_function_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.execution_class, record, "execution_class"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_function_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_function_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_function_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.execution_class)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 369 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_named_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_named_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_named_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_named_type_info")); } void structure_field_type_info_adder<thinknode_named_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_named_type_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_named_type_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_named_type_info>().schema)>(),             none); } bool operator==(thinknode_named_type_info const& a, thinknode_named_type_info const& b) { return a.name == b.name && a.description == b.description && a.schema == b.schema; } bool operator!=(thinknode_named_type_info const& a, thinknode_named_type_info const& b) { return !(a == b); } bool operator<(thinknode_named_type_info const& a, thinknode_named_type_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(thinknode_named_type_info& a, thinknode_named_type_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(thinknode_named_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_named_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, thinknode_named_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_named_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(thinknode_named_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_named_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_named_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 377 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_provider_image_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_provider_image_info_tag>()); } void type_info_query<thinknode_provider_image_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_image_info_tag")); } void enum_type_info_query<thinknode_provider_image_info_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["tag"] =  cradle::api_enum_value_info( "");values["digest"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_provider_image_info_tag value) {     switch (value)     { case thinknode_provider_image_info_tag::TAG: return "tag";case thinknode_provider_image_info_tag::DIGEST: return "digest";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_provider_image_info_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_provider_image_info_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_provider_image_info_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "tag")     {         *x = thinknode_provider_image_info_tag::TAG;         return;     };    if (boost::to_lower_copy(s) == "digest")     {         *x = thinknode_provider_image_info_tag::DIGEST;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_provider_image_info_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_provider_image_info_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_provider_image_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["tag"] =         cradle::api_union_member_info(             "a reference to a docker image by tag",             cradle::get_type_info<std::string>());    members["digest"] =         cradle::api_union_member_info(             "a reference to a docker image by digest",             cradle::get_type_info<std::string>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_provider_image_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_image_info")); } thinknode_provider_image_info make_thinknode_provider_image_info_with_tag(std::string const& x) { thinknode_provider_image_info s; s.type = thinknode_provider_image_info_tag::TAG; s.contents_ = x; return s; } thinknode_provider_image_info make_thinknode_provider_image_info_with_tag(std::string&& x) { thinknode_provider_image_info s; s.type = thinknode_provider_image_info_tag::TAG; s.contents_ = std::move(x); return s; } thinknode_provider_image_info make_thinknode_provider_image_info_with_digest(std::string const& x) { thinknode_provider_image_info s; s.type = thinknode_provider_image_info_tag::DIGEST; s.contents_ = x; return s; } thinknode_provider_image_info make_thinknode_provider_image_info_with_digest(std::string&& x) { thinknode_provider_image_info s; s.type = thinknode_provider_image_info_tag::DIGEST; s.contents_ = std::move(x); return s; } std::string const& as_tag(thinknode_provider_image_info const& x) { assert(x.type == thinknode_provider_image_info_tag::TAG); return std::any_cast<std::string const& >(x.contents_); } std::string const& as_digest(thinknode_provider_image_info const& x) { assert(x.type == thinknode_provider_image_info_tag::DIGEST); return std::any_cast<std::string const& >(x.contents_); } std::string& as_tag(thinknode_provider_image_info& x) { assert(x.type == thinknode_provider_image_info_tag::TAG); return std::any_cast<std::string&>(x.contents_); } std::string& as_digest(thinknode_provider_image_info& x) { assert(x.type == thinknode_provider_image_info_tag::DIGEST); return std::any_cast<std::string&>(x.contents_); } void set_to_tag(thinknode_provider_image_info& x, std::string const& y) { x.type = thinknode_provider_image_info_tag::TAG; x.contents_ = y; } void set_to_tag(thinknode_provider_image_info& x, std::string&& y) { x.type = thinknode_provider_image_info_tag::TAG; x.contents_ = std::move(y); } void set_to_digest(thinknode_provider_image_info& x, std::string const& y) { x.type = thinknode_provider_image_info_tag::DIGEST; x.contents_ = y; } void set_to_digest(thinknode_provider_image_info& x, std::string&& y) { x.type = thinknode_provider_image_info_tag::DIGEST; x.contents_ = std::move(y); } bool operator==(thinknode_provider_image_info const& a, thinknode_provider_image_info const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_provider_image_info_tag::TAG: return as_tag(a) == as_tag(b); case thinknode_provider_image_info_tag::DIGEST: return as_digest(a) == as_digest(b); } return true; } bool operator!=(thinknode_provider_image_info const& a, thinknode_provider_image_info const& b) { return !(a == b); } bool operator<(thinknode_provider_image_info const& a, thinknode_provider_image_info const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_provider_image_info_tag::TAG: return as_tag(a) < as_tag(b); case thinknode_provider_image_info_tag::DIGEST: return as_digest(a) < as_digest(b); } return false; } size_t hash_value(thinknode_provider_image_info const& x) {     switch (x.type)     { case thinknode_provider_image_info_tag::TAG: return cradle::invoke_hash(as_tag(x)); case thinknode_provider_image_info_tag::DIGEST: return cradle::invoke_hash(as_digest(x));      } assert(0); return 0; }void swap(thinknode_provider_image_info& a, thinknode_provider_image_info& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_provider_image_info const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_provider_image_info_tag::TAG: to_dynamic(&s[dynamic("tag")], as_tag(x)); break; case thinknode_provider_image_info_tag::DIGEST: to_dynamic(&s[dynamic("digest")], as_digest(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_provider_image_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_provider_image_info_tag::TAG:  { std::string tmp; from_dynamic(&tmp, get_field(s, "tag")); x->contents_ = tmp; break;  } case thinknode_provider_image_info_tag::DIGEST:  { std::string tmp; from_dynamic(&tmp, get_field(s, "digest")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_provider_image_info const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_provider_image_info const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_provider_image_info_tag::TAG: size += deep_sizeof(as_tag(x)); break; case thinknode_provider_image_info_tag::DIGEST: size += deep_sizeof(as_digest(x)); break; } return size; } 

#line 386 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_private_provider_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_private_provider_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_private_provider_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_private_provider_info")); } void structure_field_type_info_adder<thinknode_private_provider_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["image"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_private_provider_info>().image)>(),             none); } bool operator==(thinknode_private_provider_info const& a, thinknode_private_provider_info const& b) { return a.image == b.image; } bool operator!=(thinknode_private_provider_info const& a, thinknode_private_provider_info const& b) { return !(a == b); } bool operator<(thinknode_private_provider_info const& a, thinknode_private_provider_info const& b) { if (a.image < b.image) return true; if (b.image < a.image) return false;     return false; } void swap(thinknode_private_provider_info& a, thinknode_private_provider_info& b) {     using std::swap;     swap(a.image, b.image); } size_t deep_sizeof(thinknode_private_provider_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.image) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_private_provider_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "image", x.image); } void to_dynamic(cradle::dynamic* v, thinknode_private_provider_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_private_provider_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.image, record, "image"); } void from_dynamic(thinknode_private_provider_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_private_provider_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_private_provider_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.image));  return h; }} namespace cradle { 

#line 392 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_provider_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_provider_info_tag>()); } void type_info_query<thinknode_provider_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_info_tag")); } void enum_type_info_query<thinknode_provider_info_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["private"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_provider_info_tag value) {     switch (value)     { case thinknode_provider_info_tag::PRIVATE: return "private";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_provider_info_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_provider_info_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_provider_info_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "private")     {         *x = thinknode_provider_info_tag::PRIVATE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_provider_info_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_provider_info_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_provider_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["private"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_private_provider_info>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_provider_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_info")); } thinknode_provider_info make_thinknode_provider_info_with_private(thinknode_private_provider_info const& x) { thinknode_provider_info s; s.type = thinknode_provider_info_tag::PRIVATE; s.contents_ = x; return s; } thinknode_provider_info make_thinknode_provider_info_with_private(thinknode_private_provider_info&& x) { thinknode_provider_info s; s.type = thinknode_provider_info_tag::PRIVATE; s.contents_ = std::move(x); return s; } thinknode_private_provider_info const& as_private(thinknode_provider_info const& x) { assert(x.type == thinknode_provider_info_tag::PRIVATE); return std::any_cast<thinknode_private_provider_info const& >(x.contents_); } thinknode_private_provider_info& as_private(thinknode_provider_info& x) { assert(x.type == thinknode_provider_info_tag::PRIVATE); return std::any_cast<thinknode_private_provider_info&>(x.contents_); } void set_to_private(thinknode_provider_info& x, thinknode_private_provider_info const& y) { x.type = thinknode_provider_info_tag::PRIVATE; x.contents_ = y; } void set_to_private(thinknode_provider_info& x, thinknode_private_provider_info&& y) { x.type = thinknode_provider_info_tag::PRIVATE; x.contents_ = std::move(y); } bool operator==(thinknode_provider_info const& a, thinknode_provider_info const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_provider_info_tag::PRIVATE: return as_private(a) == as_private(b); } return true; } bool operator!=(thinknode_provider_info const& a, thinknode_provider_info const& b) { return !(a == b); } bool operator<(thinknode_provider_info const& a, thinknode_provider_info const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_provider_info_tag::PRIVATE: return as_private(a) < as_private(b); } return false; } size_t hash_value(thinknode_provider_info const& x) {     switch (x.type)     { case thinknode_provider_info_tag::PRIVATE: return cradle::invoke_hash(as_private(x));      } assert(0); return 0; }void swap(thinknode_provider_info& a, thinknode_provider_info& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_provider_info const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_provider_info_tag::PRIVATE: to_dynamic(&s[dynamic("private")], as_private(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_provider_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_provider_info_tag::PRIVATE:  { thinknode_private_provider_info tmp; from_dynamic(&tmp, get_field(s, "private")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_provider_info const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_provider_info const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_provider_info_tag::PRIVATE: size += deep_sizeof(as_private(x)); break; } return size; } 

#line 398 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_app_manifest>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_app_manifest>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_app_manifest>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_app_manifest")); } void structure_field_type_info_adder<thinknode_app_manifest>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["dependencies"] =         cradle::api_structure_field_info(             "an array of objects that denote the app and version on which the manifest depends",             cradle::get_type_info<decltype(std::declval<thinknode_app_manifest>().dependencies)>(),             none);    (*fields)["provider"] =         cradle::api_structure_field_info(             "a docker container providing function and upgrade implementations",             cradle::get_type_info<decltype(std::declval<thinknode_app_manifest>().provider)>(),             none);    (*fields)["types"] =         cradle::api_structure_field_info(             "an array of types",             cradle::get_type_info<decltype(std::declval<thinknode_app_manifest>().types)>(),             none);    (*fields)["functions"] =         cradle::api_structure_field_info(             "an array of functions",             cradle::get_type_info<decltype(std::declval<thinknode_app_manifest>().functions)>(),             none);    (*fields)["records"] =         cradle::api_structure_field_info(             "an array of records",             cradle::get_type_info<decltype(std::declval<thinknode_app_manifest>().records)>(),             none);    (*fields)["upgrades"] =         cradle::api_structure_field_info(             "an array of upgrade functions to use when migrating data from one version to another",             cradle::get_type_info<decltype(std::declval<thinknode_app_manifest>().upgrades)>(),             none); } bool operator==(thinknode_app_manifest const& a, thinknode_app_manifest const& b) { return a.dependencies == b.dependencies && a.provider == b.provider && a.types == b.types && a.functions == b.functions && a.records == b.records && a.upgrades == b.upgrades; } bool operator!=(thinknode_app_manifest const& a, thinknode_app_manifest const& b) { return !(a == b); } bool operator<(thinknode_app_manifest const& a, thinknode_app_manifest const& b) { if (a.dependencies < b.dependencies) return true; if (b.dependencies < a.dependencies) return false; if (a.provider < b.provider) return true; if (b.provider < a.provider) return false; if (a.types < b.types) return true; if (b.types < a.types) return false; if (a.functions < b.functions) return true; if (b.functions < a.functions) return false; if (a.records < b.records) return true; if (b.records < a.records) return false; if (a.upgrades < b.upgrades) return true; if (b.upgrades < a.upgrades) return false;     return false; } void swap(thinknode_app_manifest& a, thinknode_app_manifest& b) {     using std::swap;     swap(a.dependencies, b.dependencies);     swap(a.provider, b.provider);     swap(a.types, b.types);     swap(a.functions, b.functions);     swap(a.records, b.records);     swap(a.upgrades, b.upgrades); } size_t deep_sizeof(thinknode_app_manifest const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.dependencies) + deep_sizeof(x.provider) + deep_sizeof(x.types) + deep_sizeof(x.functions) + deep_sizeof(x.records) + deep_sizeof(x.upgrades) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_app_manifest const& x) { using cradle::write_field_to_record; write_field_to_record(record, "dependencies", x.dependencies); write_field_to_record(record, "provider", x.provider); write_field_to_record(record, "types", x.types); write_field_to_record(record, "functions", x.functions); write_field_to_record(record, "records", x.records); write_field_to_record(record, "upgrades", x.upgrades); } void to_dynamic(cradle::dynamic* v, thinknode_app_manifest const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_app_manifest& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.dependencies, record, "dependencies"); read_field_from_record(&x.provider, record, "provider"); read_field_from_record(&x.types, record, "types"); read_field_from_record(&x.functions, record, "functions"); read_field_from_record(&x.records, record, "records"); read_field_from_record(&x.upgrades, record, "upgrades"); } void from_dynamic(thinknode_app_manifest* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_app_manifest const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_app_manifest const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.dependencies)); boost::hash_combine(h, cradle::invoke_hash(x.provider)); boost::hash_combine(h, cradle::invoke_hash(x.types)); boost::hash_combine(h, cradle::invoke_hash(x.functions)); boost::hash_combine(h, cradle::invoke_hash(x.records)); boost::hash_combine(h, cradle::invoke_hash(x.upgrades));  return h; }} namespace cradle { 

#line 417 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_app_version_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_app_version_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_app_version_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_app_version_info")); } void structure_field_type_info_adder<thinknode_app_version_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "the name of the version",             cradle::get_type_info<decltype(std::declval<thinknode_app_version_info>().name)>(),             none);    (*fields)["manifest"] =         cradle::api_structure_field_info(             "the manifest for the version",             cradle::get_type_info<decltype(std::declval<thinknode_app_version_info>().manifest)>(),             none);    (*fields)["created_by"] =         cradle::api_structure_field_info(             "the user that created the version",             cradle::get_type_info<decltype(std::declval<thinknode_app_version_info>().created_by)>(),             none);    (*fields)["created_at"] =         cradle::api_structure_field_info(             "the date and time when the version was created",             cradle::get_type_info<decltype(std::declval<thinknode_app_version_info>().created_at)>(),             none); } bool operator==(thinknode_app_version_info const& a, thinknode_app_version_info const& b) { return a.name == b.name && a.manifest == b.manifest && a.created_by == b.created_by && a.created_at == b.created_at; } bool operator!=(thinknode_app_version_info const& a, thinknode_app_version_info const& b) { return !(a == b); } bool operator<(thinknode_app_version_info const& a, thinknode_app_version_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.manifest < b.manifest) return true; if (b.manifest < a.manifest) return false; if (a.created_by < b.created_by) return true; if (b.created_by < a.created_by) return false; if (a.created_at < b.created_at) return true; if (b.created_at < a.created_at) return false;     return false; } void swap(thinknode_app_version_info& a, thinknode_app_version_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.manifest, b.manifest);     swap(a.created_by, b.created_by);     swap(a.created_at, b.created_at); } size_t deep_sizeof(thinknode_app_version_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.manifest) + deep_sizeof(x.created_by) + deep_sizeof(x.created_at) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_app_version_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "manifest", x.manifest); write_field_to_record(record, "created_by", x.created_by); write_field_to_record(record, "created_at", x.created_at); } void to_dynamic(cradle::dynamic* v, thinknode_app_version_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_app_version_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.manifest, record, "manifest"); read_field_from_record(&x.created_by, record, "created_by"); read_field_from_record(&x.created_at, record, "created_at"); } void from_dynamic(thinknode_app_version_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_app_version_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_app_version_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.manifest)); boost::hash_combine(h, cradle::invoke_hash(x.created_by)); boost::hash_combine(h, cradle::invoke_hash(x.created_at));  return h; }} namespace cradle { 

#line 430 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_app_source_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_app_source_info_tag>()); } void type_info_query<thinknode_app_source_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_app_source_info_tag")); } void enum_type_info_query<thinknode_app_source_info_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["version"] =  cradle::api_enum_value_info( "");values["branch"] =  cradle::api_enum_value_info( "");values["commit"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_app_source_info_tag value) {     switch (value)     { case thinknode_app_source_info_tag::VERSION: return "version";case thinknode_app_source_info_tag::BRANCH: return "branch";case thinknode_app_source_info_tag::COMMIT: return "commit";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_app_source_info_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_app_source_info_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_app_source_info_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "version")     {         *x = thinknode_app_source_info_tag::VERSION;         return;     };    if (boost::to_lower_copy(s) == "branch")     {         *x = thinknode_app_source_info_tag::BRANCH;         return;     };    if (boost::to_lower_copy(s) == "commit")     {         *x = thinknode_app_source_info_tag::COMMIT;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_app_source_info_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_app_source_info_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_app_source_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["version"] =         cradle::api_union_member_info(             "the name of the source version",             cradle::get_type_info<std::string>());    members["branch"] =         cradle::api_union_member_info(             "the name of the source branch",             cradle::get_type_info<std::string>());    members["commit"] =         cradle::api_union_member_info(             "the unique id of the source commit - Note that this is only returned if the associated commit is not the current head of a branch",             cradle::get_type_info<std::string>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_app_source_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_app_source_info")); } thinknode_app_source_info make_thinknode_app_source_info_with_version(std::string const& x) { thinknode_app_source_info s; s.type = thinknode_app_source_info_tag::VERSION; s.contents_ = x; return s; } thinknode_app_source_info make_thinknode_app_source_info_with_version(std::string&& x) { thinknode_app_source_info s; s.type = thinknode_app_source_info_tag::VERSION; s.contents_ = std::move(x); return s; } thinknode_app_source_info make_thinknode_app_source_info_with_branch(std::string const& x) { thinknode_app_source_info s; s.type = thinknode_app_source_info_tag::BRANCH; s.contents_ = x; return s; } thinknode_app_source_info make_thinknode_app_source_info_with_branch(std::string&& x) { thinknode_app_source_info s; s.type = thinknode_app_source_info_tag::BRANCH; s.contents_ = std::move(x); return s; } thinknode_app_source_info make_thinknode_app_source_info_with_commit(std::string const& x) { thinknode_app_source_info s; s.type = thinknode_app_source_info_tag::COMMIT; s.contents_ = x; return s; } thinknode_app_source_info make_thinknode_app_source_info_with_commit(std::string&& x) { thinknode_app_source_info s; s.type = thinknode_app_source_info_tag::COMMIT; s.contents_ = std::move(x); return s; } std::string const& as_version(thinknode_app_source_info const& x) { assert(x.type == thinknode_app_source_info_tag::VERSION); return std::any_cast<std::string const& >(x.contents_); } std::string const& as_branch(thinknode_app_source_info const& x) { assert(x.type == thinknode_app_source_info_tag::BRANCH); return std::any_cast<std::string const& >(x.contents_); } std::string const& as_commit(thinknode_app_source_info const& x) { assert(x.type == thinknode_app_source_info_tag::COMMIT); return std::any_cast<std::string const& >(x.contents_); } std::string& as_version(thinknode_app_source_info& x) { assert(x.type == thinknode_app_source_info_tag::VERSION); return std::any_cast<std::string&>(x.contents_); } std::string& as_branch(thinknode_app_source_info& x) { assert(x.type == thinknode_app_source_info_tag::BRANCH); return std::any_cast<std::string&>(x.contents_); } std::string& as_commit(thinknode_app_source_info& x) { assert(x.type == thinknode_app_source_info_tag::COMMIT); return std::any_cast<std::string&>(x.contents_); } void set_to_version(thinknode_app_source_info& x, std::string const& y) { x.type = thinknode_app_source_info_tag::VERSION; x.contents_ = y; } void set_to_version(thinknode_app_source_info& x, std::string&& y) { x.type = thinknode_app_source_info_tag::VERSION; x.contents_ = std::move(y); } void set_to_branch(thinknode_app_source_info& x, std::string const& y) { x.type = thinknode_app_source_info_tag::BRANCH; x.contents_ = y; } void set_to_branch(thinknode_app_source_info& x, std::string&& y) { x.type = thinknode_app_source_info_tag::BRANCH; x.contents_ = std::move(y); } void set_to_commit(thinknode_app_source_info& x, std::string const& y) { x.type = thinknode_app_source_info_tag::COMMIT; x.contents_ = y; } void set_to_commit(thinknode_app_source_info& x, std::string&& y) { x.type = thinknode_app_source_info_tag::COMMIT; x.contents_ = std::move(y); } bool operator==(thinknode_app_source_info const& a, thinknode_app_source_info const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_app_source_info_tag::VERSION: return as_version(a) == as_version(b); case thinknode_app_source_info_tag::BRANCH: return as_branch(a) == as_branch(b); case thinknode_app_source_info_tag::COMMIT: return as_commit(a) == as_commit(b); } return true; } bool operator!=(thinknode_app_source_info const& a, thinknode_app_source_info const& b) { return !(a == b); } bool operator<(thinknode_app_source_info const& a, thinknode_app_source_info const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_app_source_info_tag::VERSION: return as_version(a) < as_version(b); case thinknode_app_source_info_tag::BRANCH: return as_branch(a) < as_branch(b); case thinknode_app_source_info_tag::COMMIT: return as_commit(a) < as_commit(b); } return false; } size_t hash_value(thinknode_app_source_info const& x) {     switch (x.type)     { case thinknode_app_source_info_tag::VERSION: return cradle::invoke_hash(as_version(x)); case thinknode_app_source_info_tag::BRANCH: return cradle::invoke_hash(as_branch(x)); case thinknode_app_source_info_tag::COMMIT: return cradle::invoke_hash(as_commit(x));      } assert(0); return 0; }void swap(thinknode_app_source_info& a, thinknode_app_source_info& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_app_source_info const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_app_source_info_tag::VERSION: to_dynamic(&s[dynamic("version")], as_version(x)); break; case thinknode_app_source_info_tag::BRANCH: to_dynamic(&s[dynamic("branch")], as_branch(x)); break; case thinknode_app_source_info_tag::COMMIT: to_dynamic(&s[dynamic("commit")], as_commit(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_app_source_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_app_source_info_tag::VERSION:  { std::string tmp; from_dynamic(&tmp, get_field(s, "version")); x->contents_ = tmp; break;  } case thinknode_app_source_info_tag::BRANCH:  { std::string tmp; from_dynamic(&tmp, get_field(s, "branch")); x->contents_ = tmp; break;  } case thinknode_app_source_info_tag::COMMIT:  { std::string tmp; from_dynamic(&tmp, get_field(s, "commit")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_app_source_info const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_app_source_info const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_app_source_info_tag::VERSION: size += deep_sizeof(as_version(x)); break; case thinknode_app_source_info_tag::BRANCH: size += deep_sizeof(as_branch(x)); break; case thinknode_app_source_info_tag::COMMIT: size += deep_sizeof(as_commit(x)); break; } return size; } 

#line 444 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_context_app_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_context_app_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_context_app_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_context_app_info")); } void structure_field_type_info_adder<thinknode_context_app_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["account"] =         cradle::api_structure_field_info(             "the name of the account responsible for publishing the app",             cradle::get_type_info<decltype(std::declval<thinknode_context_app_info>().account)>(),             none);    (*fields)["app"] =         cradle::api_structure_field_info(             "the name of the app",             cradle::get_type_info<decltype(std::declval<thinknode_context_app_info>().app)>(),             none);    (*fields)["source"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_context_app_info>().source)>(),             none); } bool operator==(thinknode_context_app_info const& a, thinknode_context_app_info const& b) { return a.account == b.account && a.app == b.app && a.source == b.source; } bool operator!=(thinknode_context_app_info const& a, thinknode_context_app_info const& b) { return !(a == b); } bool operator<(thinknode_context_app_info const& a, thinknode_context_app_info const& b) { if (a.account < b.account) return true; if (b.account < a.account) return false; if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.source < b.source) return true; if (b.source < a.source) return false;     return false; } void swap(thinknode_context_app_info& a, thinknode_context_app_info& b) {     using std::swap;     swap(a.account, b.account);     swap(a.app, b.app);     swap(a.source, b.source); } size_t deep_sizeof(thinknode_context_app_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.account) + deep_sizeof(x.app) + deep_sizeof(x.source) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_context_app_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "account", x.account); write_field_to_record(record, "app", x.app); write_field_to_record(record, "source", x.source); } void to_dynamic(cradle::dynamic* v, thinknode_context_app_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_context_app_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.account, record, "account"); read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.source, record, "source"); } void from_dynamic(thinknode_context_app_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_context_app_info const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_context_app_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.account)); boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.source));  return h; }} namespace cradle { 

#line 454 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_context_contents>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_context_contents>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_context_contents>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_context_contents")); } void structure_field_type_info_adder<thinknode_context_contents>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["bucket"] =         cradle::api_structure_field_info(             "the bucket for the context",             cradle::get_type_info<decltype(std::declval<thinknode_context_contents>().bucket)>(),             none);    (*fields)["contents"] =         cradle::api_structure_field_info(             "a list of apps within the context",             cradle::get_type_info<decltype(std::declval<thinknode_context_contents>().contents)>(),             none); } bool operator==(thinknode_context_contents const& a, thinknode_context_contents const& b) { return a.bucket == b.bucket && a.contents == b.contents; } bool operator!=(thinknode_context_contents const& a, thinknode_context_contents const& b) { return !(a == b); } bool operator<(thinknode_context_contents const& a, thinknode_context_contents const& b) { if (a.bucket < b.bucket) return true; if (b.bucket < a.bucket) return false; if (a.contents < b.contents) return true; if (b.contents < a.contents) return false;     return false; } void swap(thinknode_context_contents& a, thinknode_context_contents& b) {     using std::swap;     swap(a.bucket, b.bucket);     swap(a.contents, b.contents); } size_t deep_sizeof(thinknode_context_contents const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.bucket) + deep_sizeof(x.contents) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_context_contents const& x) { using cradle::write_field_to_record; write_field_to_record(record, "bucket", x.bucket); write_field_to_record(record, "contents", x.contents); } void to_dynamic(cradle::dynamic* v, thinknode_context_contents const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_context_contents& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.bucket, record, "bucket"); read_field_from_record(&x.contents, record, "contents"); } void from_dynamic(thinknode_context_contents* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_context_contents const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_context_contents const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.bucket)); boost::hash_combine(h, cradle::invoke_hash(x.contents));  return h; }} namespace cradle { 

#line 463 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_supervisor_calculation_request>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_supervisor_calculation_request>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_supervisor_calculation_request>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_supervisor_calculation_request")); } void structure_field_type_info_adder<thinknode_supervisor_calculation_request>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "the name of the function to invoke",             cradle::get_type_info<decltype(std::declval<thinknode_supervisor_calculation_request>().name)>(),             none);    (*fields)["args"] =         cradle::api_structure_field_info(             "the arguments to the function",             cradle::get_type_info<decltype(std::declval<thinknode_supervisor_calculation_request>().args)>(),             none); } bool operator==(thinknode_supervisor_calculation_request const& a, thinknode_supervisor_calculation_request const& b) { return a.name == b.name && a.args == b.args; } bool operator!=(thinknode_supervisor_calculation_request const& a, thinknode_supervisor_calculation_request const& b) { return !(a == b); } bool operator<(thinknode_supervisor_calculation_request const& a, thinknode_supervisor_calculation_request const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.args < b.args) return true; if (b.args < a.args) return false;     return false; } void swap(thinknode_supervisor_calculation_request& a, thinknode_supervisor_calculation_request& b) {     using std::swap;     swap(a.name, b.name);     swap(a.args, b.args); } size_t deep_sizeof(thinknode_supervisor_calculation_request const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.args) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_supervisor_calculation_request const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "args", x.args); } void to_dynamic(cradle::dynamic* v, thinknode_supervisor_calculation_request const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_supervisor_calculation_request& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.args, record, "args"); } void from_dynamic(thinknode_supervisor_calculation_request* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_supervisor_calculation_request const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_supervisor_calculation_request const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.args));  return h; }} namespace cradle { 

#line 472 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_supervisor_message_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_supervisor_message_tag>()); } void type_info_query<thinknode_supervisor_message_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_supervisor_message_tag")); } void enum_type_info_query<thinknode_supervisor_message_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["function"] =  cradle::api_enum_value_info( "");values["ping"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_supervisor_message_tag value) {     switch (value)     { case thinknode_supervisor_message_tag::FUNCTION: return "function";case thinknode_supervisor_message_tag::PING: return "ping";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_supervisor_message_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_supervisor_message_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_supervisor_message_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "function")     {         *x = thinknode_supervisor_message_tag::FUNCTION;         return;     };    if (boost::to_lower_copy(s) == "ping")     {         *x = thinknode_supervisor_message_tag::PING;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_supervisor_message_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_supervisor_message_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_supervisor_message>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["function"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_supervisor_calculation_request>());    members["ping"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<std::string>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_supervisor_message>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_supervisor_message")); } thinknode_supervisor_message make_thinknode_supervisor_message_with_function(thinknode_supervisor_calculation_request const& x) { thinknode_supervisor_message s; s.type = thinknode_supervisor_message_tag::FUNCTION; s.contents_ = x; return s; } thinknode_supervisor_message make_thinknode_supervisor_message_with_function(thinknode_supervisor_calculation_request&& x) { thinknode_supervisor_message s; s.type = thinknode_supervisor_message_tag::FUNCTION; s.contents_ = std::move(x); return s; } thinknode_supervisor_message make_thinknode_supervisor_message_with_ping(std::string const& x) { thinknode_supervisor_message s; s.type = thinknode_supervisor_message_tag::PING; s.contents_ = x; return s; } thinknode_supervisor_message make_thinknode_supervisor_message_with_ping(std::string&& x) { thinknode_supervisor_message s; s.type = thinknode_supervisor_message_tag::PING; s.contents_ = std::move(x); return s; } thinknode_supervisor_calculation_request const& as_function(thinknode_supervisor_message const& x) { assert(x.type == thinknode_supervisor_message_tag::FUNCTION); return std::any_cast<thinknode_supervisor_calculation_request const& >(x.contents_); } std::string const& as_ping(thinknode_supervisor_message const& x) { assert(x.type == thinknode_supervisor_message_tag::PING); return std::any_cast<std::string const& >(x.contents_); } thinknode_supervisor_calculation_request& as_function(thinknode_supervisor_message& x) { assert(x.type == thinknode_supervisor_message_tag::FUNCTION); return std::any_cast<thinknode_supervisor_calculation_request&>(x.contents_); } std::string& as_ping(thinknode_supervisor_message& x) { assert(x.type == thinknode_supervisor_message_tag::PING); return std::any_cast<std::string&>(x.contents_); } void set_to_function(thinknode_supervisor_message& x, thinknode_supervisor_calculation_request const& y) { x.type = thinknode_supervisor_message_tag::FUNCTION; x.contents_ = y; } void set_to_function(thinknode_supervisor_message& x, thinknode_supervisor_calculation_request&& y) { x.type = thinknode_supervisor_message_tag::FUNCTION; x.contents_ = std::move(y); } void set_to_ping(thinknode_supervisor_message& x, std::string const& y) { x.type = thinknode_supervisor_message_tag::PING; x.contents_ = y; } void set_to_ping(thinknode_supervisor_message& x, std::string&& y) { x.type = thinknode_supervisor_message_tag::PING; x.contents_ = std::move(y); } bool operator==(thinknode_supervisor_message const& a, thinknode_supervisor_message const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_supervisor_message_tag::FUNCTION: return as_function(a) == as_function(b); case thinknode_supervisor_message_tag::PING: return as_ping(a) == as_ping(b); } return true; } bool operator!=(thinknode_supervisor_message const& a, thinknode_supervisor_message const& b) { return !(a == b); } bool operator<(thinknode_supervisor_message const& a, thinknode_supervisor_message const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_supervisor_message_tag::FUNCTION: return as_function(a) < as_function(b); case thinknode_supervisor_message_tag::PING: return as_ping(a) < as_ping(b); } return false; } size_t hash_value(thinknode_supervisor_message const& x) {     switch (x.type)     { case thinknode_supervisor_message_tag::FUNCTION: return cradle::invoke_hash(as_function(x)); case thinknode_supervisor_message_tag::PING: return cradle::invoke_hash(as_ping(x));      } assert(0); return 0; }void swap(thinknode_supervisor_message& a, thinknode_supervisor_message& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_supervisor_message const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_supervisor_message_tag::FUNCTION: to_dynamic(&s[dynamic("function")], as_function(x)); break; case thinknode_supervisor_message_tag::PING: to_dynamic(&s[dynamic("ping")], as_ping(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_supervisor_message* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_supervisor_message_tag::FUNCTION:  { thinknode_supervisor_calculation_request tmp; from_dynamic(&tmp, get_field(s, "function")); x->contents_ = tmp; break;  } case thinknode_supervisor_message_tag::PING:  { std::string tmp; from_dynamic(&tmp, get_field(s, "ping")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_supervisor_message const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_supervisor_message const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_supervisor_message_tag::FUNCTION: size += deep_sizeof(as_function(x)); break; case thinknode_supervisor_message_tag::PING: size += deep_sizeof(as_ping(x)); break; } return size; } 

#line 479 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_provider_progress_update>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_provider_progress_update>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_provider_progress_update>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_progress_update")); } void structure_field_type_info_adder<thinknode_provider_progress_update>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["value"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_provider_progress_update>().value)>(),             none);    (*fields)["message"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_provider_progress_update>().message)>(),             none); } bool operator==(thinknode_provider_progress_update const& a, thinknode_provider_progress_update const& b) { return a.value == b.value && a.message == b.message; } bool operator!=(thinknode_provider_progress_update const& a, thinknode_provider_progress_update const& b) { return !(a == b); } bool operator<(thinknode_provider_progress_update const& a, thinknode_provider_progress_update const& b) { if (a.value < b.value) return true; if (b.value < a.value) return false; if (a.message < b.message) return true; if (b.message < a.message) return false;     return false; } void swap(thinknode_provider_progress_update& a, thinknode_provider_progress_update& b) {     using std::swap;     swap(a.value, b.value);     swap(a.message, b.message); } size_t deep_sizeof(thinknode_provider_progress_update const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.value) + deep_sizeof(x.message) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_provider_progress_update const& x) { using cradle::write_field_to_record; write_field_to_record(record, "value", x.value); write_field_to_record(record, "message", x.message); } void to_dynamic(cradle::dynamic* v, thinknode_provider_progress_update const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_provider_progress_update& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.value, record, "value"); read_field_from_record(&x.message, record, "message"); } void from_dynamic(thinknode_provider_progress_update* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_provider_progress_update const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_provider_progress_update const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.value)); boost::hash_combine(h, cradle::invoke_hash(x.message));  return h; }} namespace cradle { 

#line 486 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_provider_failure>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_provider_failure>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_provider_failure>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_failure")); } void structure_field_type_info_adder<thinknode_provider_failure>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["code"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_provider_failure>().code)>(),             none);    (*fields)["message"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<thinknode_provider_failure>().message)>(),             none); } bool operator==(thinknode_provider_failure const& a, thinknode_provider_failure const& b) { return a.code == b.code && a.message == b.message; } bool operator!=(thinknode_provider_failure const& a, thinknode_provider_failure const& b) { return !(a == b); } bool operator<(thinknode_provider_failure const& a, thinknode_provider_failure const& b) { if (a.code < b.code) return true; if (b.code < a.code) return false; if (a.message < b.message) return true; if (b.message < a.message) return false;     return false; } void swap(thinknode_provider_failure& a, thinknode_provider_failure& b) {     using std::swap;     swap(a.code, b.code);     swap(a.message, b.message); } size_t deep_sizeof(thinknode_provider_failure const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.code) + deep_sizeof(x.message) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_provider_failure const& x) { using cradle::write_field_to_record; write_field_to_record(record, "code", x.code); write_field_to_record(record, "message", x.message); } void to_dynamic(cradle::dynamic* v, thinknode_provider_failure const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_provider_failure& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.code, record, "code"); read_field_from_record(&x.message, record, "message"); } void from_dynamic(thinknode_provider_failure* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_provider_failure const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_provider_failure const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.code)); boost::hash_combine(h, cradle::invoke_hash(x.message));  return h; }} namespace cradle { 

#line 493 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { void definitive_type_info_query<thinknode_provider_registration>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<thinknode_provider_registration>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<thinknode_provider_registration>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_registration")); } void structure_field_type_info_adder<thinknode_provider_registration>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["protocol"] =         cradle::api_structure_field_info(             "protocol version",             cradle::get_type_info<decltype(std::declval<thinknode_provider_registration>().protocol)>(),             none);    (*fields)["pid"] =         cradle::api_structure_field_info(             "unique ID assigned to this provider",             cradle::get_type_info<decltype(std::declval<thinknode_provider_registration>().pid)>(),             none); } bool operator==(thinknode_provider_registration const& a, thinknode_provider_registration const& b) { return a.protocol == b.protocol && a.pid == b.pid; } bool operator!=(thinknode_provider_registration const& a, thinknode_provider_registration const& b) { return !(a == b); } bool operator<(thinknode_provider_registration const& a, thinknode_provider_registration const& b) { if (a.protocol < b.protocol) return true; if (b.protocol < a.protocol) return false; if (a.pid < b.pid) return true; if (b.pid < a.pid) return false;     return false; } void swap(thinknode_provider_registration& a, thinknode_provider_registration& b) {     using std::swap;     swap(a.protocol, b.protocol);     swap(a.pid, b.pid); } size_t deep_sizeof(thinknode_provider_registration const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.protocol) + deep_sizeof(x.pid) ; } void write_fields_to_record(cradle::dynamic_map& record, thinknode_provider_registration const& x) { using cradle::write_field_to_record; write_field_to_record(record, "protocol", x.protocol); write_field_to_record(record, "pid", x.pid); } void to_dynamic(cradle::dynamic* v, thinknode_provider_registration const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(thinknode_provider_registration& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.protocol, record, "protocol"); read_field_from_record(&x.pid, record, "pid"); } void from_dynamic(thinknode_provider_registration* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, thinknode_provider_registration const& x) { return s << to_dynamic(x); } size_t hash_value(thinknode_provider_registration const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.protocol)); boost::hash_combine(h, cradle::invoke_hash(x.pid));  return h; }} namespace cradle { 

#line 502 "C:/dev/open-cradle/cradle/src/cradle/thinknode/types.hpp"
void definitive_type_info_query<thinknode_provider_message_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<thinknode_provider_message_tag>()); } void type_info_query<thinknode_provider_message_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_message_tag")); } void enum_type_info_query<thinknode_provider_message_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["registration"] =  cradle::api_enum_value_info( "");values["progress"] =  cradle::api_enum_value_info( "");values["pong"] =  cradle::api_enum_value_info( "");values["result"] =  cradle::api_enum_value_info( "");values["failure"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(thinknode_provider_message_tag value) {     switch (value)     { case thinknode_provider_message_tag::REGISTRATION: return "registration";case thinknode_provider_message_tag::PROGRESS: return "progress";case thinknode_provider_message_tag::PONG: return "pong";case thinknode_provider_message_tag::RESULT: return "result";case thinknode_provider_message_tag::FAILURE: return "failure";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("thinknode_provider_message_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     thinknode_provider_message_tag x) {     *v = get_value_id(x); } void from_dynamic(     thinknode_provider_message_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "registration")     {         *x = thinknode_provider_message_tag::REGISTRATION;         return;     };    if (boost::to_lower_copy(s) == "progress")     {         *x = thinknode_provider_message_tag::PROGRESS;         return;     };    if (boost::to_lower_copy(s) == "pong")     {         *x = thinknode_provider_message_tag::PONG;         return;     };    if (boost::to_lower_copy(s) == "result")     {         *x = thinknode_provider_message_tag::RESULT;         return;     };    if (boost::to_lower_copy(s) == "failure")     {         *x = thinknode_provider_message_tag::FAILURE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("thinknode_provider_message_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, thinknode_provider_message_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<thinknode_provider_message>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["registration"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_provider_registration>());    members["progress"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_provider_progress_update>());    members["pong"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<std::string>());    members["result"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<dynamic>());    members["failure"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<thinknode_provider_failure>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<thinknode_provider_message>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "thinknode_provider_message")); } thinknode_provider_message make_thinknode_provider_message_with_registration(thinknode_provider_registration const& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::REGISTRATION; s.contents_ = x; return s; } thinknode_provider_message make_thinknode_provider_message_with_registration(thinknode_provider_registration&& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::REGISTRATION; s.contents_ = std::move(x); return s; } thinknode_provider_message make_thinknode_provider_message_with_progress(thinknode_provider_progress_update const& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::PROGRESS; s.contents_ = x; return s; } thinknode_provider_message make_thinknode_provider_message_with_progress(thinknode_provider_progress_update&& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::PROGRESS; s.contents_ = std::move(x); return s; } thinknode_provider_message make_thinknode_provider_message_with_pong(std::string const& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::PONG; s.contents_ = x; return s; } thinknode_provider_message make_thinknode_provider_message_with_pong(std::string&& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::PONG; s.contents_ = std::move(x); return s; } thinknode_provider_message make_thinknode_provider_message_with_result(dynamic const& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::RESULT; s.contents_ = x; return s; } thinknode_provider_message make_thinknode_provider_message_with_result(dynamic&& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::RESULT; s.contents_ = std::move(x); return s; } thinknode_provider_message make_thinknode_provider_message_with_failure(thinknode_provider_failure const& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::FAILURE; s.contents_ = x; return s; } thinknode_provider_message make_thinknode_provider_message_with_failure(thinknode_provider_failure&& x) { thinknode_provider_message s; s.type = thinknode_provider_message_tag::FAILURE; s.contents_ = std::move(x); return s; } thinknode_provider_registration const& as_registration(thinknode_provider_message const& x) { assert(x.type == thinknode_provider_message_tag::REGISTRATION); return std::any_cast<thinknode_provider_registration const& >(x.contents_); } thinknode_provider_progress_update const& as_progress(thinknode_provider_message const& x) { assert(x.type == thinknode_provider_message_tag::PROGRESS); return std::any_cast<thinknode_provider_progress_update const& >(x.contents_); } std::string const& as_pong(thinknode_provider_message const& x) { assert(x.type == thinknode_provider_message_tag::PONG); return std::any_cast<std::string const& >(x.contents_); } dynamic const& as_result(thinknode_provider_message const& x) { assert(x.type == thinknode_provider_message_tag::RESULT); return std::any_cast<dynamic const& >(x.contents_); } thinknode_provider_failure const& as_failure(thinknode_provider_message const& x) { assert(x.type == thinknode_provider_message_tag::FAILURE); return std::any_cast<thinknode_provider_failure const& >(x.contents_); } thinknode_provider_registration& as_registration(thinknode_provider_message& x) { assert(x.type == thinknode_provider_message_tag::REGISTRATION); return std::any_cast<thinknode_provider_registration&>(x.contents_); } thinknode_provider_progress_update& as_progress(thinknode_provider_message& x) { assert(x.type == thinknode_provider_message_tag::PROGRESS); return std::any_cast<thinknode_provider_progress_update&>(x.contents_); } std::string& as_pong(thinknode_provider_message& x) { assert(x.type == thinknode_provider_message_tag::PONG); return std::any_cast<std::string&>(x.contents_); } dynamic& as_result(thinknode_provider_message& x) { assert(x.type == thinknode_provider_message_tag::RESULT); return std::any_cast<dynamic&>(x.contents_); } thinknode_provider_failure& as_failure(thinknode_provider_message& x) { assert(x.type == thinknode_provider_message_tag::FAILURE); return std::any_cast<thinknode_provider_failure&>(x.contents_); } void set_to_registration(thinknode_provider_message& x, thinknode_provider_registration const& y) { x.type = thinknode_provider_message_tag::REGISTRATION; x.contents_ = y; } void set_to_registration(thinknode_provider_message& x, thinknode_provider_registration&& y) { x.type = thinknode_provider_message_tag::REGISTRATION; x.contents_ = std::move(y); } void set_to_progress(thinknode_provider_message& x, thinknode_provider_progress_update const& y) { x.type = thinknode_provider_message_tag::PROGRESS; x.contents_ = y; } void set_to_progress(thinknode_provider_message& x, thinknode_provider_progress_update&& y) { x.type = thinknode_provider_message_tag::PROGRESS; x.contents_ = std::move(y); } void set_to_pong(thinknode_provider_message& x, std::string const& y) { x.type = thinknode_provider_message_tag::PONG; x.contents_ = y; } void set_to_pong(thinknode_provider_message& x, std::string&& y) { x.type = thinknode_provider_message_tag::PONG; x.contents_ = std::move(y); } void set_to_result(thinknode_provider_message& x, dynamic const& y) { x.type = thinknode_provider_message_tag::RESULT; x.contents_ = y; } void set_to_result(thinknode_provider_message& x, dynamic&& y) { x.type = thinknode_provider_message_tag::RESULT; x.contents_ = std::move(y); } void set_to_failure(thinknode_provider_message& x, thinknode_provider_failure const& y) { x.type = thinknode_provider_message_tag::FAILURE; x.contents_ = y; } void set_to_failure(thinknode_provider_message& x, thinknode_provider_failure&& y) { x.type = thinknode_provider_message_tag::FAILURE; x.contents_ = std::move(y); } bool operator==(thinknode_provider_message const& a, thinknode_provider_message const& b) { if (a.type != b.type) return false; switch (a.type) { case thinknode_provider_message_tag::REGISTRATION: return as_registration(a) == as_registration(b); case thinknode_provider_message_tag::PROGRESS: return as_progress(a) == as_progress(b); case thinknode_provider_message_tag::PONG: return as_pong(a) == as_pong(b); case thinknode_provider_message_tag::RESULT: return as_result(a) == as_result(b); case thinknode_provider_message_tag::FAILURE: return as_failure(a) == as_failure(b); } return true; } bool operator!=(thinknode_provider_message const& a, thinknode_provider_message const& b) { return !(a == b); } bool operator<(thinknode_provider_message const& a, thinknode_provider_message const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case thinknode_provider_message_tag::REGISTRATION: return as_registration(a) < as_registration(b); case thinknode_provider_message_tag::PROGRESS: return as_progress(a) < as_progress(b); case thinknode_provider_message_tag::PONG: return as_pong(a) < as_pong(b); case thinknode_provider_message_tag::RESULT: return as_result(a) < as_result(b); case thinknode_provider_message_tag::FAILURE: return as_failure(a) < as_failure(b); } return false; } size_t hash_value(thinknode_provider_message const& x) {     switch (x.type)     { case thinknode_provider_message_tag::REGISTRATION: return cradle::invoke_hash(as_registration(x)); case thinknode_provider_message_tag::PROGRESS: return cradle::invoke_hash(as_progress(x)); case thinknode_provider_message_tag::PONG: return cradle::invoke_hash(as_pong(x)); case thinknode_provider_message_tag::RESULT: return cradle::invoke_hash(as_result(x)); case thinknode_provider_message_tag::FAILURE: return cradle::invoke_hash(as_failure(x));      } assert(0); return 0; }void swap(thinknode_provider_message& a, thinknode_provider_message& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, thinknode_provider_message const& x) { cradle::dynamic_map s; switch (x.type) { case thinknode_provider_message_tag::REGISTRATION: to_dynamic(&s[dynamic("registration")], as_registration(x)); break; case thinknode_provider_message_tag::PROGRESS: to_dynamic(&s[dynamic("progress")], as_progress(x)); break; case thinknode_provider_message_tag::PONG: to_dynamic(&s[dynamic("pong")], as_pong(x)); break; case thinknode_provider_message_tag::RESULT: to_dynamic(&s[dynamic("result")], as_result(x)); break; case thinknode_provider_message_tag::FAILURE: to_dynamic(&s[dynamic("failure")], as_failure(x)); break; } *v = std::move(s); } void from_dynamic(thinknode_provider_message* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case thinknode_provider_message_tag::REGISTRATION:  { thinknode_provider_registration tmp; from_dynamic(&tmp, get_field(s, "registration")); x->contents_ = tmp; break;  } case thinknode_provider_message_tag::PROGRESS:  { thinknode_provider_progress_update tmp; from_dynamic(&tmp, get_field(s, "progress")); x->contents_ = tmp; break;  } case thinknode_provider_message_tag::PONG:  { std::string tmp; from_dynamic(&tmp, get_field(s, "pong")); x->contents_ = tmp; break;  } case thinknode_provider_message_tag::RESULT:  { dynamic tmp; from_dynamic(&tmp, get_field(s, "result")); x->contents_ = tmp; break;  } case thinknode_provider_message_tag::FAILURE:  { thinknode_provider_failure tmp; from_dynamic(&tmp, get_field(s, "failure")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, thinknode_provider_message const& x) { return s << to_dynamic(x); } size_t deep_sizeof(thinknode_provider_message const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case thinknode_provider_message_tag::REGISTRATION: size += deep_sizeof(as_registration(x)); break; case thinknode_provider_message_tag::PROGRESS: size += deep_sizeof(as_progress(x)); break; case thinknode_provider_message_tag::PONG: size += deep_sizeof(as_pong(x)); break; case thinknode_provider_message_tag::RESULT: size += deep_sizeof(as_result(x)); break; case thinknode_provider_message_tag::FAILURE: size += deep_sizeof(as_failure(x)); break; } return size; } 

}

namespace cradle {
void add_src_cradle_thinknode_types_api(cradle::api_implementation& api)
{
register_api_named_type(     api,     "thinknode_service_id",     0,     "",     get_definitive_type_info<thinknode_service_id>());register_api_named_type(     api,     "thinknode_session",     0,     "",     get_definitive_type_info<thinknode_session>());register_api_named_type(     api,     "thinknode_type_info",     0,     "",     get_definitive_type_info<thinknode_type_info>());register_api_named_type(     api,     "thinknode_calc_request",     0,     "",     get_definitive_type_info<thinknode_calc_request>());register_api_named_type(     api,     "thinknode_function_application",     0,     "",     get_definitive_type_info<thinknode_function_application>());register_api_named_type(     api,     "thinknode_array_calc",     0,     "",     get_definitive_type_info<thinknode_array_calc>());register_api_named_type(     api,     "thinknode_object_calc",     0,     "",     get_definitive_type_info<thinknode_object_calc>());register_api_named_type(     api,     "thinknode_item_calc",     0,     "",     get_definitive_type_info<thinknode_item_calc>());register_api_named_type(     api,     "thinknode_property_calc",     0,     "",     get_definitive_type_info<thinknode_property_calc>());register_api_named_type(     api,     "thinknode_meta_calc",     0,     "",     get_definitive_type_info<thinknode_meta_calc>());register_api_named_type(     api,     "thinknode_cast_request",     0,     "",     get_definitive_type_info<thinknode_cast_request>());register_api_named_type(     api,     "thinknode_let_calc",     0,     "",     get_definitive_type_info<thinknode_let_calc>());register_api_named_type(     api,     "id_response",     0,     "This describes an HTTP response with just an ID field.",     get_definitive_type_info<id_response>());register_api_named_type(     api,     "reported_calculation_info",     0,     "",     get_definitive_type_info<reported_calculation_info>());register_api_named_type(     api,     "let_calculation_submission_info",     0,     "",     get_definitive_type_info<let_calculation_submission_info>());register_api_named_type(     api,     "augmented_calculation_request",     0,     "This augments a normal Thinknode calculation request with extra information that's useful for status reporting.",     get_definitive_type_info<augmented_calculation_request>());register_api_named_type(     api,     "calculation_queue_type",     0,     "",     get_definitive_type_info<calculation_queue_type>());register_api_named_type(     api,     "calculation_calculating_status",     0,     "",     get_definitive_type_info<calculation_calculating_status>());register_api_named_type(     api,     "calculation_uploading_status",     0,     "",     get_definitive_type_info<calculation_uploading_status>());register_api_named_type(     api,     "calculation_failure_status",     0,     "",     get_definitive_type_info<calculation_failure_status>());register_api_named_type(     api,     "calculation_status",     0,     "",     get_definitive_type_info<calculation_status>());register_api_named_type(     api,     "thinknode_nil_type",     0,     "",     get_definitive_type_info<thinknode_nil_type>());register_api_named_type(     api,     "thinknode_boolean_type",     0,     "",     get_definitive_type_info<thinknode_boolean_type>());register_api_named_type(     api,     "thinknode_integer_type",     0,     "",     get_definitive_type_info<thinknode_integer_type>());register_api_named_type(     api,     "thinknode_float_type",     0,     "",     get_definitive_type_info<thinknode_float_type>());register_api_named_type(     api,     "thinknode_string_type",     0,     "",     get_definitive_type_info<thinknode_string_type>());register_api_named_type(     api,     "thinknode_datetime_type",     0,     "",     get_definitive_type_info<thinknode_datetime_type>());register_api_named_type(     api,     "thinknode_blob_type",     0,     "",     get_definitive_type_info<thinknode_blob_type>());register_api_named_type(     api,     "thinknode_dynamic_type",     0,     "",     get_definitive_type_info<thinknode_dynamic_type>());register_api_named_type(     api,     "thinknode_structure_field_info",     0,     "",     get_definitive_type_info<thinknode_structure_field_info>());register_api_named_type(     api,     "thinknode_structure_info",     0,     "",     get_definitive_type_info<thinknode_structure_info>());register_api_named_type(     api,     "thinknode_union_member_info",     0,     "",     get_definitive_type_info<thinknode_union_member_info>());register_api_named_type(     api,     "thinknode_union_info",     0,     "",     get_definitive_type_info<thinknode_union_info>());register_api_named_type(     api,     "thinknode_enum_value_info",     0,     "",     get_definitive_type_info<thinknode_enum_value_info>());register_api_named_type(     api,     "thinknode_enum_info",     0,     "",     get_definitive_type_info<thinknode_enum_info>());register_api_named_type(     api,     "thinknode_array_info",     0,     "",     get_definitive_type_info<thinknode_array_info>());register_api_named_type(     api,     "thinknode_map_info",     0,     "",     get_definitive_type_info<thinknode_map_info>());register_api_named_type(     api,     "thinknode_named_type_reference",     0,     "",     get_definitive_type_info<thinknode_named_type_reference>());register_api_named_type(     api,     "thinknode_function_parameter_info",     0,     "",     get_definitive_type_info<thinknode_function_parameter_info>());register_api_named_type(     api,     "thinknode_function_result_info",     0,     "",     get_definitive_type_info<thinknode_function_result_info>());register_api_named_type(     api,     "thinknode_function_type_info",     0,     "",     get_definitive_type_info<thinknode_function_type_info>());register_api_named_type(     api,     "thinknode_function_type",     0,     "",     get_definitive_type_info<thinknode_function_type>());register_api_named_type(     api,     "thinknode_function_info",     0,     "",     get_definitive_type_info<thinknode_function_info>());register_api_named_type(     api,     "thinknode_named_type_info",     0,     "",     get_definitive_type_info<thinknode_named_type_info>());register_api_named_type(     api,     "thinknode_provider_image_info",     0,     "",     get_definitive_type_info<thinknode_provider_image_info>());register_api_named_type(     api,     "thinknode_private_provider_info",     0,     "",     get_definitive_type_info<thinknode_private_provider_info>());register_api_named_type(     api,     "thinknode_provider_info",     0,     "",     get_definitive_type_info<thinknode_provider_info>());register_api_named_type(     api,     "thinknode_app_manifest",     0,     "",     get_definitive_type_info<thinknode_app_manifest>());register_api_named_type(     api,     "thinknode_app_version_info",     0,     "",     get_definitive_type_info<thinknode_app_version_info>());register_api_named_type(     api,     "thinknode_app_source_info",     0,     "",     get_definitive_type_info<thinknode_app_source_info>());register_api_named_type(     api,     "thinknode_context_app_info",     0,     "",     get_definitive_type_info<thinknode_context_app_info>());register_api_named_type(     api,     "thinknode_context_contents",     0,     "",     get_definitive_type_info<thinknode_context_contents>());register_api_named_type(     api,     "thinknode_supervisor_calculation_request",     0,     "",     get_definitive_type_info<thinknode_supervisor_calculation_request>());register_api_named_type(     api,     "thinknode_supervisor_message",     0,     "",     get_definitive_type_info<thinknode_supervisor_message>());register_api_named_type(     api,     "thinknode_provider_progress_update",     0,     "",     get_definitive_type_info<thinknode_provider_progress_update>());register_api_named_type(     api,     "thinknode_provider_failure",     0,     "",     get_definitive_type_info<thinknode_provider_failure>());register_api_named_type(     api,     "thinknode_provider_registration",     0,     "",     get_definitive_type_info<thinknode_provider_registration>());register_api_named_type(     api,     "thinknode_provider_message",     0,     "",     get_definitive_type_info<thinknode_provider_message>());
}

}
