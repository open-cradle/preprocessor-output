// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#include <algorithm>
#include <typeinfo>
#include "diff.hpp"
#include <cradle/typing/core/preprocessed.h>
#include <boost/algorithm/string/case_conv.hpp>

namespace cradle {

#line 8 "/home/runner/work/cradle/cradle/src/cradle/typing/utilities/diff.hpp"
void definitive_type_info_query<value_diff_op>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<value_diff_op>()); } void type_info_query<value_diff_op>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "value_diff_op")); } void enum_type_info_query<value_diff_op>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["insert"] =  cradle::api_enum_value_info( "insert a field into a record or an item into a list");values["update"] =  cradle::api_enum_value_info( "update an existing record field or list item");values["delete"] =  cradle::api_enum_value_info( "delete a record field or list item");     *info = cradle::api_enum_info(values); } char const* get_value_id(value_diff_op value) {     switch (value)     { case value_diff_op::INSERT: return "insert";case value_diff_op::UPDATE: return "update";case value_diff_op::DELETE: return "delete";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("value_diff_op") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     value_diff_op x) {     *v = get_value_id(x); } void from_dynamic(     value_diff_op* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "insert")     {         *x = value_diff_op::INSERT;         return;     };    if (boost::to_lower_copy(s) == "update")     {         *x = value_diff_op::UPDATE;         return;     };    if (boost::to_lower_copy(s) == "delete")     {         *x = value_diff_op::DELETE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("value_diff_op") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, value_diff_op const& x) {     s << get_value_id(x);     return s; } 

#line 28 "/home/runner/work/cradle/cradle/src/cradle/typing/utilities/diff.hpp"
} namespace cradle { void definitive_type_info_query<value_diff_item>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<value_diff_item>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<value_diff_item>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "value_diff_item")); } void structure_field_type_info_adder<value_diff_item>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["path"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<value_diff_item>().path)>(),             none);    (*fields)["op"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<value_diff_item>().op)>(),             none);    (*fields)["a"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<value_diff_item>().a)>(),             none);    (*fields)["b"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<value_diff_item>().b)>(),             none); } bool operator==(value_diff_item const& a, value_diff_item const& b) { return a.path == b.path && a.op == b.op && a.a == b.a && a.b == b.b; } bool operator!=(value_diff_item const& a, value_diff_item const& b) { return !(a == b); } bool operator<(value_diff_item const& a, value_diff_item const& b) { if (a.path < b.path) return true; if (b.path < a.path) return false; if (a.op < b.op) return true; if (b.op < a.op) return false; if (a.a < b.a) return true; if (b.a < a.a) return false; if (a.b < b.b) return true; if (b.b < a.b) return false;     return false; } void swap(value_diff_item& a, value_diff_item& b) {     using std::swap;     swap(a.path, b.path);     swap(a.op, b.op);     swap(a.a, b.a);     swap(a.b, b.b); } size_t deep_sizeof(value_diff_item const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.path) + deep_sizeof(x.op) + deep_sizeof(x.a) + deep_sizeof(x.b) ; } void write_fields_to_record(cradle::dynamic_map& record, value_diff_item const& x) { using cradle::write_field_to_record; write_field_to_record(record, "path", x.path); write_field_to_record(record, "op", x.op); write_field_to_record(record, "a", x.a); write_field_to_record(record, "b", x.b); } void to_dynamic(cradle::dynamic* v, value_diff_item const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(value_diff_item& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.path, record, "path"); read_field_from_record(&x.op, record, "op"); read_field_from_record(&x.a, record, "a"); read_field_from_record(&x.b, record, "b"); } void from_dynamic(value_diff_item* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, value_diff_item const& x) { return s << to_dynamic(x); } size_t hash_value(value_diff_item const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.path)); boost::hash_combine(h, cradle::invoke_hash(x.op)); boost::hash_combine(h, cradle::invoke_hash(x.a)); boost::hash_combine(h, cradle::invoke_hash(x.b));  return h; }} namespace cradle { 

}

namespace cradle {
void add_src_cradle_typing_utilities_diff_api(cradle::api_implementation& api)
{

}

}
