// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#include <algorithm>
#include <typeinfo>
#include "upgrades.hpp"
#include <cradle/typing/core/preprocessed.h>
#include <boost/algorithm/string/case_conv.hpp>

namespace cradle {

#line 8 "C:/dev/open-cradle/cradle/src/cradle/typing/core/upgrades.hpp"
void definitive_type_info_query<upgrade_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<upgrade_type>()); } void type_info_query<upgrade_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "upgrade_type")); } void enum_type_info_query<upgrade_type>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["none"] =  cradle::api_enum_value_info( "no upgrade");values["function"] =  cradle::api_enum_value_info( "an upgrade via a custom function");     *info = cradle::api_enum_info(values); } char const* get_value_id(upgrade_type value) {     switch (value)     { case upgrade_type::NONE: return "none";case upgrade_type::FUNCTION: return "function";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("upgrade_type") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     upgrade_type x) {     *v = get_value_id(x); } void from_dynamic(     upgrade_type* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "none")     {         *x = upgrade_type::NONE;         return;     };    if (boost::to_lower_copy(s) == "function")     {         *x = upgrade_type::FUNCTION;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("upgrade_type") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, upgrade_type const& x) {     s << get_value_id(x);     return s; } 

}

namespace cradle {
void add_src_cradle_typing_core_upgrades_api(cradle::api_implementation& api)
{
register_api_named_type(     api,     "upgrade_type",     0,     "Denotes the different kind of upgrades that are available.",     get_definitive_type_info<upgrade_type>());
}

}
