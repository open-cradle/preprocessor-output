// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#include <algorithm>
#include <typeinfo>
#include "api_types.hpp"
#include <cradle/typing/core/preprocessed.h>
#include <boost/algorithm/string/case_conv.hpp>

namespace cradle {

#line 29 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
void definitive_type_info_query<api_type_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<api_type_info_tag>()); } void type_info_query<api_type_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_type_info_tag")); } void enum_type_info_query<api_type_info_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["nil_type"] =  cradle::api_enum_value_info( "");values["boolean_type"] =  cradle::api_enum_value_info( "");values["integer_type"] =  cradle::api_enum_value_info( "");values["float_type"] =  cradle::api_enum_value_info( "");values["string_type"] =  cradle::api_enum_value_info( "");values["datetime_type"] =  cradle::api_enum_value_info( "");values["blob_type"] =  cradle::api_enum_value_info( "");values["dynamic_type"] =  cradle::api_enum_value_info( "");values["structure_type"] =  cradle::api_enum_value_info( "");values["union_type"] =  cradle::api_enum_value_info( "");values["enum_type"] =  cradle::api_enum_value_info( "");values["map_type"] =  cradle::api_enum_value_info( "");values["array_type"] =  cradle::api_enum_value_info( "");values["optional_type"] =  cradle::api_enum_value_info( "");values["reference_type"] =  cradle::api_enum_value_info( "");values["named_type"] =  cradle::api_enum_value_info( "");values["function_type"] =  cradle::api_enum_value_info( "");values["record_type"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(api_type_info_tag value) {     switch (value)     { case api_type_info_tag::NIL_TYPE: return "nil_type";case api_type_info_tag::BOOLEAN_TYPE: return "boolean_type";case api_type_info_tag::INTEGER_TYPE: return "integer_type";case api_type_info_tag::FLOAT_TYPE: return "float_type";case api_type_info_tag::STRING_TYPE: return "string_type";case api_type_info_tag::DATETIME_TYPE: return "datetime_type";case api_type_info_tag::BLOB_TYPE: return "blob_type";case api_type_info_tag::DYNAMIC_TYPE: return "dynamic_type";case api_type_info_tag::STRUCTURE_TYPE: return "structure_type";case api_type_info_tag::UNION_TYPE: return "union_type";case api_type_info_tag::ENUM_TYPE: return "enum_type";case api_type_info_tag::MAP_TYPE: return "map_type";case api_type_info_tag::ARRAY_TYPE: return "array_type";case api_type_info_tag::OPTIONAL_TYPE: return "optional_type";case api_type_info_tag::REFERENCE_TYPE: return "reference_type";case api_type_info_tag::NAMED_TYPE: return "named_type";case api_type_info_tag::FUNCTION_TYPE: return "function_type";case api_type_info_tag::RECORD_TYPE: return "record_type";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("api_type_info_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     api_type_info_tag x) {     *v = get_value_id(x); } void from_dynamic(     api_type_info_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "nil_type")     {         *x = api_type_info_tag::NIL_TYPE;         return;     };    if (boost::to_lower_copy(s) == "boolean_type")     {         *x = api_type_info_tag::BOOLEAN_TYPE;         return;     };    if (boost::to_lower_copy(s) == "integer_type")     {         *x = api_type_info_tag::INTEGER_TYPE;         return;     };    if (boost::to_lower_copy(s) == "float_type")     {         *x = api_type_info_tag::FLOAT_TYPE;         return;     };    if (boost::to_lower_copy(s) == "string_type")     {         *x = api_type_info_tag::STRING_TYPE;         return;     };    if (boost::to_lower_copy(s) == "datetime_type")     {         *x = api_type_info_tag::DATETIME_TYPE;         return;     };    if (boost::to_lower_copy(s) == "blob_type")     {         *x = api_type_info_tag::BLOB_TYPE;         return;     };    if (boost::to_lower_copy(s) == "dynamic_type")     {         *x = api_type_info_tag::DYNAMIC_TYPE;         return;     };    if (boost::to_lower_copy(s) == "structure_type")     {         *x = api_type_info_tag::STRUCTURE_TYPE;         return;     };    if (boost::to_lower_copy(s) == "union_type")     {         *x = api_type_info_tag::UNION_TYPE;         return;     };    if (boost::to_lower_copy(s) == "enum_type")     {         *x = api_type_info_tag::ENUM_TYPE;         return;     };    if (boost::to_lower_copy(s) == "map_type")     {         *x = api_type_info_tag::MAP_TYPE;         return;     };    if (boost::to_lower_copy(s) == "array_type")     {         *x = api_type_info_tag::ARRAY_TYPE;         return;     };    if (boost::to_lower_copy(s) == "optional_type")     {         *x = api_type_info_tag::OPTIONAL_TYPE;         return;     };    if (boost::to_lower_copy(s) == "reference_type")     {         *x = api_type_info_tag::REFERENCE_TYPE;         return;     };    if (boost::to_lower_copy(s) == "named_type")     {         *x = api_type_info_tag::NAMED_TYPE;         return;     };    if (boost::to_lower_copy(s) == "function_type")     {         *x = api_type_info_tag::FUNCTION_TYPE;         return;     };    if (boost::to_lower_copy(s) == "record_type")     {         *x = api_type_info_tag::RECORD_TYPE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("api_type_info_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, api_type_info_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<api_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["nil_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_nil_type>());    members["boolean_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_boolean_type>());    members["integer_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_integer_type>());    members["float_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_float_type>());    members["string_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_string_type>());    members["datetime_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_datetime_type>());    members["blob_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_blob_type>());    members["dynamic_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_dynamic_type>());    members["structure_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_structure_info>());    members["union_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_union_info>());    members["enum_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_enum_info>());    members["map_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_map_info>());    members["array_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_array_info>());    members["optional_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_type_info>());    members["reference_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_type_info>());    members["named_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_named_type_reference>());    members["function_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_function_type_info>());    members["record_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_record_info>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<api_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_type_info")); } api_type_info make_api_type_info_with_nil_type(api_nil_type const& x) { api_type_info s; s.type = api_type_info_tag::NIL_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_nil_type(api_nil_type&& x) { api_type_info s; s.type = api_type_info_tag::NIL_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_boolean_type(api_boolean_type const& x) { api_type_info s; s.type = api_type_info_tag::BOOLEAN_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_boolean_type(api_boolean_type&& x) { api_type_info s; s.type = api_type_info_tag::BOOLEAN_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_integer_type(api_integer_type const& x) { api_type_info s; s.type = api_type_info_tag::INTEGER_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_integer_type(api_integer_type&& x) { api_type_info s; s.type = api_type_info_tag::INTEGER_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_float_type(api_float_type const& x) { api_type_info s; s.type = api_type_info_tag::FLOAT_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_float_type(api_float_type&& x) { api_type_info s; s.type = api_type_info_tag::FLOAT_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_string_type(api_string_type const& x) { api_type_info s; s.type = api_type_info_tag::STRING_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_string_type(api_string_type&& x) { api_type_info s; s.type = api_type_info_tag::STRING_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_datetime_type(api_datetime_type const& x) { api_type_info s; s.type = api_type_info_tag::DATETIME_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_datetime_type(api_datetime_type&& x) { api_type_info s; s.type = api_type_info_tag::DATETIME_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_blob_type(api_blob_type const& x) { api_type_info s; s.type = api_type_info_tag::BLOB_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_blob_type(api_blob_type&& x) { api_type_info s; s.type = api_type_info_tag::BLOB_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_dynamic_type(api_dynamic_type const& x) { api_type_info s; s.type = api_type_info_tag::DYNAMIC_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_dynamic_type(api_dynamic_type&& x) { api_type_info s; s.type = api_type_info_tag::DYNAMIC_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_structure_type(api_structure_info const& x) { api_type_info s; s.type = api_type_info_tag::STRUCTURE_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_structure_type(api_structure_info&& x) { api_type_info s; s.type = api_type_info_tag::STRUCTURE_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_union_type(api_union_info const& x) { api_type_info s; s.type = api_type_info_tag::UNION_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_union_type(api_union_info&& x) { api_type_info s; s.type = api_type_info_tag::UNION_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_enum_type(api_enum_info const& x) { api_type_info s; s.type = api_type_info_tag::ENUM_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_enum_type(api_enum_info&& x) { api_type_info s; s.type = api_type_info_tag::ENUM_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_map_type(api_map_info const& x) { api_type_info s; s.type = api_type_info_tag::MAP_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_map_type(api_map_info&& x) { api_type_info s; s.type = api_type_info_tag::MAP_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_array_type(api_array_info const& x) { api_type_info s; s.type = api_type_info_tag::ARRAY_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_array_type(api_array_info&& x) { api_type_info s; s.type = api_type_info_tag::ARRAY_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_optional_type(api_type_info const& x) { api_type_info s; s.type = api_type_info_tag::OPTIONAL_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_optional_type(api_type_info&& x) { api_type_info s; s.type = api_type_info_tag::OPTIONAL_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_reference_type(api_type_info const& x) { api_type_info s; s.type = api_type_info_tag::REFERENCE_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_reference_type(api_type_info&& x) { api_type_info s; s.type = api_type_info_tag::REFERENCE_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_named_type(api_named_type_reference const& x) { api_type_info s; s.type = api_type_info_tag::NAMED_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_named_type(api_named_type_reference&& x) { api_type_info s; s.type = api_type_info_tag::NAMED_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_function_type(api_function_type_info const& x) { api_type_info s; s.type = api_type_info_tag::FUNCTION_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_function_type(api_function_type_info&& x) { api_type_info s; s.type = api_type_info_tag::FUNCTION_TYPE; s.contents_ = std::move(x); return s; } api_type_info make_api_type_info_with_record_type(api_record_info const& x) { api_type_info s; s.type = api_type_info_tag::RECORD_TYPE; s.contents_ = x; return s; } api_type_info make_api_type_info_with_record_type(api_record_info&& x) { api_type_info s; s.type = api_type_info_tag::RECORD_TYPE; s.contents_ = std::move(x); return s; } api_nil_type const& as_nil_type(api_type_info const& x) { assert(x.type == api_type_info_tag::NIL_TYPE); return std::any_cast<api_nil_type const& >(x.contents_); } api_boolean_type const& as_boolean_type(api_type_info const& x) { assert(x.type == api_type_info_tag::BOOLEAN_TYPE); return std::any_cast<api_boolean_type const& >(x.contents_); } api_integer_type const& as_integer_type(api_type_info const& x) { assert(x.type == api_type_info_tag::INTEGER_TYPE); return std::any_cast<api_integer_type const& >(x.contents_); } api_float_type const& as_float_type(api_type_info const& x) { assert(x.type == api_type_info_tag::FLOAT_TYPE); return std::any_cast<api_float_type const& >(x.contents_); } api_string_type const& as_string_type(api_type_info const& x) { assert(x.type == api_type_info_tag::STRING_TYPE); return std::any_cast<api_string_type const& >(x.contents_); } api_datetime_type const& as_datetime_type(api_type_info const& x) { assert(x.type == api_type_info_tag::DATETIME_TYPE); return std::any_cast<api_datetime_type const& >(x.contents_); } api_blob_type const& as_blob_type(api_type_info const& x) { assert(x.type == api_type_info_tag::BLOB_TYPE); return std::any_cast<api_blob_type const& >(x.contents_); } api_dynamic_type const& as_dynamic_type(api_type_info const& x) { assert(x.type == api_type_info_tag::DYNAMIC_TYPE); return std::any_cast<api_dynamic_type const& >(x.contents_); } api_structure_info const& as_structure_type(api_type_info const& x) { assert(x.type == api_type_info_tag::STRUCTURE_TYPE); return std::any_cast<api_structure_info const& >(x.contents_); } api_union_info const& as_union_type(api_type_info const& x) { assert(x.type == api_type_info_tag::UNION_TYPE); return std::any_cast<api_union_info const& >(x.contents_); } api_enum_info const& as_enum_type(api_type_info const& x) { assert(x.type == api_type_info_tag::ENUM_TYPE); return std::any_cast<api_enum_info const& >(x.contents_); } api_map_info const& as_map_type(api_type_info const& x) { assert(x.type == api_type_info_tag::MAP_TYPE); return std::any_cast<api_map_info const& >(x.contents_); } api_array_info const& as_array_type(api_type_info const& x) { assert(x.type == api_type_info_tag::ARRAY_TYPE); return std::any_cast<api_array_info const& >(x.contents_); } api_type_info const& as_optional_type(api_type_info const& x) { assert(x.type == api_type_info_tag::OPTIONAL_TYPE); return std::any_cast<api_type_info const& >(x.contents_); } api_type_info const& as_reference_type(api_type_info const& x) { assert(x.type == api_type_info_tag::REFERENCE_TYPE); return std::any_cast<api_type_info const& >(x.contents_); } api_named_type_reference const& as_named_type(api_type_info const& x) { assert(x.type == api_type_info_tag::NAMED_TYPE); return std::any_cast<api_named_type_reference const& >(x.contents_); } api_function_type_info const& as_function_type(api_type_info const& x) { assert(x.type == api_type_info_tag::FUNCTION_TYPE); return std::any_cast<api_function_type_info const& >(x.contents_); } api_record_info const& as_record_type(api_type_info const& x) { assert(x.type == api_type_info_tag::RECORD_TYPE); return std::any_cast<api_record_info const& >(x.contents_); } api_nil_type& as_nil_type(api_type_info& x) { assert(x.type == api_type_info_tag::NIL_TYPE); return std::any_cast<api_nil_type&>(x.contents_); } api_boolean_type& as_boolean_type(api_type_info& x) { assert(x.type == api_type_info_tag::BOOLEAN_TYPE); return std::any_cast<api_boolean_type&>(x.contents_); } api_integer_type& as_integer_type(api_type_info& x) { assert(x.type == api_type_info_tag::INTEGER_TYPE); return std::any_cast<api_integer_type&>(x.contents_); } api_float_type& as_float_type(api_type_info& x) { assert(x.type == api_type_info_tag::FLOAT_TYPE); return std::any_cast<api_float_type&>(x.contents_); } api_string_type& as_string_type(api_type_info& x) { assert(x.type == api_type_info_tag::STRING_TYPE); return std::any_cast<api_string_type&>(x.contents_); } api_datetime_type& as_datetime_type(api_type_info& x) { assert(x.type == api_type_info_tag::DATETIME_TYPE); return std::any_cast<api_datetime_type&>(x.contents_); } api_blob_type& as_blob_type(api_type_info& x) { assert(x.type == api_type_info_tag::BLOB_TYPE); return std::any_cast<api_blob_type&>(x.contents_); } api_dynamic_type& as_dynamic_type(api_type_info& x) { assert(x.type == api_type_info_tag::DYNAMIC_TYPE); return std::any_cast<api_dynamic_type&>(x.contents_); } api_structure_info& as_structure_type(api_type_info& x) { assert(x.type == api_type_info_tag::STRUCTURE_TYPE); return std::any_cast<api_structure_info&>(x.contents_); } api_union_info& as_union_type(api_type_info& x) { assert(x.type == api_type_info_tag::UNION_TYPE); return std::any_cast<api_union_info&>(x.contents_); } api_enum_info& as_enum_type(api_type_info& x) { assert(x.type == api_type_info_tag::ENUM_TYPE); return std::any_cast<api_enum_info&>(x.contents_); } api_map_info& as_map_type(api_type_info& x) { assert(x.type == api_type_info_tag::MAP_TYPE); return std::any_cast<api_map_info&>(x.contents_); } api_array_info& as_array_type(api_type_info& x) { assert(x.type == api_type_info_tag::ARRAY_TYPE); return std::any_cast<api_array_info&>(x.contents_); } api_type_info& as_optional_type(api_type_info& x) { assert(x.type == api_type_info_tag::OPTIONAL_TYPE); return std::any_cast<api_type_info&>(x.contents_); } api_type_info& as_reference_type(api_type_info& x) { assert(x.type == api_type_info_tag::REFERENCE_TYPE); return std::any_cast<api_type_info&>(x.contents_); } api_named_type_reference& as_named_type(api_type_info& x) { assert(x.type == api_type_info_tag::NAMED_TYPE); return std::any_cast<api_named_type_reference&>(x.contents_); } api_function_type_info& as_function_type(api_type_info& x) { assert(x.type == api_type_info_tag::FUNCTION_TYPE); return std::any_cast<api_function_type_info&>(x.contents_); } api_record_info& as_record_type(api_type_info& x) { assert(x.type == api_type_info_tag::RECORD_TYPE); return std::any_cast<api_record_info&>(x.contents_); } void set_to_nil_type(api_type_info& x, api_nil_type const& y) { x.type = api_type_info_tag::NIL_TYPE; x.contents_ = y; } void set_to_nil_type(api_type_info& x, api_nil_type&& y) { x.type = api_type_info_tag::NIL_TYPE; x.contents_ = std::move(y); } void set_to_boolean_type(api_type_info& x, api_boolean_type const& y) { x.type = api_type_info_tag::BOOLEAN_TYPE; x.contents_ = y; } void set_to_boolean_type(api_type_info& x, api_boolean_type&& y) { x.type = api_type_info_tag::BOOLEAN_TYPE; x.contents_ = std::move(y); } void set_to_integer_type(api_type_info& x, api_integer_type const& y) { x.type = api_type_info_tag::INTEGER_TYPE; x.contents_ = y; } void set_to_integer_type(api_type_info& x, api_integer_type&& y) { x.type = api_type_info_tag::INTEGER_TYPE; x.contents_ = std::move(y); } void set_to_float_type(api_type_info& x, api_float_type const& y) { x.type = api_type_info_tag::FLOAT_TYPE; x.contents_ = y; } void set_to_float_type(api_type_info& x, api_float_type&& y) { x.type = api_type_info_tag::FLOAT_TYPE; x.contents_ = std::move(y); } void set_to_string_type(api_type_info& x, api_string_type const& y) { x.type = api_type_info_tag::STRING_TYPE; x.contents_ = y; } void set_to_string_type(api_type_info& x, api_string_type&& y) { x.type = api_type_info_tag::STRING_TYPE; x.contents_ = std::move(y); } void set_to_datetime_type(api_type_info& x, api_datetime_type const& y) { x.type = api_type_info_tag::DATETIME_TYPE; x.contents_ = y; } void set_to_datetime_type(api_type_info& x, api_datetime_type&& y) { x.type = api_type_info_tag::DATETIME_TYPE; x.contents_ = std::move(y); } void set_to_blob_type(api_type_info& x, api_blob_type const& y) { x.type = api_type_info_tag::BLOB_TYPE; x.contents_ = y; } void set_to_blob_type(api_type_info& x, api_blob_type&& y) { x.type = api_type_info_tag::BLOB_TYPE; x.contents_ = std::move(y); } void set_to_dynamic_type(api_type_info& x, api_dynamic_type const& y) { x.type = api_type_info_tag::DYNAMIC_TYPE; x.contents_ = y; } void set_to_dynamic_type(api_type_info& x, api_dynamic_type&& y) { x.type = api_type_info_tag::DYNAMIC_TYPE; x.contents_ = std::move(y); } void set_to_structure_type(api_type_info& x, api_structure_info const& y) { x.type = api_type_info_tag::STRUCTURE_TYPE; x.contents_ = y; } void set_to_structure_type(api_type_info& x, api_structure_info&& y) { x.type = api_type_info_tag::STRUCTURE_TYPE; x.contents_ = std::move(y); } void set_to_union_type(api_type_info& x, api_union_info const& y) { x.type = api_type_info_tag::UNION_TYPE; x.contents_ = y; } void set_to_union_type(api_type_info& x, api_union_info&& y) { x.type = api_type_info_tag::UNION_TYPE; x.contents_ = std::move(y); } void set_to_enum_type(api_type_info& x, api_enum_info const& y) { x.type = api_type_info_tag::ENUM_TYPE; x.contents_ = y; } void set_to_enum_type(api_type_info& x, api_enum_info&& y) { x.type = api_type_info_tag::ENUM_TYPE; x.contents_ = std::move(y); } void set_to_map_type(api_type_info& x, api_map_info const& y) { x.type = api_type_info_tag::MAP_TYPE; x.contents_ = y; } void set_to_map_type(api_type_info& x, api_map_info&& y) { x.type = api_type_info_tag::MAP_TYPE; x.contents_ = std::move(y); } void set_to_array_type(api_type_info& x, api_array_info const& y) { x.type = api_type_info_tag::ARRAY_TYPE; x.contents_ = y; } void set_to_array_type(api_type_info& x, api_array_info&& y) { x.type = api_type_info_tag::ARRAY_TYPE; x.contents_ = std::move(y); } void set_to_optional_type(api_type_info& x, api_type_info const& y) { x.type = api_type_info_tag::OPTIONAL_TYPE; x.contents_ = y; } void set_to_optional_type(api_type_info& x, api_type_info&& y) { x.type = api_type_info_tag::OPTIONAL_TYPE; x.contents_ = std::move(y); } void set_to_reference_type(api_type_info& x, api_type_info const& y) { x.type = api_type_info_tag::REFERENCE_TYPE; x.contents_ = y; } void set_to_reference_type(api_type_info& x, api_type_info&& y) { x.type = api_type_info_tag::REFERENCE_TYPE; x.contents_ = std::move(y); } void set_to_named_type(api_type_info& x, api_named_type_reference const& y) { x.type = api_type_info_tag::NAMED_TYPE; x.contents_ = y; } void set_to_named_type(api_type_info& x, api_named_type_reference&& y) { x.type = api_type_info_tag::NAMED_TYPE; x.contents_ = std::move(y); } void set_to_function_type(api_type_info& x, api_function_type_info const& y) { x.type = api_type_info_tag::FUNCTION_TYPE; x.contents_ = y; } void set_to_function_type(api_type_info& x, api_function_type_info&& y) { x.type = api_type_info_tag::FUNCTION_TYPE; x.contents_ = std::move(y); } void set_to_record_type(api_type_info& x, api_record_info const& y) { x.type = api_type_info_tag::RECORD_TYPE; x.contents_ = y; } void set_to_record_type(api_type_info& x, api_record_info&& y) { x.type = api_type_info_tag::RECORD_TYPE; x.contents_ = std::move(y); } bool operator==(api_type_info const& a, api_type_info const& b) { if (a.type != b.type) return false; switch (a.type) { case api_type_info_tag::NIL_TYPE: return as_nil_type(a) == as_nil_type(b); case api_type_info_tag::BOOLEAN_TYPE: return as_boolean_type(a) == as_boolean_type(b); case api_type_info_tag::INTEGER_TYPE: return as_integer_type(a) == as_integer_type(b); case api_type_info_tag::FLOAT_TYPE: return as_float_type(a) == as_float_type(b); case api_type_info_tag::STRING_TYPE: return as_string_type(a) == as_string_type(b); case api_type_info_tag::DATETIME_TYPE: return as_datetime_type(a) == as_datetime_type(b); case api_type_info_tag::BLOB_TYPE: return as_blob_type(a) == as_blob_type(b); case api_type_info_tag::DYNAMIC_TYPE: return as_dynamic_type(a) == as_dynamic_type(b); case api_type_info_tag::STRUCTURE_TYPE: return as_structure_type(a) == as_structure_type(b); case api_type_info_tag::UNION_TYPE: return as_union_type(a) == as_union_type(b); case api_type_info_tag::ENUM_TYPE: return as_enum_type(a) == as_enum_type(b); case api_type_info_tag::MAP_TYPE: return as_map_type(a) == as_map_type(b); case api_type_info_tag::ARRAY_TYPE: return as_array_type(a) == as_array_type(b); case api_type_info_tag::OPTIONAL_TYPE: return as_optional_type(a) == as_optional_type(b); case api_type_info_tag::REFERENCE_TYPE: return as_reference_type(a) == as_reference_type(b); case api_type_info_tag::NAMED_TYPE: return as_named_type(a) == as_named_type(b); case api_type_info_tag::FUNCTION_TYPE: return as_function_type(a) == as_function_type(b); case api_type_info_tag::RECORD_TYPE: return as_record_type(a) == as_record_type(b); } return true; } bool operator!=(api_type_info const& a, api_type_info const& b) { return !(a == b); } bool operator<(api_type_info const& a, api_type_info const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case api_type_info_tag::NIL_TYPE: return as_nil_type(a) < as_nil_type(b); case api_type_info_tag::BOOLEAN_TYPE: return as_boolean_type(a) < as_boolean_type(b); case api_type_info_tag::INTEGER_TYPE: return as_integer_type(a) < as_integer_type(b); case api_type_info_tag::FLOAT_TYPE: return as_float_type(a) < as_float_type(b); case api_type_info_tag::STRING_TYPE: return as_string_type(a) < as_string_type(b); case api_type_info_tag::DATETIME_TYPE: return as_datetime_type(a) < as_datetime_type(b); case api_type_info_tag::BLOB_TYPE: return as_blob_type(a) < as_blob_type(b); case api_type_info_tag::DYNAMIC_TYPE: return as_dynamic_type(a) < as_dynamic_type(b); case api_type_info_tag::STRUCTURE_TYPE: return as_structure_type(a) < as_structure_type(b); case api_type_info_tag::UNION_TYPE: return as_union_type(a) < as_union_type(b); case api_type_info_tag::ENUM_TYPE: return as_enum_type(a) < as_enum_type(b); case api_type_info_tag::MAP_TYPE: return as_map_type(a) < as_map_type(b); case api_type_info_tag::ARRAY_TYPE: return as_array_type(a) < as_array_type(b); case api_type_info_tag::OPTIONAL_TYPE: return as_optional_type(a) < as_optional_type(b); case api_type_info_tag::REFERENCE_TYPE: return as_reference_type(a) < as_reference_type(b); case api_type_info_tag::NAMED_TYPE: return as_named_type(a) < as_named_type(b); case api_type_info_tag::FUNCTION_TYPE: return as_function_type(a) < as_function_type(b); case api_type_info_tag::RECORD_TYPE: return as_record_type(a) < as_record_type(b); } return false; } size_t hash_value(api_type_info const& x) {     switch (x.type)     { case api_type_info_tag::NIL_TYPE: return cradle::invoke_hash(as_nil_type(x)); case api_type_info_tag::BOOLEAN_TYPE: return cradle::invoke_hash(as_boolean_type(x)); case api_type_info_tag::INTEGER_TYPE: return cradle::invoke_hash(as_integer_type(x)); case api_type_info_tag::FLOAT_TYPE: return cradle::invoke_hash(as_float_type(x)); case api_type_info_tag::STRING_TYPE: return cradle::invoke_hash(as_string_type(x)); case api_type_info_tag::DATETIME_TYPE: return cradle::invoke_hash(as_datetime_type(x)); case api_type_info_tag::BLOB_TYPE: return cradle::invoke_hash(as_blob_type(x)); case api_type_info_tag::DYNAMIC_TYPE: return cradle::invoke_hash(as_dynamic_type(x)); case api_type_info_tag::STRUCTURE_TYPE: return cradle::invoke_hash(as_structure_type(x)); case api_type_info_tag::UNION_TYPE: return cradle::invoke_hash(as_union_type(x)); case api_type_info_tag::ENUM_TYPE: return cradle::invoke_hash(as_enum_type(x)); case api_type_info_tag::MAP_TYPE: return cradle::invoke_hash(as_map_type(x)); case api_type_info_tag::ARRAY_TYPE: return cradle::invoke_hash(as_array_type(x)); case api_type_info_tag::OPTIONAL_TYPE: return cradle::invoke_hash(as_optional_type(x)); case api_type_info_tag::REFERENCE_TYPE: return cradle::invoke_hash(as_reference_type(x)); case api_type_info_tag::NAMED_TYPE: return cradle::invoke_hash(as_named_type(x)); case api_type_info_tag::FUNCTION_TYPE: return cradle::invoke_hash(as_function_type(x)); case api_type_info_tag::RECORD_TYPE: return cradle::invoke_hash(as_record_type(x));      } assert(0); return 0; }void swap(api_type_info& a, api_type_info& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, api_type_info const& x) { cradle::dynamic_map s; switch (x.type) { case api_type_info_tag::NIL_TYPE: to_dynamic(&s[dynamic("nil_type")], as_nil_type(x)); break; case api_type_info_tag::BOOLEAN_TYPE: to_dynamic(&s[dynamic("boolean_type")], as_boolean_type(x)); break; case api_type_info_tag::INTEGER_TYPE: to_dynamic(&s[dynamic("integer_type")], as_integer_type(x)); break; case api_type_info_tag::FLOAT_TYPE: to_dynamic(&s[dynamic("float_type")], as_float_type(x)); break; case api_type_info_tag::STRING_TYPE: to_dynamic(&s[dynamic("string_type")], as_string_type(x)); break; case api_type_info_tag::DATETIME_TYPE: to_dynamic(&s[dynamic("datetime_type")], as_datetime_type(x)); break; case api_type_info_tag::BLOB_TYPE: to_dynamic(&s[dynamic("blob_type")], as_blob_type(x)); break; case api_type_info_tag::DYNAMIC_TYPE: to_dynamic(&s[dynamic("dynamic_type")], as_dynamic_type(x)); break; case api_type_info_tag::STRUCTURE_TYPE: to_dynamic(&s[dynamic("structure_type")], as_structure_type(x)); break; case api_type_info_tag::UNION_TYPE: to_dynamic(&s[dynamic("union_type")], as_union_type(x)); break; case api_type_info_tag::ENUM_TYPE: to_dynamic(&s[dynamic("enum_type")], as_enum_type(x)); break; case api_type_info_tag::MAP_TYPE: to_dynamic(&s[dynamic("map_type")], as_map_type(x)); break; case api_type_info_tag::ARRAY_TYPE: to_dynamic(&s[dynamic("array_type")], as_array_type(x)); break; case api_type_info_tag::OPTIONAL_TYPE: to_dynamic(&s[dynamic("optional_type")], as_optional_type(x)); break; case api_type_info_tag::REFERENCE_TYPE: to_dynamic(&s[dynamic("reference_type")], as_reference_type(x)); break; case api_type_info_tag::NAMED_TYPE: to_dynamic(&s[dynamic("named_type")], as_named_type(x)); break; case api_type_info_tag::FUNCTION_TYPE: to_dynamic(&s[dynamic("function_type")], as_function_type(x)); break; case api_type_info_tag::RECORD_TYPE: to_dynamic(&s[dynamic("record_type")], as_record_type(x)); break; } *v = std::move(s); } void from_dynamic(api_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case api_type_info_tag::NIL_TYPE:  { api_nil_type tmp; from_dynamic(&tmp, get_field(s, "nil_type")); x->contents_ = tmp; break;  } case api_type_info_tag::BOOLEAN_TYPE:  { api_boolean_type tmp; from_dynamic(&tmp, get_field(s, "boolean_type")); x->contents_ = tmp; break;  } case api_type_info_tag::INTEGER_TYPE:  { api_integer_type tmp; from_dynamic(&tmp, get_field(s, "integer_type")); x->contents_ = tmp; break;  } case api_type_info_tag::FLOAT_TYPE:  { api_float_type tmp; from_dynamic(&tmp, get_field(s, "float_type")); x->contents_ = tmp; break;  } case api_type_info_tag::STRING_TYPE:  { api_string_type tmp; from_dynamic(&tmp, get_field(s, "string_type")); x->contents_ = tmp; break;  } case api_type_info_tag::DATETIME_TYPE:  { api_datetime_type tmp; from_dynamic(&tmp, get_field(s, "datetime_type")); x->contents_ = tmp; break;  } case api_type_info_tag::BLOB_TYPE:  { api_blob_type tmp; from_dynamic(&tmp, get_field(s, "blob_type")); x->contents_ = tmp; break;  } case api_type_info_tag::DYNAMIC_TYPE:  { api_dynamic_type tmp; from_dynamic(&tmp, get_field(s, "dynamic_type")); x->contents_ = tmp; break;  } case api_type_info_tag::STRUCTURE_TYPE:  { api_structure_info tmp; from_dynamic(&tmp, get_field(s, "structure_type")); x->contents_ = tmp; break;  } case api_type_info_tag::UNION_TYPE:  { api_union_info tmp; from_dynamic(&tmp, get_field(s, "union_type")); x->contents_ = tmp; break;  } case api_type_info_tag::ENUM_TYPE:  { api_enum_info tmp; from_dynamic(&tmp, get_field(s, "enum_type")); x->contents_ = tmp; break;  } case api_type_info_tag::MAP_TYPE:  { api_map_info tmp; from_dynamic(&tmp, get_field(s, "map_type")); x->contents_ = tmp; break;  } case api_type_info_tag::ARRAY_TYPE:  { api_array_info tmp; from_dynamic(&tmp, get_field(s, "array_type")); x->contents_ = tmp; break;  } case api_type_info_tag::OPTIONAL_TYPE:  { api_type_info tmp; from_dynamic(&tmp, get_field(s, "optional_type")); x->contents_ = tmp; break;  } case api_type_info_tag::REFERENCE_TYPE:  { api_type_info tmp; from_dynamic(&tmp, get_field(s, "reference_type")); x->contents_ = tmp; break;  } case api_type_info_tag::NAMED_TYPE:  { api_named_type_reference tmp; from_dynamic(&tmp, get_field(s, "named_type")); x->contents_ = tmp; break;  } case api_type_info_tag::FUNCTION_TYPE:  { api_function_type_info tmp; from_dynamic(&tmp, get_field(s, "function_type")); x->contents_ = tmp; break;  } case api_type_info_tag::RECORD_TYPE:  { api_record_info tmp; from_dynamic(&tmp, get_field(s, "record_type")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, api_type_info const& x) { return s << to_dynamic(x); } size_t deep_sizeof(api_type_info const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case api_type_info_tag::NIL_TYPE: size += deep_sizeof(as_nil_type(x)); break; case api_type_info_tag::BOOLEAN_TYPE: size += deep_sizeof(as_boolean_type(x)); break; case api_type_info_tag::INTEGER_TYPE: size += deep_sizeof(as_integer_type(x)); break; case api_type_info_tag::FLOAT_TYPE: size += deep_sizeof(as_float_type(x)); break; case api_type_info_tag::STRING_TYPE: size += deep_sizeof(as_string_type(x)); break; case api_type_info_tag::DATETIME_TYPE: size += deep_sizeof(as_datetime_type(x)); break; case api_type_info_tag::BLOB_TYPE: size += deep_sizeof(as_blob_type(x)); break; case api_type_info_tag::DYNAMIC_TYPE: size += deep_sizeof(as_dynamic_type(x)); break; case api_type_info_tag::STRUCTURE_TYPE: size += deep_sizeof(as_structure_type(x)); break; case api_type_info_tag::UNION_TYPE: size += deep_sizeof(as_union_type(x)); break; case api_type_info_tag::ENUM_TYPE: size += deep_sizeof(as_enum_type(x)); break; case api_type_info_tag::MAP_TYPE: size += deep_sizeof(as_map_type(x)); break; case api_type_info_tag::ARRAY_TYPE: size += deep_sizeof(as_array_type(x)); break; case api_type_info_tag::OPTIONAL_TYPE: size += deep_sizeof(as_optional_type(x)); break; case api_type_info_tag::REFERENCE_TYPE: size += deep_sizeof(as_reference_type(x)); break; case api_type_info_tag::NAMED_TYPE: size += deep_sizeof(as_named_type(x)); break; case api_type_info_tag::FUNCTION_TYPE: size += deep_sizeof(as_function_type(x)); break; case api_type_info_tag::RECORD_TYPE: size += deep_sizeof(as_record_type(x)); break; } return size; } 

#line 52 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_nil_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_nil_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_nil_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_nil_type")); } void structure_field_type_info_adder<api_nil_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_nil_type const& a, api_nil_type const& b) { return true;} bool operator!=(api_nil_type const& a, api_nil_type const& b) { return !(a == b); } bool operator<(api_nil_type const& a, api_nil_type const& b) {     return false; } void swap(api_nil_type& a, api_nil_type& b) {     using std::swap; } size_t deep_sizeof(api_nil_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_nil_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_nil_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_nil_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_nil_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_nil_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_nil_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 57 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_boolean_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_boolean_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_boolean_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_boolean_type")); } void structure_field_type_info_adder<api_boolean_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_boolean_type const& a, api_boolean_type const& b) { return true;} bool operator!=(api_boolean_type const& a, api_boolean_type const& b) { return !(a == b); } bool operator<(api_boolean_type const& a, api_boolean_type const& b) {     return false; } void swap(api_boolean_type& a, api_boolean_type& b) {     using std::swap; } size_t deep_sizeof(api_boolean_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_boolean_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_boolean_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_boolean_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_boolean_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_boolean_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_boolean_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 62 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_integer_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_integer_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_integer_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_integer_type")); } void structure_field_type_info_adder<api_integer_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_integer_type const& a, api_integer_type const& b) { return true;} bool operator!=(api_integer_type const& a, api_integer_type const& b) { return !(a == b); } bool operator<(api_integer_type const& a, api_integer_type const& b) {     return false; } void swap(api_integer_type& a, api_integer_type& b) {     using std::swap; } size_t deep_sizeof(api_integer_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_integer_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_integer_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_integer_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_integer_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_integer_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_integer_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 67 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_float_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_float_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_float_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_float_type")); } void structure_field_type_info_adder<api_float_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_float_type const& a, api_float_type const& b) { return true;} bool operator!=(api_float_type const& a, api_float_type const& b) { return !(a == b); } bool operator<(api_float_type const& a, api_float_type const& b) {     return false; } void swap(api_float_type& a, api_float_type& b) {     using std::swap; } size_t deep_sizeof(api_float_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_float_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_float_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_float_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_float_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_float_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_float_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 72 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_string_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_string_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_string_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_string_type")); } void structure_field_type_info_adder<api_string_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_string_type const& a, api_string_type const& b) { return true;} bool operator!=(api_string_type const& a, api_string_type const& b) { return !(a == b); } bool operator<(api_string_type const& a, api_string_type const& b) {     return false; } void swap(api_string_type& a, api_string_type& b) {     using std::swap; } size_t deep_sizeof(api_string_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_string_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_string_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_string_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_string_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_string_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_string_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 77 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_datetime_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_datetime_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_datetime_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_datetime_type")); } void structure_field_type_info_adder<api_datetime_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_datetime_type const& a, api_datetime_type const& b) { return true;} bool operator!=(api_datetime_type const& a, api_datetime_type const& b) { return !(a == b); } bool operator<(api_datetime_type const& a, api_datetime_type const& b) {     return false; } void swap(api_datetime_type& a, api_datetime_type& b) {     using std::swap; } size_t deep_sizeof(api_datetime_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_datetime_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_datetime_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_datetime_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_datetime_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_datetime_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_datetime_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 82 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_blob_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_blob_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_blob_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_blob_type")); } void structure_field_type_info_adder<api_blob_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_blob_type const& a, api_blob_type const& b) { return true;} bool operator!=(api_blob_type const& a, api_blob_type const& b) { return !(a == b); } bool operator<(api_blob_type const& a, api_blob_type const& b) {     return false; } void swap(api_blob_type& a, api_blob_type& b) {     using std::swap; } size_t deep_sizeof(api_blob_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_blob_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_blob_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_blob_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_blob_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_blob_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_blob_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 87 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_dynamic_type>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_dynamic_type>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_dynamic_type>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_dynamic_type")); } void structure_field_type_info_adder<api_dynamic_type>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {   } bool operator==(api_dynamic_type const& a, api_dynamic_type const& b) { return true;} bool operator!=(api_dynamic_type const& a, api_dynamic_type const& b) { return !(a == b); } bool operator<(api_dynamic_type const& a, api_dynamic_type const& b) {     return false; } void swap(api_dynamic_type& a, api_dynamic_type& b) {     using std::swap; } size_t deep_sizeof(api_dynamic_type const& x) {     using cradle::deep_sizeof;     return 0 ; } void write_fields_to_record(cradle::dynamic_map& record, api_dynamic_type const& x) { using cradle::write_field_to_record; } void to_dynamic(cradle::dynamic* v, api_dynamic_type const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_dynamic_type& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; } void from_dynamic(api_dynamic_type* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_dynamic_type const& x) { return s << to_dynamic(x); } size_t hash_value(api_dynamic_type const& x) { size_t h = 0;  return h; }} namespace cradle { 

#line 92 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_structure_field_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_structure_field_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_structure_field_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_structure_field_info")); } void structure_field_type_info_adder<api_structure_field_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_structure_field_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_structure_field_info>().schema)>(),             none);    (*fields)["omissible"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_structure_field_info>().omissible)>(),             none); } bool operator==(api_structure_field_info const& a, api_structure_field_info const& b) { return a.description == b.description && a.schema == b.schema && a.omissible == b.omissible; } bool operator!=(api_structure_field_info const& a, api_structure_field_info const& b) { return !(a == b); } bool operator<(api_structure_field_info const& a, api_structure_field_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false; if (a.omissible < b.omissible) return true; if (b.omissible < a.omissible) return false;     return false; } void swap(api_structure_field_info& a, api_structure_field_info& b) {     using std::swap;     swap(a.description, b.description);     swap(a.schema, b.schema);     swap(a.omissible, b.omissible); } size_t deep_sizeof(api_structure_field_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) + deep_sizeof(x.schema) + deep_sizeof(x.omissible) ; } void write_fields_to_record(cradle::dynamic_map& record, api_structure_field_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); write_field_to_record(record, "omissible", x.omissible); } void to_dynamic(cradle::dynamic* v, api_structure_field_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_structure_field_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); read_field_from_record(&x.omissible, record, "omissible"); } void from_dynamic(api_structure_field_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_structure_field_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_structure_field_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema)); boost::hash_combine(h, cradle::invoke_hash(x.omissible));  return h; }} namespace cradle { 

#line 100 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_structure_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_structure_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_structure_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_structure_info")); } void structure_field_type_info_adder<api_structure_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["fields"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_structure_info>().fields)>(),             none); } bool operator==(api_structure_info const& a, api_structure_info const& b) { return a.fields == b.fields; } bool operator!=(api_structure_info const& a, api_structure_info const& b) { return !(a == b); } bool operator<(api_structure_info const& a, api_structure_info const& b) { if (a.fields < b.fields) return true; if (b.fields < a.fields) return false;     return false; } void swap(api_structure_info& a, api_structure_info& b) {     using std::swap;     swap(a.fields, b.fields); } size_t deep_sizeof(api_structure_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.fields) ; } void write_fields_to_record(cradle::dynamic_map& record, api_structure_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "fields", x.fields); } void to_dynamic(cradle::dynamic* v, api_structure_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_structure_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.fields, record, "fields"); } void from_dynamic(api_structure_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_structure_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_structure_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.fields));  return h; }} namespace cradle { 

#line 106 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_union_member_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_union_member_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_union_member_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_union_member_info")); } void structure_field_type_info_adder<api_union_member_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_union_member_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_union_member_info>().schema)>(),             none); } bool operator==(api_union_member_info const& a, api_union_member_info const& b) { return a.description == b.description && a.schema == b.schema; } bool operator!=(api_union_member_info const& a, api_union_member_info const& b) { return !(a == b); } bool operator<(api_union_member_info const& a, api_union_member_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_union_member_info& a, api_union_member_info& b) {     using std::swap;     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(api_union_member_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_union_member_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_union_member_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_union_member_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_union_member_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_union_member_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_union_member_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 113 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_union_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_union_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_union_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_union_info")); } void structure_field_type_info_adder<api_union_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["members"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_union_info>().members)>(),             none); } bool operator==(api_union_info const& a, api_union_info const& b) { return a.members == b.members; } bool operator!=(api_union_info const& a, api_union_info const& b) { return !(a == b); } bool operator<(api_union_info const& a, api_union_info const& b) { if (a.members < b.members) return true; if (b.members < a.members) return false;     return false; } void swap(api_union_info& a, api_union_info& b) {     using std::swap;     swap(a.members, b.members); } size_t deep_sizeof(api_union_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.members) ; } void write_fields_to_record(cradle::dynamic_map& record, api_union_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "members", x.members); } void to_dynamic(cradle::dynamic* v, api_union_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_union_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.members, record, "members"); } void from_dynamic(api_union_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_union_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_union_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.members));  return h; }} namespace cradle { 

#line 119 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_enum_value_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_enum_value_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_enum_value_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_enum_value_info")); } void structure_field_type_info_adder<api_enum_value_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_enum_value_info>().description)>(),             none); } bool operator==(api_enum_value_info const& a, api_enum_value_info const& b) { return a.description == b.description; } bool operator!=(api_enum_value_info const& a, api_enum_value_info const& b) { return !(a == b); } bool operator<(api_enum_value_info const& a, api_enum_value_info const& b) { if (a.description < b.description) return true; if (b.description < a.description) return false;     return false; } void swap(api_enum_value_info& a, api_enum_value_info& b) {     using std::swap;     swap(a.description, b.description); } size_t deep_sizeof(api_enum_value_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.description) ; } void write_fields_to_record(cradle::dynamic_map& record, api_enum_value_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "description", x.description); } void to_dynamic(cradle::dynamic* v, api_enum_value_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_enum_value_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.description, record, "description"); } void from_dynamic(api_enum_value_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_enum_value_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_enum_value_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.description));  return h; }} namespace cradle { 

#line 125 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_enum_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_enum_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_enum_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_enum_info")); } void structure_field_type_info_adder<api_enum_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["values"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_enum_info>().values)>(),             none); } bool operator==(api_enum_info const& a, api_enum_info const& b) { return a.values == b.values; } bool operator!=(api_enum_info const& a, api_enum_info const& b) { return !(a == b); } bool operator<(api_enum_info const& a, api_enum_info const& b) { if (a.values < b.values) return true; if (b.values < a.values) return false;     return false; } void swap(api_enum_info& a, api_enum_info& b) {     using std::swap;     swap(a.values, b.values); } size_t deep_sizeof(api_enum_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.values) ; } void write_fields_to_record(cradle::dynamic_map& record, api_enum_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "values", x.values); } void to_dynamic(cradle::dynamic* v, api_enum_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_enum_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.values, record, "values"); } void from_dynamic(api_enum_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_enum_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_enum_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.values));  return h; }} namespace cradle { 

#line 131 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_array_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_array_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_array_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_array_info")); } void structure_field_type_info_adder<api_array_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["size"] =         cradle::api_structure_field_info(             "If size is absent, any size is acceptable.",             cradle::get_type_info<decltype(std::declval<api_array_info>().size)>(),             none);    (*fields)["element_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_array_info>().element_schema)>(),             none); } bool operator==(api_array_info const& a, api_array_info const& b) { return a.size == b.size && a.element_schema == b.element_schema; } bool operator!=(api_array_info const& a, api_array_info const& b) { return !(a == b); } bool operator<(api_array_info const& a, api_array_info const& b) { if (a.size < b.size) return true; if (b.size < a.size) return false; if (a.element_schema < b.element_schema) return true; if (b.element_schema < a.element_schema) return false;     return false; } void swap(api_array_info& a, api_array_info& b) {     using std::swap;     swap(a.size, b.size);     swap(a.element_schema, b.element_schema); } size_t deep_sizeof(api_array_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.size) + deep_sizeof(x.element_schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_array_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "size", x.size); write_field_to_record(record, "element_schema", x.element_schema); } void to_dynamic(cradle::dynamic* v, api_array_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_array_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.size, record, "size"); read_field_from_record(&x.element_schema, record, "element_schema"); } void from_dynamic(api_array_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_array_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_array_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.size)); boost::hash_combine(h, cradle::invoke_hash(x.element_schema));  return h; }} namespace cradle { 

#line 139 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_map_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_map_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_map_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_map_info")); } void structure_field_type_info_adder<api_map_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["key_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_map_info>().key_schema)>(),             none);    (*fields)["value_schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_map_info>().value_schema)>(),             none); } bool operator==(api_map_info const& a, api_map_info const& b) { return a.key_schema == b.key_schema && a.value_schema == b.value_schema; } bool operator!=(api_map_info const& a, api_map_info const& b) { return !(a == b); } bool operator<(api_map_info const& a, api_map_info const& b) { if (a.key_schema < b.key_schema) return true; if (b.key_schema < a.key_schema) return false; if (a.value_schema < b.value_schema) return true; if (b.value_schema < a.value_schema) return false;     return false; } void swap(api_map_info& a, api_map_info& b) {     using std::swap;     swap(a.key_schema, b.key_schema);     swap(a.value_schema, b.value_schema); } size_t deep_sizeof(api_map_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.key_schema) + deep_sizeof(x.value_schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_map_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "key_schema", x.key_schema); write_field_to_record(record, "value_schema", x.value_schema); } void to_dynamic(cradle::dynamic* v, api_map_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_map_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.key_schema, record, "key_schema"); read_field_from_record(&x.value_schema, record, "value_schema"); } void from_dynamic(api_map_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_map_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_map_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.key_schema)); boost::hash_combine(h, cradle::invoke_hash(x.value_schema));  return h; }} namespace cradle { 

#line 145 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_named_type_reference>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_named_type_reference>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_named_type_reference>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_named_type_reference")); } void structure_field_type_info_adder<api_named_type_reference>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["app"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_reference>().app)>(),             none);    (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_reference>().name)>(),             none); } bool operator==(api_named_type_reference const& a, api_named_type_reference const& b) { return a.app == b.app && a.name == b.name; } bool operator!=(api_named_type_reference const& a, api_named_type_reference const& b) { return !(a == b); } bool operator<(api_named_type_reference const& a, api_named_type_reference const& b) { if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.name < b.name) return true; if (b.name < a.name) return false;     return false; } void swap(api_named_type_reference& a, api_named_type_reference& b) {     using std::swap;     swap(a.app, b.app);     swap(a.name, b.name); } size_t deep_sizeof(api_named_type_reference const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.app) + deep_sizeof(x.name) ; } void write_fields_to_record(cradle::dynamic_map& record, api_named_type_reference const& x) { using cradle::write_field_to_record; write_field_to_record(record, "app", x.app); write_field_to_record(record, "name", x.name); } void to_dynamic(cradle::dynamic* v, api_named_type_reference const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_named_type_reference& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.name, record, "name"); } void from_dynamic(api_named_type_reference* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_named_type_reference const& x) { return s << to_dynamic(x); } size_t hash_value(api_named_type_reference const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.name));  return h; }} namespace cradle { 

#line 152 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_record_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_record_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_record_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_record_type_info")); } void structure_field_type_info_adder<api_record_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_record_type_info>().schema)>(),             none); } bool operator==(api_record_type_info const& a, api_record_type_info const& b) { return a.schema == b.schema; } bool operator!=(api_record_type_info const& a, api_record_type_info const& b) { return !(a == b); } bool operator<(api_record_type_info const& a, api_record_type_info const& b) { if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_record_type_info& a, api_record_type_info& b) {     using std::swap;     swap(a.schema, b.schema); } size_t deep_sizeof(api_record_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_record_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_record_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_record_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_record_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_record_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_record_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 158 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_function_parameter_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_function_parameter_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_function_parameter_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_function_parameter_info")); } void structure_field_type_info_adder<api_function_parameter_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_parameter_info>().name)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_parameter_info>().schema)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_parameter_info>().description)>(),             none); } bool operator==(api_function_parameter_info const& a, api_function_parameter_info const& b) { return a.name == b.name && a.schema == b.schema && a.description == b.description; } bool operator!=(api_function_parameter_info const& a, api_function_parameter_info const& b) { return !(a == b); } bool operator<(api_function_parameter_info const& a, api_function_parameter_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false; if (a.description < b.description) return true; if (b.description < a.description) return false;     return false; } void swap(api_function_parameter_info& a, api_function_parameter_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.schema, b.schema);     swap(a.description, b.description); } size_t deep_sizeof(api_function_parameter_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.schema) + deep_sizeof(x.description) ; } void write_fields_to_record(cradle::dynamic_map& record, api_function_parameter_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "schema", x.schema); write_field_to_record(record, "description", x.description); } void to_dynamic(cradle::dynamic* v, api_function_parameter_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_function_parameter_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.schema, record, "schema"); read_field_from_record(&x.description, record, "description"); } void from_dynamic(api_function_parameter_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_function_parameter_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_function_parameter_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.schema)); boost::hash_combine(h, cradle::invoke_hash(x.description));  return h; }} namespace cradle { 

#line 166 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_function_result_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_function_result_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_function_result_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_function_result_info")); } void structure_field_type_info_adder<api_function_result_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_result_info>().schema)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_result_info>().description)>(),             none); } bool operator==(api_function_result_info const& a, api_function_result_info const& b) { return a.schema == b.schema && a.description == b.description; } bool operator!=(api_function_result_info const& a, api_function_result_info const& b) { return !(a == b); } bool operator<(api_function_result_info const& a, api_function_result_info const& b) { if (a.schema < b.schema) return true; if (b.schema < a.schema) return false; if (a.description < b.description) return true; if (b.description < a.description) return false;     return false; } void swap(api_function_result_info& a, api_function_result_info& b) {     using std::swap;     swap(a.schema, b.schema);     swap(a.description, b.description); } size_t deep_sizeof(api_function_result_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.schema) + deep_sizeof(x.description) ; } void write_fields_to_record(cradle::dynamic_map& record, api_function_result_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "schema", x.schema); write_field_to_record(record, "description", x.description); } void to_dynamic(cradle::dynamic* v, api_function_result_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_function_result_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.schema, record, "schema"); read_field_from_record(&x.description, record, "description"); } void from_dynamic(api_function_result_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_function_result_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_function_result_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.schema)); boost::hash_combine(h, cradle::invoke_hash(x.description));  return h; }} namespace cradle { 

#line 173 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_function_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_function_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_function_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_function_type_info")); } void structure_field_type_info_adder<api_function_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["parameters"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_type_info>().parameters)>(),             none);    (*fields)["returns"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_type_info>().returns)>(),             none); } bool operator==(api_function_type_info const& a, api_function_type_info const& b) { return a.parameters == b.parameters && a.returns == b.returns; } bool operator!=(api_function_type_info const& a, api_function_type_info const& b) { return !(a == b); } bool operator<(api_function_type_info const& a, api_function_type_info const& b) { if (a.parameters < b.parameters) return true; if (b.parameters < a.parameters) return false; if (a.returns < b.returns) return true; if (b.returns < a.returns) return false;     return false; } void swap(api_function_type_info& a, api_function_type_info& b) {     using std::swap;     swap(a.parameters, b.parameters);     swap(a.returns, b.returns); } size_t deep_sizeof(api_function_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.parameters) + deep_sizeof(x.returns) ; } void write_fields_to_record(cradle::dynamic_map& record, api_function_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "parameters", x.parameters); write_field_to_record(record, "returns", x.returns); } void to_dynamic(cradle::dynamic* v, api_function_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_function_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.parameters, record, "parameters"); read_field_from_record(&x.returns, record, "returns"); } void from_dynamic(api_function_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_function_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_function_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.parameters)); boost::hash_combine(h, cradle::invoke_hash(x.returns));  return h; }} namespace cradle { 

#line 180 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_function_upgrade_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_function_upgrade_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_function_upgrade_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_function_upgrade_type_info")); } void structure_field_type_info_adder<api_function_upgrade_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["version"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_upgrade_type_info>().version)>(),             none);    (*fields)["type"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_upgrade_type_info>().type)>(),             none);    (*fields)["function"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_upgrade_type_info>().function)>(),             none); } bool operator==(api_function_upgrade_type_info const& a, api_function_upgrade_type_info const& b) { return a.version == b.version && a.type == b.type && a.function == b.function; } bool operator!=(api_function_upgrade_type_info const& a, api_function_upgrade_type_info const& b) { return !(a == b); } bool operator<(api_function_upgrade_type_info const& a, api_function_upgrade_type_info const& b) { if (a.version < b.version) return true; if (b.version < a.version) return false; if (a.type < b.type) return true; if (b.type < a.type) return false; if (a.function < b.function) return true; if (b.function < a.function) return false;     return false; } void swap(api_function_upgrade_type_info& a, api_function_upgrade_type_info& b) {     using std::swap;     swap(a.version, b.version);     swap(a.type, b.type);     swap(a.function, b.function); } size_t deep_sizeof(api_function_upgrade_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.version) + deep_sizeof(x.type) + deep_sizeof(x.function) ; } void write_fields_to_record(cradle::dynamic_map& record, api_function_upgrade_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "version", x.version); write_field_to_record(record, "type", x.type); write_field_to_record(record, "function", x.function); } void to_dynamic(cradle::dynamic* v, api_function_upgrade_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_function_upgrade_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.version, record, "version"); read_field_from_record(&x.type, record, "type"); read_field_from_record(&x.function, record, "function"); } void from_dynamic(api_function_upgrade_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_function_upgrade_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_function_upgrade_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.version)); boost::hash_combine(h, cradle::invoke_hash(x.type)); boost::hash_combine(h, cradle::invoke_hash(x.function));  return h; }} namespace cradle { 

#line 186 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_function_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_function_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_function_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_function_info")); } void structure_field_type_info_adder<api_function_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_info>().description)>(),             none);    (*fields)["execution_class"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_info>().execution_class)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_info>().schema)>(),             none); } bool operator==(api_function_info const& a, api_function_info const& b) { return a.name == b.name && a.description == b.description && a.execution_class == b.execution_class && a.schema == b.schema; } bool operator!=(api_function_info const& a, api_function_info const& b) { return !(a == b); } bool operator<(api_function_info const& a, api_function_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.execution_class < b.execution_class) return true; if (b.execution_class < a.execution_class) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_function_info& a, api_function_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.execution_class, b.execution_class);     swap(a.schema, b.schema); } size_t deep_sizeof(api_function_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.execution_class) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_function_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "execution_class", x.execution_class); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_function_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_function_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.execution_class, record, "execution_class"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_function_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_function_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_function_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.execution_class)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 196 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_upgrade_function_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_upgrade_function_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_upgrade_function_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_upgrade_function_info")); } void structure_field_type_info_adder<api_upgrade_function_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["version"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_upgrade_function_info>().version)>(),             none);    (*fields)["type"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_upgrade_function_info>().type)>(),             none);    (*fields)["function"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_upgrade_function_info>().function)>(),             none); } bool operator==(api_upgrade_function_info const& a, api_upgrade_function_info const& b) { return a.version == b.version && a.type == b.type && a.function == b.function; } bool operator!=(api_upgrade_function_info const& a, api_upgrade_function_info const& b) { return !(a == b); } bool operator<(api_upgrade_function_info const& a, api_upgrade_function_info const& b) { if (a.version < b.version) return true; if (b.version < a.version) return false; if (a.type < b.type) return true; if (b.type < a.type) return false; if (a.function < b.function) return true; if (b.function < a.function) return false;     return false; } void swap(api_upgrade_function_info& a, api_upgrade_function_info& b) {     using std::swap;     swap(a.version, b.version);     swap(a.type, b.type);     swap(a.function, b.function); } size_t deep_sizeof(api_upgrade_function_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.version) + deep_sizeof(x.type) + deep_sizeof(x.function) ; } void write_fields_to_record(cradle::dynamic_map& record, api_upgrade_function_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "version", x.version); write_field_to_record(record, "type", x.type); write_field_to_record(record, "function", x.function); } void to_dynamic(cradle::dynamic* v, api_upgrade_function_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_upgrade_function_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.version, record, "version"); read_field_from_record(&x.type, record, "type"); read_field_from_record(&x.function, record, "function"); } void from_dynamic(api_upgrade_function_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_upgrade_function_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_upgrade_function_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.version)); boost::hash_combine(h, cradle::invoke_hash(x.type)); boost::hash_combine(h, cradle::invoke_hash(x.function));  return h; }} namespace cradle { 

#line 305 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_named_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_named_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_named_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_named_type_info")); } void structure_field_type_info_adder<api_named_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_info>().schema)>(),             none); } bool operator==(api_named_type_info const& a, api_named_type_info const& b) { return a.name == b.name && a.description == b.description && a.schema == b.schema; } bool operator!=(api_named_type_info const& a, api_named_type_info const& b) { return !(a == b); } bool operator<(api_named_type_info const& a, api_named_type_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_named_type_info& a, api_named_type_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(api_named_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_named_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_named_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_named_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_named_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_named_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_named_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 313 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_named_type_implementation_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_named_type_implementation_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_named_type_implementation_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_named_type_implementation_info")); } void structure_field_type_info_adder<api_named_type_implementation_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_implementation_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_implementation_info>().description)>(),             none);    (*fields)["upgrade"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_implementation_info>().upgrade)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_type_implementation_info>().schema)>(),             none); } bool operator==(api_named_type_implementation_info const& a, api_named_type_implementation_info const& b) { return a.name == b.name && a.description == b.description && a.upgrade == b.upgrade && a.schema == b.schema; } bool operator!=(api_named_type_implementation_info const& a, api_named_type_implementation_info const& b) { return !(a == b); } bool operator<(api_named_type_implementation_info const& a, api_named_type_implementation_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.upgrade < b.upgrade) return true; if (b.upgrade < a.upgrade) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_named_type_implementation_info& a, api_named_type_implementation_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.upgrade, b.upgrade);     swap(a.schema, b.schema); } size_t deep_sizeof(api_named_type_implementation_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.upgrade) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_named_type_implementation_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "upgrade", x.upgrade); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_named_type_implementation_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_named_type_implementation_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.upgrade, record, "upgrade"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_named_type_implementation_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_named_type_implementation_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_named_type_implementation_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.upgrade)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 322 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_mutation_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_mutation_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_mutation_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_mutation_type_info")); } void structure_field_type_info_adder<api_mutation_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["version"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_mutation_type_info>().version)>(),             none);    (*fields)["type"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_mutation_type_info>().type)>(),             none);    (*fields)["body"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_mutation_type_info>().body)>(),             none); } bool operator==(api_mutation_type_info const& a, api_mutation_type_info const& b) { return a.version == b.version && a.type == b.type && a.body == b.body; } bool operator!=(api_mutation_type_info const& a, api_mutation_type_info const& b) { return !(a == b); } bool operator<(api_mutation_type_info const& a, api_mutation_type_info const& b) { if (a.version < b.version) return true; if (b.version < a.version) return false; if (a.type < b.type) return true; if (b.type < a.type) return false; if (a.body < b.body) return true; if (b.body < a.body) return false;     return false; } void swap(api_mutation_type_info& a, api_mutation_type_info& b) {     using std::swap;     swap(a.version, b.version);     swap(a.type, b.type);     swap(a.body, b.body); } size_t deep_sizeof(api_mutation_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.version) + deep_sizeof(x.type) + deep_sizeof(x.body) ; } void write_fields_to_record(cradle::dynamic_map& record, api_mutation_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "version", x.version); write_field_to_record(record, "type", x.type); write_field_to_record(record, "body", x.body); } void to_dynamic(cradle::dynamic* v, api_mutation_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_mutation_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.version, record, "version"); read_field_from_record(&x.type, record, "type"); read_field_from_record(&x.body, record, "body"); } void from_dynamic(api_mutation_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_mutation_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_mutation_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.version)); boost::hash_combine(h, cradle::invoke_hash(x.type)); boost::hash_combine(h, cradle::invoke_hash(x.body));  return h; }} namespace cradle { 

#line 330 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
void definitive_type_info_query<upgrade_type_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_enum_type(             cradle::get_enum_type_info<upgrade_type_info_tag>()); } void type_info_query<upgrade_type_info_tag>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "upgrade_type_info_tag")); } void enum_type_info_query<upgrade_type_info_tag>::get(     cradle::api_enum_info* info) {     std::map<std::string, cradle::api_enum_value_info> values; values["mutation_type"] =  cradle::api_enum_value_info( "");values["upgrade_type"] =  cradle::api_enum_value_info( "");     *info = cradle::api_enum_info(values); } char const* get_value_id(upgrade_type_info_tag value) {     switch (value)     { case upgrade_type_info_tag::MUTATION_TYPE: return "mutation_type";case upgrade_type_info_tag::UPGRADE_TYPE: return "upgrade_type";     }     CRADLE_THROW(         cradle::invalid_enum_value() <<             cradle::enum_id_info("upgrade_type_info_tag") <<             cradle::enum_value_info(int(value))); }void to_dynamic(     cradle::dynamic* v,     upgrade_type_info_tag x) {     *v = get_value_id(x); } void from_dynamic(     upgrade_type_info_tag* x,     cradle::dynamic const& v) {     string s = cast<string>(v);     if (boost::to_lower_copy(s) == "mutation_type")     {         *x = upgrade_type_info_tag::MUTATION_TYPE;         return;     };    if (boost::to_lower_copy(s) == "upgrade_type")     {         *x = upgrade_type_info_tag::UPGRADE_TYPE;         return;     };     CRADLE_THROW(         cradle::invalid_enum_string() <<             cradle::enum_id_info("upgrade_type_info_tag") <<             cradle::enum_string_info(s)); } std::ostream& operator<<(std::ostream& s, upgrade_type_info_tag const& x) {     s << get_value_id(x);     return s; } void definitive_type_info_query<upgrade_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_union_member_info> members;     members["mutation_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<dynamic>());    members["upgrade_type"] =         cradle::api_union_member_info(             "",             cradle::get_type_info<api_upgrade_function_info>());     *info =         cradle::make_api_type_info_with_union_type(             cradle::api_union_info(                 members)); } void type_info_query<upgrade_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "upgrade_type_info")); } upgrade_type_info make_upgrade_type_info_with_mutation_type(dynamic const& x) { upgrade_type_info s; s.type = upgrade_type_info_tag::MUTATION_TYPE; s.contents_ = x; return s; } upgrade_type_info make_upgrade_type_info_with_mutation_type(dynamic&& x) { upgrade_type_info s; s.type = upgrade_type_info_tag::MUTATION_TYPE; s.contents_ = std::move(x); return s; } upgrade_type_info make_upgrade_type_info_with_upgrade_type(api_upgrade_function_info const& x) { upgrade_type_info s; s.type = upgrade_type_info_tag::UPGRADE_TYPE; s.contents_ = x; return s; } upgrade_type_info make_upgrade_type_info_with_upgrade_type(api_upgrade_function_info&& x) { upgrade_type_info s; s.type = upgrade_type_info_tag::UPGRADE_TYPE; s.contents_ = std::move(x); return s; } dynamic const& as_mutation_type(upgrade_type_info const& x) { assert(x.type == upgrade_type_info_tag::MUTATION_TYPE); return std::any_cast<dynamic const& >(x.contents_); } api_upgrade_function_info const& as_upgrade_type(upgrade_type_info const& x) { assert(x.type == upgrade_type_info_tag::UPGRADE_TYPE); return std::any_cast<api_upgrade_function_info const& >(x.contents_); } dynamic& as_mutation_type(upgrade_type_info& x) { assert(x.type == upgrade_type_info_tag::MUTATION_TYPE); return std::any_cast<dynamic&>(x.contents_); } api_upgrade_function_info& as_upgrade_type(upgrade_type_info& x) { assert(x.type == upgrade_type_info_tag::UPGRADE_TYPE); return std::any_cast<api_upgrade_function_info&>(x.contents_); } void set_to_mutation_type(upgrade_type_info& x, dynamic const& y) { x.type = upgrade_type_info_tag::MUTATION_TYPE; x.contents_ = y; } void set_to_mutation_type(upgrade_type_info& x, dynamic&& y) { x.type = upgrade_type_info_tag::MUTATION_TYPE; x.contents_ = std::move(y); } void set_to_upgrade_type(upgrade_type_info& x, api_upgrade_function_info const& y) { x.type = upgrade_type_info_tag::UPGRADE_TYPE; x.contents_ = y; } void set_to_upgrade_type(upgrade_type_info& x, api_upgrade_function_info&& y) { x.type = upgrade_type_info_tag::UPGRADE_TYPE; x.contents_ = std::move(y); } bool operator==(upgrade_type_info const& a, upgrade_type_info const& b) { if (a.type != b.type) return false; switch (a.type) { case upgrade_type_info_tag::MUTATION_TYPE: return as_mutation_type(a) == as_mutation_type(b); case upgrade_type_info_tag::UPGRADE_TYPE: return as_upgrade_type(a) == as_upgrade_type(b); } return true; } bool operator!=(upgrade_type_info const& a, upgrade_type_info const& b) { return !(a == b); } bool operator<(upgrade_type_info const& a, upgrade_type_info const& b) { if (a.type < b.type) return true; if (b.type < a.type) return false; switch (a.type) { case upgrade_type_info_tag::MUTATION_TYPE: return as_mutation_type(a) < as_mutation_type(b); case upgrade_type_info_tag::UPGRADE_TYPE: return as_upgrade_type(a) < as_upgrade_type(b); } return false; } size_t hash_value(upgrade_type_info const& x) {     switch (x.type)     { case upgrade_type_info_tag::MUTATION_TYPE: return cradle::invoke_hash(as_mutation_type(x)); case upgrade_type_info_tag::UPGRADE_TYPE: return cradle::invoke_hash(as_upgrade_type(x));      } assert(0); return 0; }void swap(upgrade_type_info& a, upgrade_type_info& b) { using std::swap; swap(a.type, b.type); swap(a.contents_, b.contents_); } void to_dynamic(cradle::dynamic* v, upgrade_type_info const& x) { cradle::dynamic_map s; switch (x.type) { case upgrade_type_info_tag::MUTATION_TYPE: to_dynamic(&s[dynamic("mutation_type")], as_mutation_type(x)); break; case upgrade_type_info_tag::UPGRADE_TYPE: to_dynamic(&s[dynamic("upgrade_type")], as_upgrade_type(x)); break; } *v = std::move(s); } void from_dynamic(upgrade_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& s = cradle::cast<cradle::dynamic_map>(v); from_dynamic(&x->type, get_union_tag(s)); switch (x->type) { case upgrade_type_info_tag::MUTATION_TYPE:  { dynamic tmp; from_dynamic(&tmp, get_field(s, "mutation_type")); x->contents_ = tmp; break;  } case upgrade_type_info_tag::UPGRADE_TYPE:  { api_upgrade_function_info tmp; from_dynamic(&tmp, get_field(s, "upgrade_type")); x->contents_ = tmp; break;  } } } std::ostream& operator<<(std::ostream& s, upgrade_type_info const& x) { return s << to_dynamic(x); } size_t deep_sizeof(upgrade_type_info const& x) { using cradle::deep_sizeof; size_t size = sizeof(x); switch (x.type) { case upgrade_type_info_tag::MUTATION_TYPE: size += deep_sizeof(as_mutation_type(x)); break; case upgrade_type_info_tag::UPGRADE_TYPE: size += deep_sizeof(as_upgrade_type(x)); break; } return size; } 

#line 337 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_upgrade_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_upgrade_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_upgrade_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_upgrade_type_info")); } void structure_field_type_info_adder<api_upgrade_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_upgrade_type_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_upgrade_type_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_upgrade_type_info>().schema)>(),             none); } bool operator==(api_upgrade_type_info const& a, api_upgrade_type_info const& b) { return a.name == b.name && a.description == b.description && a.schema == b.schema; } bool operator!=(api_upgrade_type_info const& a, api_upgrade_type_info const& b) { return !(a == b); } bool operator<(api_upgrade_type_info const& a, api_upgrade_type_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_upgrade_type_info& a, api_upgrade_type_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(api_upgrade_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_upgrade_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_upgrade_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_upgrade_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_upgrade_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_upgrade_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_upgrade_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 345 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_dependency_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_dependency_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_dependency_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_dependency_type_info")); } void structure_field_type_info_adder<api_dependency_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["account"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_dependency_type_info>().account)>(),             none);    (*fields)["app"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_dependency_type_info>().app)>(),             none);    (*fields)["version"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_dependency_type_info>().version)>(),             none); } bool operator==(api_dependency_type_info const& a, api_dependency_type_info const& b) { return a.account == b.account && a.app == b.app && a.version == b.version; } bool operator!=(api_dependency_type_info const& a, api_dependency_type_info const& b) { return !(a == b); } bool operator<(api_dependency_type_info const& a, api_dependency_type_info const& b) { if (a.account < b.account) return true; if (b.account < a.account) return false; if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.version < b.version) return true; if (b.version < a.version) return false;     return false; } void swap(api_dependency_type_info& a, api_dependency_type_info& b) {     using std::swap;     swap(a.account, b.account);     swap(a.app, b.app);     swap(a.version, b.version); } size_t deep_sizeof(api_dependency_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.account) + deep_sizeof(x.app) + deep_sizeof(x.version) ; } void write_fields_to_record(cradle::dynamic_map& record, api_dependency_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "account", x.account); write_field_to_record(record, "app", x.app); write_field_to_record(record, "version", x.version); } void to_dynamic(cradle::dynamic* v, api_dependency_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_dependency_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.account, record, "account"); read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.version, record, "version"); } void from_dynamic(api_dependency_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_dependency_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_dependency_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.account)); boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.version));  return h; }} namespace cradle { 

#line 353 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_record_named_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_record_named_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_record_named_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_record_named_type_info")); } void structure_field_type_info_adder<api_record_named_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_record_named_type_info>().name)>(),             none);    (*fields)["app"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_record_named_type_info>().app)>(),             none);    (*fields)["account"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_record_named_type_info>().account)>(),             none); } bool operator==(api_record_named_type_info const& a, api_record_named_type_info const& b) { return a.name == b.name && a.app == b.app && a.account == b.account; } bool operator!=(api_record_named_type_info const& a, api_record_named_type_info const& b) { return !(a == b); } bool operator<(api_record_named_type_info const& a, api_record_named_type_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.app < b.app) return true; if (b.app < a.app) return false; if (a.account < b.account) return true; if (b.account < a.account) return false;     return false; } void swap(api_record_named_type_info& a, api_record_named_type_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.app, b.app);     swap(a.account, b.account); } size_t deep_sizeof(api_record_named_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.app) + deep_sizeof(x.account) ; } void write_fields_to_record(cradle::dynamic_map& record, api_record_named_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "app", x.app); write_field_to_record(record, "account", x.account); } void to_dynamic(cradle::dynamic* v, api_record_named_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_record_named_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.app, record, "app"); read_field_from_record(&x.account, record, "account"); } void from_dynamic(api_record_named_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_record_named_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_record_named_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.app)); boost::hash_combine(h, cradle::invoke_hash(x.account));  return h; }} namespace cradle { 

#line 361 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_record_named_type_schema>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_record_named_type_schema>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_record_named_type_schema>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_record_named_type_schema")); } void structure_field_type_info_adder<api_record_named_type_schema>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["named_type"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_record_named_type_schema>().named_type)>(),             none); } bool operator==(api_record_named_type_schema const& a, api_record_named_type_schema const& b) { return a.named_type == b.named_type; } bool operator!=(api_record_named_type_schema const& a, api_record_named_type_schema const& b) { return !(a == b); } bool operator<(api_record_named_type_schema const& a, api_record_named_type_schema const& b) { if (a.named_type < b.named_type) return true; if (b.named_type < a.named_type) return false;     return false; } void swap(api_record_named_type_schema& a, api_record_named_type_schema& b) {     using std::swap;     swap(a.named_type, b.named_type); } size_t deep_sizeof(api_record_named_type_schema const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.named_type) ; } void write_fields_to_record(cradle::dynamic_map& record, api_record_named_type_schema const& x) { using cradle::write_field_to_record; write_field_to_record(record, "named_type", x.named_type); } void to_dynamic(cradle::dynamic* v, api_record_named_type_schema const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_record_named_type_schema& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.named_type, record, "named_type"); } void from_dynamic(api_record_named_type_schema* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_record_named_type_schema const& x) { return s << to_dynamic(x); } size_t hash_value(api_record_named_type_schema const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.named_type));  return h; }} namespace cradle { 

#line 367 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_record_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_record_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_record_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_record_info")); } void structure_field_type_info_adder<api_record_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_record_info>().schema)>(),             none); } bool operator==(api_record_info const& a, api_record_info const& b) { return a.schema == b.schema; } bool operator!=(api_record_info const& a, api_record_info const& b) { return !(a == b); } bool operator<(api_record_info const& a, api_record_info const& b) { if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_record_info& a, api_record_info& b) {     using std::swap;     swap(a.schema, b.schema); } size_t deep_sizeof(api_record_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_record_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_record_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_record_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_record_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_record_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_record_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 373 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_named_record_type_info>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_named_record_type_info>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_named_record_type_info>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_named_record_type_info")); } void structure_field_type_info_adder<api_named_record_type_info>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_record_type_info>().name)>(),             none);    (*fields)["description"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_record_type_info>().description)>(),             none);    (*fields)["schema"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_named_record_type_info>().schema)>(),             none); } bool operator==(api_named_record_type_info const& a, api_named_record_type_info const& b) { return a.name == b.name && a.description == b.description && a.schema == b.schema; } bool operator!=(api_named_record_type_info const& a, api_named_record_type_info const& b) { return !(a == b); } bool operator<(api_named_record_type_info const& a, api_named_record_type_info const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.description < b.description) return true; if (b.description < a.description) return false; if (a.schema < b.schema) return true; if (b.schema < a.schema) return false;     return false; } void swap(api_named_record_type_info& a, api_named_record_type_info& b) {     using std::swap;     swap(a.name, b.name);     swap(a.description, b.description);     swap(a.schema, b.schema); } size_t deep_sizeof(api_named_record_type_info const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.description) + deep_sizeof(x.schema) ; } void write_fields_to_record(cradle::dynamic_map& record, api_named_record_type_info const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "description", x.description); write_field_to_record(record, "schema", x.schema); } void to_dynamic(cradle::dynamic* v, api_named_record_type_info const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_named_record_type_info& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.description, record, "description"); read_field_from_record(&x.schema, record, "schema"); } void from_dynamic(api_named_record_type_info* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_named_record_type_info const& x) { return s << to_dynamic(x); } size_t hash_value(api_named_record_type_info const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.description)); boost::hash_combine(h, cradle::invoke_hash(x.schema));  return h; }} namespace cradle { 

#line 425 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_function_uid_contents>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_function_uid_contents>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_function_uid_contents>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_function_uid_contents")); } void structure_field_type_info_adder<api_function_uid_contents>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["name"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_uid_contents>().name)>(),             none);    (*fields)["parameters"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_uid_contents>().parameters)>(),             none);    (*fields)["revision"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_function_uid_contents>().revision)>(),             none); } bool operator==(api_function_uid_contents const& a, api_function_uid_contents const& b) { return a.name == b.name && a.parameters == b.parameters && a.revision == b.revision; } bool operator!=(api_function_uid_contents const& a, api_function_uid_contents const& b) { return !(a == b); } bool operator<(api_function_uid_contents const& a, api_function_uid_contents const& b) { if (a.name < b.name) return true; if (b.name < a.name) return false; if (a.parameters < b.parameters) return true; if (b.parameters < a.parameters) return false; if (a.revision < b.revision) return true; if (b.revision < a.revision) return false;     return false; } void swap(api_function_uid_contents& a, api_function_uid_contents& b) {     using std::swap;     swap(a.name, b.name);     swap(a.parameters, b.parameters);     swap(a.revision, b.revision); } size_t deep_sizeof(api_function_uid_contents const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.name) + deep_sizeof(x.parameters) + deep_sizeof(x.revision) ; } void write_fields_to_record(cradle::dynamic_map& record, api_function_uid_contents const& x) { using cradle::write_field_to_record; write_field_to_record(record, "name", x.name); write_field_to_record(record, "parameters", x.parameters); write_field_to_record(record, "revision", x.revision); } void to_dynamic(cradle::dynamic* v, api_function_uid_contents const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_function_uid_contents& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.name, record, "name"); read_field_from_record(&x.parameters, record, "parameters"); read_field_from_record(&x.revision, record, "revision"); } void from_dynamic(api_function_uid_contents* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_function_uid_contents const& x) { return s << to_dynamic(x); } size_t hash_value(api_function_uid_contents const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.name)); boost::hash_combine(h, cradle::invoke_hash(x.parameters)); boost::hash_combine(h, cradle::invoke_hash(x.revision));  return h; }} namespace cradle { 

#line 441 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_documentation>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_documentation>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_documentation>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_documentation")); } void structure_field_type_info_adder<api_documentation>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {      (*fields)["types"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_documentation>().types)>(),             none);    (*fields)["functions"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_documentation>().functions)>(),             none);    (*fields)["upgrades"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_documentation>().upgrades)>(),             none);    (*fields)["dependencies"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_documentation>().dependencies)>(),             none);    (*fields)["records"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_documentation>().records)>(),             none); } bool operator==(api_documentation const& a, api_documentation const& b) { return a.types == b.types && a.functions == b.functions && a.upgrades == b.upgrades && a.dependencies == b.dependencies && a.records == b.records; } bool operator!=(api_documentation const& a, api_documentation const& b) { return !(a == b); } bool operator<(api_documentation const& a, api_documentation const& b) { if (a.types < b.types) return true; if (b.types < a.types) return false; if (a.functions < b.functions) return true; if (b.functions < a.functions) return false; if (a.upgrades < b.upgrades) return true; if (b.upgrades < a.upgrades) return false; if (a.dependencies < b.dependencies) return true; if (b.dependencies < a.dependencies) return false; if (a.records < b.records) return true; if (b.records < a.records) return false;     return false; } void swap(api_documentation& a, api_documentation& b) {     using std::swap;     swap(a.types, b.types);     swap(a.functions, b.functions);     swap(a.upgrades, b.upgrades);     swap(a.dependencies, b.dependencies);     swap(a.records, b.records); } size_t deep_sizeof(api_documentation const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(x.types) + deep_sizeof(x.functions) + deep_sizeof(x.upgrades) + deep_sizeof(x.dependencies) + deep_sizeof(x.records) ; } void write_fields_to_record(cradle::dynamic_map& record, api_documentation const& x) { using cradle::write_field_to_record; write_field_to_record(record, "types", x.types); write_field_to_record(record, "functions", x.functions); write_field_to_record(record, "upgrades", x.upgrades); write_field_to_record(record, "dependencies", x.dependencies); write_field_to_record(record, "records", x.records); } void to_dynamic(cradle::dynamic* v, api_documentation const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_documentation& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_field_from_record(&x.types, record, "types"); read_field_from_record(&x.functions, record, "functions"); read_field_from_record(&x.upgrades, record, "upgrades"); read_field_from_record(&x.dependencies, record, "dependencies"); read_field_from_record(&x.records, record, "records"); } void from_dynamic(api_documentation* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_documentation const& x) { return s << to_dynamic(x); } size_t hash_value(api_documentation const& x) { size_t h = 0; boost::hash_combine(h, cradle::invoke_hash(x.types)); boost::hash_combine(h, cradle::invoke_hash(x.functions)); boost::hash_combine(h, cradle::invoke_hash(x.upgrades)); boost::hash_combine(h, cradle::invoke_hash(x.dependencies)); boost::hash_combine(h, cradle::invoke_hash(x.records));  return h; }} namespace cradle { 

#line 455 "C:/dev/open-cradle/cradle/src/cradle/typing/core/api_types.hpp"
} namespace cradle { void definitive_type_info_query<api_manifest>::get(     cradle::api_type_info* info) {     std::map<std::string, cradle::api_structure_field_info> fields;     structure_field_type_info_adder<api_manifest>::add(&fields);     *info =         cradle::make_api_type_info_with_structure_type(             cradle::api_structure_info(                 fields)); } void type_info_query<api_manifest>::get(     cradle::api_type_info* info) {     *info =         cradle::make_api_type_info_with_named_type(             cradle::api_named_type_reference(                 "dosimetry", "api_manifest")); } void structure_field_type_info_adder<api_manifest>::add(     std::map<std::string, cradle::api_structure_field_info>* fields) {     structure_field_type_info_adder<api_documentation>::add(fields);      (*fields)["var1"] =         cradle::api_structure_field_info(             "",             cradle::get_type_info<decltype(std::declval<api_manifest>().var1)>(),             none); } bool operator==(api_manifest const& a, api_manifest const& b) { return as_api_documentation(a) == as_api_documentation(b) && a.var1 == b.var1; } bool operator!=(api_manifest const& a, api_manifest const& b) { return !(a == b); } bool operator<(api_manifest const& a, api_manifest const& b) { if (as_api_documentation(a) < as_api_documentation(b)) return true; if (as_api_documentation(b) < as_api_documentation(a)) return false; if (a.var1 < b.var1) return true; if (b.var1 < a.var1) return false;     return false; } void swap(api_manifest& a, api_manifest& b) {     using std::swap; swap(as_api_documentation(a), as_api_documentation(b));     swap(a.var1, b.var1); } size_t deep_sizeof(api_manifest const& x) {     using cradle::deep_sizeof;     return 0 + deep_sizeof(as_api_documentation(x)) + deep_sizeof(x.var1) ; } void write_fields_to_record(cradle::dynamic_map& record, api_manifest const& x) { using cradle::write_field_to_record; write_fields_to_record(record, as_api_documentation(x)); write_field_to_record(record, "var1", x.var1); } void to_dynamic(cradle::dynamic* v, api_manifest const& x) { cradle::dynamic_map r; write_fields_to_record(r, x); *v = std::move(r); } void read_fields_from_record(api_manifest& x, cradle::dynamic_map const& record) { using cradle::read_field_from_record; read_fields_from_record(as_api_documentation(x), record); read_field_from_record(&x.var1, record, "var1"); } void from_dynamic(api_manifest* x, cradle::dynamic const& v) { cradle::dynamic_map const& r = cradle::cast<cradle::dynamic_map>(v); read_fields_from_record(*x, r); } std::ostream& operator<<(std::ostream& s, api_manifest const& x) { return s << to_dynamic(x); } size_t hash_value(api_manifest const& x) { size_t h = cradle::invoke_hash(as_api_documentation(x)); boost::hash_combine(h, cradle::invoke_hash(x.var1));  return h; }} namespace cradle { 

}

namespace cradle {
void add_src_cradle_typing_core_api_types_api(cradle::api_implementation& api)
{
register_api_named_type(     api,     "api_type_info",     0,     "",     get_definitive_type_info<api_type_info>());register_api_named_type(     api,     "api_nil_type",     0,     "",     get_definitive_type_info<api_nil_type>());register_api_named_type(     api,     "api_boolean_type",     0,     "",     get_definitive_type_info<api_boolean_type>());register_api_named_type(     api,     "api_integer_type",     0,     "",     get_definitive_type_info<api_integer_type>());register_api_named_type(     api,     "api_float_type",     0,     "",     get_definitive_type_info<api_float_type>());register_api_named_type(     api,     "api_string_type",     0,     "",     get_definitive_type_info<api_string_type>());register_api_named_type(     api,     "api_datetime_type",     0,     "",     get_definitive_type_info<api_datetime_type>());register_api_named_type(     api,     "api_blob_type",     0,     "",     get_definitive_type_info<api_blob_type>());register_api_named_type(     api,     "api_dynamic_type",     0,     "",     get_definitive_type_info<api_dynamic_type>());register_api_named_type(     api,     "api_structure_field_info",     0,     "",     get_definitive_type_info<api_structure_field_info>());register_api_named_type(     api,     "api_structure_info",     0,     "",     get_definitive_type_info<api_structure_info>());register_api_named_type(     api,     "api_union_member_info",     0,     "",     get_definitive_type_info<api_union_member_info>());register_api_named_type(     api,     "api_union_info",     0,     "",     get_definitive_type_info<api_union_info>());register_api_named_type(     api,     "api_enum_value_info",     0,     "",     get_definitive_type_info<api_enum_value_info>());register_api_named_type(     api,     "api_enum_info",     0,     "",     get_definitive_type_info<api_enum_info>());register_api_named_type(     api,     "api_array_info",     0,     "",     get_definitive_type_info<api_array_info>());register_api_named_type(     api,     "api_map_info",     0,     "",     get_definitive_type_info<api_map_info>());register_api_named_type(     api,     "api_named_type_reference",     0,     "",     get_definitive_type_info<api_named_type_reference>());register_api_named_type(     api,     "api_record_type_info",     0,     "",     get_definitive_type_info<api_record_type_info>());register_api_named_type(     api,     "api_function_parameter_info",     0,     "",     get_definitive_type_info<api_function_parameter_info>());register_api_named_type(     api,     "api_function_result_info",     0,     "",     get_definitive_type_info<api_function_result_info>());register_api_named_type(     api,     "api_function_type_info",     0,     "",     get_definitive_type_info<api_function_type_info>());register_api_named_type(     api,     "api_function_upgrade_type_info",     0,     "",     get_definitive_type_info<api_function_upgrade_type_info>());register_api_named_type(     api,     "api_function_info",     0,     "",     get_definitive_type_info<api_function_info>());register_api_named_type(     api,     "api_upgrade_function_info",     0,     "",     get_definitive_type_info<api_upgrade_function_info>());register_api_named_type(     api,     "api_named_type_info",     0,     "",     get_definitive_type_info<api_named_type_info>());register_api_named_type(     api,     "api_named_type_implementation_info",     0,     "",     get_definitive_type_info<api_named_type_implementation_info>());register_api_named_type(     api,     "api_record_named_type_info",     0,     "",     get_definitive_type_info<api_record_named_type_info>());register_api_named_type(     api,     "api_record_named_type_schema",     0,     "",     get_definitive_type_info<api_record_named_type_schema>());register_api_named_type(     api,     "api_record_info",     0,     "",     get_definitive_type_info<api_record_info>());
}

}
