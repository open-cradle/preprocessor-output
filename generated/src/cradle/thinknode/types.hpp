// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#ifndef THINKNODE_ACCOUNT
#define THINKNODE_ACCOUNT "mgh"
#endif
#ifndef THINKNODE_FUNCTION_APP
#define THINKNODE_FUNCTION_APP "dosimetry"
#endif
#ifndef THINKNODE_TYPES_APP
#define THINKNODE_TYPES_APP "dosimetry"
#endif
#include <cradle/typing/core/preprocessed.h>









#ifdef IAM 
    #undef IAM 
#endif 

#ifdef APM 
    #undef APM 
#endif 

#ifdef ISS 
    #undef ISS 
#endif 

#ifdef CALC 
    #undef CALC 
#endif 

#ifdef CAS 
    #undef CAS 
#endif 

#ifdef RKS 
    #undef RKS 
#endif 

#ifdef IMMUTABLE 
    #undef IMMUTABLE 
#endif 







#ifdef ARRAY_TYPE 
    #undef ARRAY_TYPE 
#endif 

#ifdef BLOB_TYPE 
    #undef BLOB_TYPE 
#endif 

#ifdef BOOLEAN_TYPE 
    #undef BOOLEAN_TYPE 
#endif 

#ifdef DATETIME_TYPE 
    #undef DATETIME_TYPE 
#endif 

#ifdef DYNAMIC_TYPE 
    #undef DYNAMIC_TYPE 
#endif 

#ifdef ENUM_TYPE 
    #undef ENUM_TYPE 
#endif 

#ifdef FLOAT_TYPE 
    #undef FLOAT_TYPE 
#endif 

#ifdef INTEGER_TYPE 
    #undef INTEGER_TYPE 
#endif 

#ifdef MAP_TYPE 
    #undef MAP_TYPE 
#endif 

#ifdef NAMED_TYPE 
    #undef NAMED_TYPE 
#endif 

#ifdef NIL_TYPE 
    #undef NIL_TYPE 
#endif 

#ifdef OPTIONAL_TYPE 
    #undef OPTIONAL_TYPE 
#endif 

#ifdef REFERENCE_TYPE 
    #undef REFERENCE_TYPE 
#endif 

#ifdef STRING_TYPE 
    #undef STRING_TYPE 
#endif 

#ifdef STRUCTURE_TYPE 
    #undef STRUCTURE_TYPE 
#endif 

#ifdef UNION_TYPE 
    #undef UNION_TYPE 
#endif 





#ifdef REFERENCE 
    #undef REFERENCE 
#endif 

#ifdef VALUE 
    #undef VALUE 
#endif 

#ifdef FUNCTION 
    #undef FUNCTION 
#endif 

#ifdef ARRAY 
    #undef ARRAY 
#endif 

#ifdef ITEM 
    #undef ITEM 
#endif 

#ifdef OBJECT 
    #undef OBJECT 
#endif 

#ifdef PROPERTY 
    #undef PROPERTY 
#endif 

#ifdef LET 
    #undef LET 
#endif 

#ifdef VARIABLE 
    #undef VARIABLE 
#endif 

#ifdef META 
    #undef META 
#endif 

#ifdef CAST 
    #undef CAST 
#endif 



























#ifdef PENDING 
    #undef PENDING 
#endif 

#ifdef READY 
    #undef READY 
#endif 









#ifdef CALCULATING 
    #undef CALCULATING 
#endif 

#ifdef CANCELED 
    #undef CANCELED 
#endif 

#ifdef COMPLETED 
    #undef COMPLETED 
#endif 

#ifdef FAILED 
    #undef FAILED 
#endif 

#ifdef GENERATING 
    #undef GENERATING 
#endif 

#ifdef QUEUED 
    #undef QUEUED 
#endif 

#ifdef UPLOADING 
    #undef UPLOADING 
#endif 

#ifdef WAITING 
    #undef WAITING 
#endif 











































#ifdef FUNCTION_TYPE 
    #undef FUNCTION_TYPE 
#endif 







#ifdef TAG 
    #undef TAG 
#endif 

#ifdef DIGEST 
    #undef DIGEST 
#endif 





#ifdef PRIVATE 
    #undef PRIVATE 
#endif 







#ifdef VERSION 
    #undef VERSION 
#endif 

#ifdef BRANCH 
    #undef BRANCH 
#endif 

#ifdef COMMIT 
    #undef COMMIT 
#endif 









#ifdef FUNCTION 
    #undef FUNCTION 
#endif 

#ifdef PING 
    #undef PING 
#endif 









#ifdef REGISTRATION 
    #undef REGISTRATION 
#endif 

#ifdef PROGRESS 
    #undef PROGRESS 
#endif 

#ifdef PONG 
    #undef PONG 
#endif 

#ifdef RESULT 
    #undef RESULT 
#endif 

#ifdef FAILURE 
    #undef FAILURE 
#endif 




#line 1 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
#ifndef CRADLE_THINKNODE_TYPES_HPP
#define CRADLE_THINKNODE_TYPES_HPP

#line 4 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
#include <vector>

#line 6 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
#include <cradle/inner/core/id.h>

#line 8 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
namespace cradle {


#ifdef IAM 
    #undef IAM 
#endif 

#ifdef APM 
    #undef APM 
#endif 

#ifdef ISS 
    #undef ISS 
#endif 

#ifdef CALC 
    #undef CALC 
#endif 

#ifdef CAS 
    #undef CAS 
#endif 

#ifdef RKS 
    #undef RKS 
#endif 

#ifdef IMMUTABLE 
    #undef IMMUTABLE 
#endif 
#line 10 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_service_id { IAM,APM,ISS,CALC,CAS,RKS,IMMUTABLE }; template<> struct definitive_type_info_query<thinknode_service_id> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_service_id> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_service_id> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_service_id) { return sizeof(thinknode_service_id); } inline size_t hash_value(thinknode_service_id const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_service_id) { return 7; } char const* get_value_id(thinknode_service_id value); void to_dynamic(     cradle::dynamic* v,     thinknode_service_id x); void from_dynamic(     thinknode_service_id* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_service_id const& x); 

#line 22 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_session { std::string api_url;  std::string access_token;  thinknode_session() {} thinknode_session(std::string const& api_url, std::string const& access_token) : api_url(api_url), access_token(access_token) {} };  inline thinknode_session make_thinknode_session(  std::string api_url, std::string access_token ) { return thinknode_session(  std::move(api_url), std::move(access_token) ); }template<> struct definitive_type_info_query<thinknode_session> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_session> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_session> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_session const& a, thinknode_session const& b); bool operator!=(thinknode_session const& a, thinknode_session const& b); bool operator<(thinknode_session const& a, thinknode_session const& b); void swap(thinknode_session& a, thinknode_session& b); size_t deep_sizeof(thinknode_session const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_session const& x); void to_dynamic(cradle::dynamic* v, thinknode_session const& x); void read_fields_from_record(thinknode_session& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_session* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_session const& x);std::ostream& operator<<(std::ostream& s, thinknode_session const& x);size_t hash_value(thinknode_session const& x);} namespace cradle { 

#line 29 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
struct thinknode_array_info;
struct thinknode_blob_type;
struct thinknode_boolean_type;
struct thinknode_datetime_type;
struct thinknode_dynamic_type;
struct thinknode_enum_info;
struct thinknode_float_type;
struct thinknode_integer_type;
struct thinknode_map_info;
struct thinknode_named_type_reference;
struct thinknode_nil_type;
struct thinknode_type_info;
struct thinknode_string_type;
struct thinknode_structure_info;
struct thinknode_union_info;


#ifdef ARRAY_TYPE 
    #undef ARRAY_TYPE 
#endif 

#ifdef BLOB_TYPE 
    #undef BLOB_TYPE 
#endif 

#ifdef BOOLEAN_TYPE 
    #undef BOOLEAN_TYPE 
#endif 

#ifdef DATETIME_TYPE 
    #undef DATETIME_TYPE 
#endif 

#ifdef DYNAMIC_TYPE 
    #undef DYNAMIC_TYPE 
#endif 

#ifdef ENUM_TYPE 
    #undef ENUM_TYPE 
#endif 

#ifdef FLOAT_TYPE 
    #undef FLOAT_TYPE 
#endif 

#ifdef INTEGER_TYPE 
    #undef INTEGER_TYPE 
#endif 

#ifdef MAP_TYPE 
    #undef MAP_TYPE 
#endif 

#ifdef NAMED_TYPE 
    #undef NAMED_TYPE 
#endif 

#ifdef NIL_TYPE 
    #undef NIL_TYPE 
#endif 

#ifdef OPTIONAL_TYPE 
    #undef OPTIONAL_TYPE 
#endif 

#ifdef REFERENCE_TYPE 
    #undef REFERENCE_TYPE 
#endif 

#ifdef STRING_TYPE 
    #undef STRING_TYPE 
#endif 

#ifdef STRUCTURE_TYPE 
    #undef STRUCTURE_TYPE 
#endif 

#ifdef UNION_TYPE 
    #undef UNION_TYPE 
#endif 
#line 45 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_type_info_tag { ARRAY_TYPE,BLOB_TYPE,BOOLEAN_TYPE,DATETIME_TYPE,DYNAMIC_TYPE,ENUM_TYPE,FLOAT_TYPE,INTEGER_TYPE,MAP_TYPE,NAMED_TYPE,NIL_TYPE,OPTIONAL_TYPE,REFERENCE_TYPE,STRING_TYPE,STRUCTURE_TYPE,UNION_TYPE }; template<> struct definitive_type_info_query<thinknode_type_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_type_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_type_info_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_type_info_tag) { return sizeof(thinknode_type_info_tag); } inline size_t hash_value(thinknode_type_info_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_type_info_tag) { return 16; } char const* get_value_id(thinknode_type_info_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_type_info_tag x); void from_dynamic(     thinknode_type_info_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_type_info_tag const& x); struct thinknode_type_info { thinknode_type_info_tag type; std::any contents_; thinknode_type_info() {} thinknode_type_info(thinknode_type_info const& other) : type(other.type), contents_(other.contents_) {} thinknode_type_info(thinknode_type_info&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_type_info& operator=(thinknode_type_info const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_type_info& operator=(thinknode_type_info&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_type_info> {     static void     get(cradle::api_type_info*); }; thinknode_type_info make_thinknode_type_info_with_array_type(thinknode_array_info const& x); thinknode_type_info make_thinknode_type_info_with_array_type(thinknode_array_info&& x); thinknode_type_info make_thinknode_type_info_with_blob_type(thinknode_blob_type const& x); thinknode_type_info make_thinknode_type_info_with_blob_type(thinknode_blob_type&& x); thinknode_type_info make_thinknode_type_info_with_boolean_type(thinknode_boolean_type const& x); thinknode_type_info make_thinknode_type_info_with_boolean_type(thinknode_boolean_type&& x); thinknode_type_info make_thinknode_type_info_with_datetime_type(thinknode_datetime_type const& x); thinknode_type_info make_thinknode_type_info_with_datetime_type(thinknode_datetime_type&& x); thinknode_type_info make_thinknode_type_info_with_dynamic_type(thinknode_dynamic_type const& x); thinknode_type_info make_thinknode_type_info_with_dynamic_type(thinknode_dynamic_type&& x); thinknode_type_info make_thinknode_type_info_with_enum_type(thinknode_enum_info const& x); thinknode_type_info make_thinknode_type_info_with_enum_type(thinknode_enum_info&& x); thinknode_type_info make_thinknode_type_info_with_float_type(thinknode_float_type const& x); thinknode_type_info make_thinknode_type_info_with_float_type(thinknode_float_type&& x); thinknode_type_info make_thinknode_type_info_with_integer_type(thinknode_integer_type const& x); thinknode_type_info make_thinknode_type_info_with_integer_type(thinknode_integer_type&& x); thinknode_type_info make_thinknode_type_info_with_map_type(thinknode_map_info const& x); thinknode_type_info make_thinknode_type_info_with_map_type(thinknode_map_info&& x); thinknode_type_info make_thinknode_type_info_with_named_type(thinknode_named_type_reference const& x); thinknode_type_info make_thinknode_type_info_with_named_type(thinknode_named_type_reference&& x); thinknode_type_info make_thinknode_type_info_with_nil_type(thinknode_nil_type const& x); thinknode_type_info make_thinknode_type_info_with_nil_type(thinknode_nil_type&& x); thinknode_type_info make_thinknode_type_info_with_optional_type(thinknode_type_info const& x); thinknode_type_info make_thinknode_type_info_with_optional_type(thinknode_type_info&& x); thinknode_type_info make_thinknode_type_info_with_reference_type(thinknode_type_info const& x); thinknode_type_info make_thinknode_type_info_with_reference_type(thinknode_type_info&& x); thinknode_type_info make_thinknode_type_info_with_string_type(thinknode_string_type const& x); thinknode_type_info make_thinknode_type_info_with_string_type(thinknode_string_type&& x); thinknode_type_info make_thinknode_type_info_with_structure_type(thinknode_structure_info const& x); thinknode_type_info make_thinknode_type_info_with_structure_type(thinknode_structure_info&& x); thinknode_type_info make_thinknode_type_info_with_union_type(thinknode_union_info const& x); thinknode_type_info make_thinknode_type_info_with_union_type(thinknode_union_info&& x); static inline thinknode_type_info_tag  get_tag(thinknode_type_info const& x) { return x.type; } bool static inline is_array_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::ARRAY_TYPE; } bool static inline is_blob_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::BLOB_TYPE; } bool static inline is_boolean_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::BOOLEAN_TYPE; } bool static inline is_datetime_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::DATETIME_TYPE; } bool static inline is_dynamic_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::DYNAMIC_TYPE; } bool static inline is_enum_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::ENUM_TYPE; } bool static inline is_float_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::FLOAT_TYPE; } bool static inline is_integer_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::INTEGER_TYPE; } bool static inline is_map_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::MAP_TYPE; } bool static inline is_named_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::NAMED_TYPE; } bool static inline is_nil_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::NIL_TYPE; } bool static inline is_optional_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::OPTIONAL_TYPE; } bool static inline is_reference_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::REFERENCE_TYPE; } bool static inline is_string_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::STRING_TYPE; } bool static inline is_structure_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::STRUCTURE_TYPE; } bool static inline is_union_type(thinknode_type_info const& x) { return x.type == thinknode_type_info_tag::UNION_TYPE; } thinknode_array_info const& as_array_type(thinknode_type_info const& x); thinknode_blob_type const& as_blob_type(thinknode_type_info const& x); thinknode_boolean_type const& as_boolean_type(thinknode_type_info const& x); thinknode_datetime_type const& as_datetime_type(thinknode_type_info const& x); thinknode_dynamic_type const& as_dynamic_type(thinknode_type_info const& x); thinknode_enum_info const& as_enum_type(thinknode_type_info const& x); thinknode_float_type const& as_float_type(thinknode_type_info const& x); thinknode_integer_type const& as_integer_type(thinknode_type_info const& x); thinknode_map_info const& as_map_type(thinknode_type_info const& x); thinknode_named_type_reference const& as_named_type(thinknode_type_info const& x); thinknode_nil_type const& as_nil_type(thinknode_type_info const& x); thinknode_type_info const& as_optional_type(thinknode_type_info const& x); thinknode_type_info const& as_reference_type(thinknode_type_info const& x); thinknode_string_type const& as_string_type(thinknode_type_info const& x); thinknode_structure_info const& as_structure_type(thinknode_type_info const& x); thinknode_union_info const& as_union_type(thinknode_type_info const& x); thinknode_array_info& as_array_type(thinknode_type_info& x); thinknode_blob_type& as_blob_type(thinknode_type_info& x); thinknode_boolean_type& as_boolean_type(thinknode_type_info& x); thinknode_datetime_type& as_datetime_type(thinknode_type_info& x); thinknode_dynamic_type& as_dynamic_type(thinknode_type_info& x); thinknode_enum_info& as_enum_type(thinknode_type_info& x); thinknode_float_type& as_float_type(thinknode_type_info& x); thinknode_integer_type& as_integer_type(thinknode_type_info& x); thinknode_map_info& as_map_type(thinknode_type_info& x); thinknode_named_type_reference& as_named_type(thinknode_type_info& x); thinknode_nil_type& as_nil_type(thinknode_type_info& x); thinknode_type_info& as_optional_type(thinknode_type_info& x); thinknode_type_info& as_reference_type(thinknode_type_info& x); thinknode_string_type& as_string_type(thinknode_type_info& x); thinknode_structure_info& as_structure_type(thinknode_type_info& x); thinknode_union_info& as_union_type(thinknode_type_info& x); void set_to_array_type(thinknode_type_info& x, thinknode_array_info const& y); void set_to_array_type(thinknode_type_info& x, thinknode_array_info&& y); void set_to_blob_type(thinknode_type_info& x, thinknode_blob_type const& y); void set_to_blob_type(thinknode_type_info& x, thinknode_blob_type&& y); void set_to_boolean_type(thinknode_type_info& x, thinknode_boolean_type const& y); void set_to_boolean_type(thinknode_type_info& x, thinknode_boolean_type&& y); void set_to_datetime_type(thinknode_type_info& x, thinknode_datetime_type const& y); void set_to_datetime_type(thinknode_type_info& x, thinknode_datetime_type&& y); void set_to_dynamic_type(thinknode_type_info& x, thinknode_dynamic_type const& y); void set_to_dynamic_type(thinknode_type_info& x, thinknode_dynamic_type&& y); void set_to_enum_type(thinknode_type_info& x, thinknode_enum_info const& y); void set_to_enum_type(thinknode_type_info& x, thinknode_enum_info&& y); void set_to_float_type(thinknode_type_info& x, thinknode_float_type const& y); void set_to_float_type(thinknode_type_info& x, thinknode_float_type&& y); void set_to_integer_type(thinknode_type_info& x, thinknode_integer_type const& y); void set_to_integer_type(thinknode_type_info& x, thinknode_integer_type&& y); void set_to_map_type(thinknode_type_info& x, thinknode_map_info const& y); void set_to_map_type(thinknode_type_info& x, thinknode_map_info&& y); void set_to_named_type(thinknode_type_info& x, thinknode_named_type_reference const& y); void set_to_named_type(thinknode_type_info& x, thinknode_named_type_reference&& y); void set_to_nil_type(thinknode_type_info& x, thinknode_nil_type const& y); void set_to_nil_type(thinknode_type_info& x, thinknode_nil_type&& y); void set_to_optional_type(thinknode_type_info& x, thinknode_type_info const& y); void set_to_optional_type(thinknode_type_info& x, thinknode_type_info&& y); void set_to_reference_type(thinknode_type_info& x, thinknode_type_info const& y); void set_to_reference_type(thinknode_type_info& x, thinknode_type_info&& y); void set_to_string_type(thinknode_type_info& x, thinknode_string_type const& y); void set_to_string_type(thinknode_type_info& x, thinknode_string_type&& y); void set_to_structure_type(thinknode_type_info& x, thinknode_structure_info const& y); void set_to_structure_type(thinknode_type_info& x, thinknode_structure_info&& y); void set_to_union_type(thinknode_type_info& x, thinknode_union_info const& y); void set_to_union_type(thinknode_type_info& x, thinknode_union_info&& y); bool operator==(thinknode_type_info const& a, thinknode_type_info const& b); bool operator!=(thinknode_type_info const& a, thinknode_type_info const& b); bool operator<(thinknode_type_info const& a, thinknode_type_info const& b); size_t hash_value(thinknode_type_info const& x);void swap(thinknode_type_info& a, thinknode_type_info& b); void to_dynamic(cradle::dynamic* v, thinknode_type_info const& x); void from_dynamic(thinknode_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_type_info const& x); size_t deep_sizeof(thinknode_type_info const& x); 

#line 66 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
struct thinknode_function_application;
struct thinknode_array_calc;
struct thinknode_item_calc;
struct thinknode_object_calc;
struct thinknode_property_calc;
struct thinknode_let_calc;
struct thinknode_meta_calc;
struct thinknode_cast_request;


#ifdef REFERENCE 
    #undef REFERENCE 
#endif 

#ifdef VALUE 
    #undef VALUE 
#endif 

#ifdef FUNCTION 
    #undef FUNCTION 
#endif 

#ifdef ARRAY 
    #undef ARRAY 
#endif 

#ifdef ITEM 
    #undef ITEM 
#endif 

#ifdef OBJECT 
    #undef OBJECT 
#endif 

#ifdef PROPERTY 
    #undef PROPERTY 
#endif 

#ifdef LET 
    #undef LET 
#endif 

#ifdef VARIABLE 
    #undef VARIABLE 
#endif 

#ifdef META 
    #undef META 
#endif 

#ifdef CAST 
    #undef CAST 
#endif 
#line 75 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_calc_request_tag { REFERENCE,VALUE,FUNCTION,ARRAY,ITEM,OBJECT,PROPERTY,LET,VARIABLE,META,CAST }; template<> struct definitive_type_info_query<thinknode_calc_request_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_calc_request_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_calc_request_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_calc_request_tag) { return sizeof(thinknode_calc_request_tag); } inline size_t hash_value(thinknode_calc_request_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_calc_request_tag) { return 11; } char const* get_value_id(thinknode_calc_request_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_calc_request_tag x); void from_dynamic(     thinknode_calc_request_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_calc_request_tag const& x); struct thinknode_calc_request { thinknode_calc_request_tag type; std::any contents_; thinknode_calc_request() {} thinknode_calc_request(thinknode_calc_request const& other) : type(other.type), contents_(other.contents_) {} thinknode_calc_request(thinknode_calc_request&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_calc_request& operator=(thinknode_calc_request const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_calc_request& operator=(thinknode_calc_request&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_calc_request> {     static void     get(cradle::api_type_info*); }; thinknode_calc_request make_thinknode_calc_request_with_reference(std::string const& x); thinknode_calc_request make_thinknode_calc_request_with_reference(std::string&& x); thinknode_calc_request make_thinknode_calc_request_with_value(dynamic const& x); thinknode_calc_request make_thinknode_calc_request_with_value(dynamic&& x); thinknode_calc_request make_thinknode_calc_request_with_function(thinknode_function_application const& x); thinknode_calc_request make_thinknode_calc_request_with_function(thinknode_function_application&& x); thinknode_calc_request make_thinknode_calc_request_with_array(thinknode_array_calc const& x); thinknode_calc_request make_thinknode_calc_request_with_array(thinknode_array_calc&& x); thinknode_calc_request make_thinknode_calc_request_with_item(thinknode_item_calc const& x); thinknode_calc_request make_thinknode_calc_request_with_item(thinknode_item_calc&& x); thinknode_calc_request make_thinknode_calc_request_with_object(thinknode_object_calc const& x); thinknode_calc_request make_thinknode_calc_request_with_object(thinknode_object_calc&& x); thinknode_calc_request make_thinknode_calc_request_with_property(thinknode_property_calc const& x); thinknode_calc_request make_thinknode_calc_request_with_property(thinknode_property_calc&& x); thinknode_calc_request make_thinknode_calc_request_with_let(thinknode_let_calc const& x); thinknode_calc_request make_thinknode_calc_request_with_let(thinknode_let_calc&& x); thinknode_calc_request make_thinknode_calc_request_with_variable(std::string const& x); thinknode_calc_request make_thinknode_calc_request_with_variable(std::string&& x); thinknode_calc_request make_thinknode_calc_request_with_meta(thinknode_meta_calc const& x); thinknode_calc_request make_thinknode_calc_request_with_meta(thinknode_meta_calc&& x); thinknode_calc_request make_thinknode_calc_request_with_cast(thinknode_cast_request const& x); thinknode_calc_request make_thinknode_calc_request_with_cast(thinknode_cast_request&& x); static inline thinknode_calc_request_tag  get_tag(thinknode_calc_request const& x) { return x.type; } bool static inline is_reference(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::REFERENCE; } bool static inline is_value(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::VALUE; } bool static inline is_function(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::FUNCTION; } bool static inline is_array(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::ARRAY; } bool static inline is_item(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::ITEM; } bool static inline is_object(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::OBJECT; } bool static inline is_property(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::PROPERTY; } bool static inline is_let(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::LET; } bool static inline is_variable(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::VARIABLE; } bool static inline is_meta(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::META; } bool static inline is_cast(thinknode_calc_request const& x) { return x.type == thinknode_calc_request_tag::CAST; } std::string const& as_reference(thinknode_calc_request const& x); dynamic const& as_value(thinknode_calc_request const& x); thinknode_function_application const& as_function(thinknode_calc_request const& x); thinknode_array_calc const& as_array(thinknode_calc_request const& x); thinknode_item_calc const& as_item(thinknode_calc_request const& x); thinknode_object_calc const& as_object(thinknode_calc_request const& x); thinknode_property_calc const& as_property(thinknode_calc_request const& x); thinknode_let_calc const& as_let(thinknode_calc_request const& x); std::string const& as_variable(thinknode_calc_request const& x); thinknode_meta_calc const& as_meta(thinknode_calc_request const& x); thinknode_cast_request const& as_cast(thinknode_calc_request const& x); std::string& as_reference(thinknode_calc_request& x); dynamic& as_value(thinknode_calc_request& x); thinknode_function_application& as_function(thinknode_calc_request& x); thinknode_array_calc& as_array(thinknode_calc_request& x); thinknode_item_calc& as_item(thinknode_calc_request& x); thinknode_object_calc& as_object(thinknode_calc_request& x); thinknode_property_calc& as_property(thinknode_calc_request& x); thinknode_let_calc& as_let(thinknode_calc_request& x); std::string& as_variable(thinknode_calc_request& x); thinknode_meta_calc& as_meta(thinknode_calc_request& x); thinknode_cast_request& as_cast(thinknode_calc_request& x); void set_to_reference(thinknode_calc_request& x, std::string const& y); void set_to_reference(thinknode_calc_request& x, std::string&& y); void set_to_value(thinknode_calc_request& x, dynamic const& y); void set_to_value(thinknode_calc_request& x, dynamic&& y); void set_to_function(thinknode_calc_request& x, thinknode_function_application const& y); void set_to_function(thinknode_calc_request& x, thinknode_function_application&& y); void set_to_array(thinknode_calc_request& x, thinknode_array_calc const& y); void set_to_array(thinknode_calc_request& x, thinknode_array_calc&& y); void set_to_item(thinknode_calc_request& x, thinknode_item_calc const& y); void set_to_item(thinknode_calc_request& x, thinknode_item_calc&& y); void set_to_object(thinknode_calc_request& x, thinknode_object_calc const& y); void set_to_object(thinknode_calc_request& x, thinknode_object_calc&& y); void set_to_property(thinknode_calc_request& x, thinknode_property_calc const& y); void set_to_property(thinknode_calc_request& x, thinknode_property_calc&& y); void set_to_let(thinknode_calc_request& x, thinknode_let_calc const& y); void set_to_let(thinknode_calc_request& x, thinknode_let_calc&& y); void set_to_variable(thinknode_calc_request& x, std::string const& y); void set_to_variable(thinknode_calc_request& x, std::string&& y); void set_to_meta(thinknode_calc_request& x, thinknode_meta_calc const& y); void set_to_meta(thinknode_calc_request& x, thinknode_meta_calc&& y); void set_to_cast(thinknode_calc_request& x, thinknode_cast_request const& y); void set_to_cast(thinknode_calc_request& x, thinknode_cast_request&& y); bool operator==(thinknode_calc_request const& a, thinknode_calc_request const& b); bool operator!=(thinknode_calc_request const& a, thinknode_calc_request const& b); bool operator<(thinknode_calc_request const& a, thinknode_calc_request const& b); size_t hash_value(thinknode_calc_request const& x);void swap(thinknode_calc_request& a, thinknode_calc_request& b); void to_dynamic(cradle::dynamic* v, thinknode_calc_request const& x); void from_dynamic(thinknode_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_calc_request const& x); size_t deep_sizeof(thinknode_calc_request const& x); 

#line 91 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_function_application { std::string account;  std::string app;  std::string name;  omissible<cradle::integer > level;  std::vector<cradle::thinknode_calc_request > args;  thinknode_function_application() {} thinknode_function_application(std::string const& account, std::string const& app, std::string const& name, omissible<cradle::integer > const& level, std::vector<cradle::thinknode_calc_request > const& args) : account(account), app(app), name(name), level(level), args(args) {} };  inline thinknode_function_application make_thinknode_function_application(  std::string account, std::string app, std::string name, omissible<cradle::integer > level, std::vector<cradle::thinknode_calc_request > args ) { return thinknode_function_application(  std::move(account), std::move(app), std::move(name), std::move(level), std::move(args) ); }template<> struct definitive_type_info_query<thinknode_function_application> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_application> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_function_application> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_function_application const& a, thinknode_function_application const& b); bool operator!=(thinknode_function_application const& a, thinknode_function_application const& b); bool operator<(thinknode_function_application const& a, thinknode_function_application const& b); void swap(thinknode_function_application& a, thinknode_function_application& b); size_t deep_sizeof(thinknode_function_application const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_application const& x); void to_dynamic(cradle::dynamic* v, thinknode_function_application const& x); void read_fields_from_record(thinknode_function_application& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_function_application* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_function_application const& x);std::ostream& operator<<(std::ostream& s, thinknode_function_application const& x);size_t hash_value(thinknode_function_application const& x);} namespace cradle { 

#line 101 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_array_calc { std::vector<cradle::thinknode_calc_request > items;  cradle::thinknode_type_info item_schema;  thinknode_array_calc() {} thinknode_array_calc(std::vector<cradle::thinknode_calc_request > const& items, cradle::thinknode_type_info const& item_schema) : items(items), item_schema(item_schema) {} };  inline thinknode_array_calc make_thinknode_array_calc(  std::vector<cradle::thinknode_calc_request > items, cradle::thinknode_type_info item_schema ) { return thinknode_array_calc(  std::move(items), std::move(item_schema) ); }template<> struct definitive_type_info_query<thinknode_array_calc> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_array_calc> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_array_calc> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_array_calc const& a, thinknode_array_calc const& b); bool operator!=(thinknode_array_calc const& a, thinknode_array_calc const& b); bool operator<(thinknode_array_calc const& a, thinknode_array_calc const& b); void swap(thinknode_array_calc& a, thinknode_array_calc& b); size_t deep_sizeof(thinknode_array_calc const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_array_calc const& x); void to_dynamic(cradle::dynamic* v, thinknode_array_calc const& x); void read_fields_from_record(thinknode_array_calc& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_array_calc* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_array_calc const& x);std::ostream& operator<<(std::ostream& s, thinknode_array_calc const& x);size_t hash_value(thinknode_array_calc const& x);} namespace cradle { 

#line 108 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_object_calc { std::map<std::string,cradle::thinknode_calc_request > properties;  cradle::thinknode_type_info schema;  thinknode_object_calc() {} thinknode_object_calc(std::map<std::string,cradle::thinknode_calc_request > const& properties, cradle::thinknode_type_info const& schema) : properties(properties), schema(schema) {} };  inline thinknode_object_calc make_thinknode_object_calc(  std::map<std::string,cradle::thinknode_calc_request > properties, cradle::thinknode_type_info schema ) { return thinknode_object_calc(  std::move(properties), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_object_calc> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_object_calc> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_object_calc> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_object_calc const& a, thinknode_object_calc const& b); bool operator!=(thinknode_object_calc const& a, thinknode_object_calc const& b); bool operator<(thinknode_object_calc const& a, thinknode_object_calc const& b); void swap(thinknode_object_calc& a, thinknode_object_calc& b); size_t deep_sizeof(thinknode_object_calc const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_object_calc const& x); void to_dynamic(cradle::dynamic* v, thinknode_object_calc const& x); void read_fields_from_record(thinknode_object_calc& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_object_calc* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_object_calc const& x);std::ostream& operator<<(std::ostream& s, thinknode_object_calc const& x);size_t hash_value(thinknode_object_calc const& x);} namespace cradle { 

#line 115 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_item_calc { cradle::thinknode_calc_request array;  cradle::thinknode_calc_request index;  cradle::thinknode_type_info schema;  thinknode_item_calc() {} thinknode_item_calc(cradle::thinknode_calc_request const& array, cradle::thinknode_calc_request const& index, cradle::thinknode_type_info const& schema) : array(array), index(index), schema(schema) {} };  inline thinknode_item_calc make_thinknode_item_calc(  cradle::thinknode_calc_request array, cradle::thinknode_calc_request index, cradle::thinknode_type_info schema ) { return thinknode_item_calc(  std::move(array), std::move(index), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_item_calc> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_item_calc> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_item_calc> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_item_calc const& a, thinknode_item_calc const& b); bool operator!=(thinknode_item_calc const& a, thinknode_item_calc const& b); bool operator<(thinknode_item_calc const& a, thinknode_item_calc const& b); void swap(thinknode_item_calc& a, thinknode_item_calc& b); size_t deep_sizeof(thinknode_item_calc const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_item_calc const& x); void to_dynamic(cradle::dynamic* v, thinknode_item_calc const& x); void read_fields_from_record(thinknode_item_calc& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_item_calc* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_item_calc const& x);std::ostream& operator<<(std::ostream& s, thinknode_item_calc const& x);size_t hash_value(thinknode_item_calc const& x);} namespace cradle { 

#line 123 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_property_calc { cradle::thinknode_calc_request object;  cradle::thinknode_calc_request field;  cradle::thinknode_type_info schema;  thinknode_property_calc() {} thinknode_property_calc(cradle::thinknode_calc_request const& object, cradle::thinknode_calc_request const& field, cradle::thinknode_type_info const& schema) : object(object), field(field), schema(schema) {} };  inline thinknode_property_calc make_thinknode_property_calc(  cradle::thinknode_calc_request object, cradle::thinknode_calc_request field, cradle::thinknode_type_info schema ) { return thinknode_property_calc(  std::move(object), std::move(field), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_property_calc> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_property_calc> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_property_calc> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_property_calc const& a, thinknode_property_calc const& b); bool operator!=(thinknode_property_calc const& a, thinknode_property_calc const& b); bool operator<(thinknode_property_calc const& a, thinknode_property_calc const& b); void swap(thinknode_property_calc& a, thinknode_property_calc& b); size_t deep_sizeof(thinknode_property_calc const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_property_calc const& x); void to_dynamic(cradle::dynamic* v, thinknode_property_calc const& x); void read_fields_from_record(thinknode_property_calc& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_property_calc* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_property_calc const& x);std::ostream& operator<<(std::ostream& s, thinknode_property_calc const& x);size_t hash_value(thinknode_property_calc const& x);} namespace cradle { 

#line 131 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_meta_calc { cradle::thinknode_calc_request generator;  cradle::thinknode_type_info schema;  thinknode_meta_calc() {} thinknode_meta_calc(cradle::thinknode_calc_request const& generator, cradle::thinknode_type_info const& schema) : generator(generator), schema(schema) {} };  inline thinknode_meta_calc make_thinknode_meta_calc(  cradle::thinknode_calc_request generator, cradle::thinknode_type_info schema ) { return thinknode_meta_calc(  std::move(generator), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_meta_calc> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_meta_calc> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_meta_calc> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_meta_calc const& a, thinknode_meta_calc const& b); bool operator!=(thinknode_meta_calc const& a, thinknode_meta_calc const& b); bool operator<(thinknode_meta_calc const& a, thinknode_meta_calc const& b); void swap(thinknode_meta_calc& a, thinknode_meta_calc& b); size_t deep_sizeof(thinknode_meta_calc const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_meta_calc const& x); void to_dynamic(cradle::dynamic* v, thinknode_meta_calc const& x); void read_fields_from_record(thinknode_meta_calc& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_meta_calc* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_meta_calc const& x);std::ostream& operator<<(std::ostream& s, thinknode_meta_calc const& x);size_t hash_value(thinknode_meta_calc const& x);} namespace cradle { 

#line 138 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_cast_request { cradle::thinknode_type_info schema;  cradle::thinknode_calc_request object;  thinknode_cast_request() {} thinknode_cast_request(cradle::thinknode_type_info const& schema, cradle::thinknode_calc_request const& object) : schema(schema), object(object) {} };  inline thinknode_cast_request make_thinknode_cast_request(  cradle::thinknode_type_info schema, cradle::thinknode_calc_request object ) { return thinknode_cast_request(  std::move(schema), std::move(object) ); }template<> struct definitive_type_info_query<thinknode_cast_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_cast_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_cast_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_cast_request const& a, thinknode_cast_request const& b); bool operator!=(thinknode_cast_request const& a, thinknode_cast_request const& b); bool operator<(thinknode_cast_request const& a, thinknode_cast_request const& b); void swap(thinknode_cast_request& a, thinknode_cast_request& b); size_t deep_sizeof(thinknode_cast_request const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_cast_request const& x); void to_dynamic(cradle::dynamic* v, thinknode_cast_request const& x); void read_fields_from_record(thinknode_cast_request& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_cast_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_cast_request const& x);std::ostream& operator<<(std::ostream& s, thinknode_cast_request const& x);size_t hash_value(thinknode_cast_request const& x);} namespace cradle { 

#line 145 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_let_calc { std::map<std::string,cradle::thinknode_calc_request > variables;  cradle::thinknode_calc_request in;  thinknode_let_calc() {} thinknode_let_calc(std::map<std::string,cradle::thinknode_calc_request > const& variables, cradle::thinknode_calc_request const& in) : variables(variables), in(in) {} };  inline thinknode_let_calc make_thinknode_let_calc(  std::map<std::string,cradle::thinknode_calc_request > variables, cradle::thinknode_calc_request in ) { return thinknode_let_calc(  std::move(variables), std::move(in) ); }template<> struct definitive_type_info_query<thinknode_let_calc> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_let_calc> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_let_calc> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_let_calc const& a, thinknode_let_calc const& b); bool operator!=(thinknode_let_calc const& a, thinknode_let_calc const& b); bool operator<(thinknode_let_calc const& a, thinknode_let_calc const& b); void swap(thinknode_let_calc& a, thinknode_let_calc& b); size_t deep_sizeof(thinknode_let_calc const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_let_calc const& x); void to_dynamic(cradle::dynamic* v, thinknode_let_calc const& x); void read_fields_from_record(thinknode_let_calc& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_let_calc* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_let_calc const& x);std::ostream& operator<<(std::ostream& s, thinknode_let_calc const& x);size_t hash_value(thinknode_let_calc const& x);} namespace cradle { 

#line 152 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct id_response { std::string id;  id_response() {} explicit id_response(std::string const& id) : id(id) {} };  inline id_response make_id_response(  std::string id ) { return id_response(  std::move(id) ); }template<> struct definitive_type_info_query<id_response> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<id_response> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<id_response> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(id_response const& a, id_response const& b); bool operator!=(id_response const& a, id_response const& b); bool operator<(id_response const& a, id_response const& b); void swap(id_response& a, id_response& b); size_t deep_sizeof(id_response const& x); void write_fields_to_record(cradle::dynamic_map& record, id_response const& x); void to_dynamic(cradle::dynamic* v, id_response const& x); void read_fields_from_record(id_response& x, cradle::dynamic_map const& record); void from_dynamic(id_response* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, id_response const& x);std::ostream& operator<<(std::ostream& s, id_response const& x);size_t hash_value(id_response const& x);} namespace cradle { 

#line 159 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct reported_calculation_info { std::string id;  std::string label;  reported_calculation_info() {} reported_calculation_info(std::string const& id, std::string const& label) : id(id), label(label) {} };  inline reported_calculation_info make_reported_calculation_info(  std::string id, std::string label ) { return reported_calculation_info(  std::move(id), std::move(label) ); }template<> struct definitive_type_info_query<reported_calculation_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<reported_calculation_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<reported_calculation_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(reported_calculation_info const& a, reported_calculation_info const& b); bool operator!=(reported_calculation_info const& a, reported_calculation_info const& b); bool operator<(reported_calculation_info const& a, reported_calculation_info const& b); void swap(reported_calculation_info& a, reported_calculation_info& b); size_t deep_sizeof(reported_calculation_info const& x); void write_fields_to_record(cradle::dynamic_map& record, reported_calculation_info const& x); void to_dynamic(cradle::dynamic* v, reported_calculation_info const& x); void read_fields_from_record(reported_calculation_info& x, cradle::dynamic_map const& record); void from_dynamic(reported_calculation_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, reported_calculation_info const& x);std::ostream& operator<<(std::ostream& s, reported_calculation_info const& x);size_t hash_value(reported_calculation_info const& x);} namespace cradle { 

#line 168 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct let_calculation_submission_info { std::string main_calc_id;  std::vector<cradle::reported_calculation_info > reported_subcalcs;  std::vector<std::string > other_subcalc_ids;  let_calculation_submission_info() {} let_calculation_submission_info(std::string const& main_calc_id, std::vector<cradle::reported_calculation_info > const& reported_subcalcs, std::vector<std::string > const& other_subcalc_ids) : main_calc_id(main_calc_id), reported_subcalcs(reported_subcalcs), other_subcalc_ids(other_subcalc_ids) {} };  inline let_calculation_submission_info make_let_calculation_submission_info(  std::string main_calc_id, std::vector<cradle::reported_calculation_info > reported_subcalcs, std::vector<std::string > other_subcalc_ids ) { return let_calculation_submission_info(  std::move(main_calc_id), std::move(reported_subcalcs), std::move(other_subcalc_ids) ); }template<> struct definitive_type_info_query<let_calculation_submission_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<let_calculation_submission_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<let_calculation_submission_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(let_calculation_submission_info const& a, let_calculation_submission_info const& b); bool operator!=(let_calculation_submission_info const& a, let_calculation_submission_info const& b); bool operator<(let_calculation_submission_info const& a, let_calculation_submission_info const& b); void swap(let_calculation_submission_info& a, let_calculation_submission_info& b); size_t deep_sizeof(let_calculation_submission_info const& x); void write_fields_to_record(cradle::dynamic_map& record, let_calculation_submission_info const& x); void to_dynamic(cradle::dynamic* v, let_calculation_submission_info const& x); void read_fields_from_record(let_calculation_submission_info& x, cradle::dynamic_map const& record); void from_dynamic(let_calculation_submission_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, let_calculation_submission_info const& x);std::ostream& operator<<(std::ostream& s, let_calculation_submission_info const& x);size_t hash_value(let_calculation_submission_info const& x);} namespace cradle { 

#line 179 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct augmented_calculation_request { cradle::thinknode_calc_request request;  std::vector<std::string > reported_variables;  augmented_calculation_request() {} augmented_calculation_request(cradle::thinknode_calc_request const& request, std::vector<std::string > const& reported_variables) : request(request), reported_variables(reported_variables) {} };  inline augmented_calculation_request make_augmented_calculation_request(  cradle::thinknode_calc_request request, std::vector<std::string > reported_variables ) { return augmented_calculation_request(  std::move(request), std::move(reported_variables) ); }template<> struct definitive_type_info_query<augmented_calculation_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<augmented_calculation_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<augmented_calculation_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(augmented_calculation_request const& a, augmented_calculation_request const& b); bool operator!=(augmented_calculation_request const& a, augmented_calculation_request const& b); bool operator<(augmented_calculation_request const& a, augmented_calculation_request const& b); void swap(augmented_calculation_request& a, augmented_calculation_request& b); size_t deep_sizeof(augmented_calculation_request const& x); void write_fields_to_record(cradle::dynamic_map& record, augmented_calculation_request const& x); void to_dynamic(cradle::dynamic* v, augmented_calculation_request const& x); void read_fields_from_record(augmented_calculation_request& x, cradle::dynamic_map const& record); void from_dynamic(augmented_calculation_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, augmented_calculation_request const& x);std::ostream& operator<<(std::ostream& s, augmented_calculation_request const& x);size_t hash_value(augmented_calculation_request const& x);} namespace cradle { 


#ifdef PENDING 
    #undef PENDING 
#endif 

#ifdef READY 
    #undef READY 
#endif 
#line 190 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class calculation_queue_type { PENDING,READY }; template<> struct definitive_type_info_query<calculation_queue_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_queue_type> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<calculation_queue_type> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(calculation_queue_type) { return sizeof(calculation_queue_type); } inline size_t hash_value(calculation_queue_type const& x) {     return size_t(x); }static inline unsigned get_value_count(calculation_queue_type) { return 2; } char const* get_value_id(calculation_queue_type value); void to_dynamic(     cradle::dynamic* v,     calculation_queue_type x); void from_dynamic(     calculation_queue_type* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      calculation_queue_type const& x); 

#line 197 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct calculation_calculating_status { double progress;  calculation_calculating_status() {} explicit calculation_calculating_status(double const& progress) : progress(progress) {} };  inline calculation_calculating_status make_calculation_calculating_status(  double progress ) { return calculation_calculating_status(  std::move(progress) ); }template<> struct definitive_type_info_query<calculation_calculating_status> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_calculating_status> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<calculation_calculating_status> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(calculation_calculating_status const& a, calculation_calculating_status const& b); bool operator!=(calculation_calculating_status const& a, calculation_calculating_status const& b); bool operator<(calculation_calculating_status const& a, calculation_calculating_status const& b); void swap(calculation_calculating_status& a, calculation_calculating_status& b); size_t deep_sizeof(calculation_calculating_status const& x); void write_fields_to_record(cradle::dynamic_map& record, calculation_calculating_status const& x); void to_dynamic(cradle::dynamic* v, calculation_calculating_status const& x); void read_fields_from_record(calculation_calculating_status& x, cradle::dynamic_map const& record); void from_dynamic(calculation_calculating_status* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, calculation_calculating_status const& x);std::ostream& operator<<(std::ostream& s, calculation_calculating_status const& x);size_t hash_value(calculation_calculating_status const& x);} namespace cradle { 

#line 203 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct calculation_uploading_status { double progress;  calculation_uploading_status() {} explicit calculation_uploading_status(double const& progress) : progress(progress) {} };  inline calculation_uploading_status make_calculation_uploading_status(  double progress ) { return calculation_uploading_status(  std::move(progress) ); }template<> struct definitive_type_info_query<calculation_uploading_status> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_uploading_status> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<calculation_uploading_status> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(calculation_uploading_status const& a, calculation_uploading_status const& b); bool operator!=(calculation_uploading_status const& a, calculation_uploading_status const& b); bool operator<(calculation_uploading_status const& a, calculation_uploading_status const& b); void swap(calculation_uploading_status& a, calculation_uploading_status& b); size_t deep_sizeof(calculation_uploading_status const& x); void write_fields_to_record(cradle::dynamic_map& record, calculation_uploading_status const& x); void to_dynamic(cradle::dynamic* v, calculation_uploading_status const& x); void read_fields_from_record(calculation_uploading_status& x, cradle::dynamic_map const& record); void from_dynamic(calculation_uploading_status* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, calculation_uploading_status const& x);std::ostream& operator<<(std::ostream& s, calculation_uploading_status const& x);size_t hash_value(calculation_uploading_status const& x);} namespace cradle { 

#line 209 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct calculation_failure_status { std::string code;  std::string error;  std::string message;  calculation_failure_status() {} calculation_failure_status(std::string const& code, std::string const& error, std::string const& message) : code(code), error(error), message(message) {} };  inline calculation_failure_status make_calculation_failure_status(  std::string code, std::string error, std::string message ) { return calculation_failure_status(  std::move(code), std::move(error), std::move(message) ); }template<> struct definitive_type_info_query<calculation_failure_status> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_failure_status> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<calculation_failure_status> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(calculation_failure_status const& a, calculation_failure_status const& b); bool operator!=(calculation_failure_status const& a, calculation_failure_status const& b); bool operator<(calculation_failure_status const& a, calculation_failure_status const& b); void swap(calculation_failure_status& a, calculation_failure_status& b); size_t deep_sizeof(calculation_failure_status const& x); void write_fields_to_record(cradle::dynamic_map& record, calculation_failure_status const& x); void to_dynamic(cradle::dynamic* v, calculation_failure_status const& x); void read_fields_from_record(calculation_failure_status& x, cradle::dynamic_map const& record); void from_dynamic(calculation_failure_status* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, calculation_failure_status const& x);std::ostream& operator<<(std::ostream& s, calculation_failure_status const& x);size_t hash_value(calculation_failure_status const& x);} namespace cradle { 


#ifdef CALCULATING 
    #undef CALCULATING 
#endif 

#ifdef CANCELED 
    #undef CANCELED 
#endif 

#ifdef COMPLETED 
    #undef COMPLETED 
#endif 

#ifdef FAILED 
    #undef FAILED 
#endif 

#ifdef GENERATING 
    #undef GENERATING 
#endif 

#ifdef QUEUED 
    #undef QUEUED 
#endif 

#ifdef UPLOADING 
    #undef UPLOADING 
#endif 

#ifdef WAITING 
    #undef WAITING 
#endif 
#line 217 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class calculation_status_tag { CALCULATING,CANCELED,COMPLETED,FAILED,GENERATING,QUEUED,UPLOADING,WAITING }; template<> struct definitive_type_info_query<calculation_status_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_status_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<calculation_status_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(calculation_status_tag) { return sizeof(calculation_status_tag); } inline size_t hash_value(calculation_status_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(calculation_status_tag) { return 8; } char const* get_value_id(calculation_status_tag value); void to_dynamic(     cradle::dynamic* v,     calculation_status_tag x); void from_dynamic(     calculation_status_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      calculation_status_tag const& x); struct calculation_status { calculation_status_tag type; std::any contents_; calculation_status() {} calculation_status(calculation_status const& other) : type(other.type), contents_(other.contents_) {} calculation_status(calculation_status&& other) : type(other.type), contents_(std::move(other.contents_)) {} calculation_status& operator=(calculation_status const& other) { type = other.type; contents_ = other.contents_; return *this; } calculation_status& operator=(calculation_status&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<calculation_status> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_status> {     static void     get(cradle::api_type_info*); }; calculation_status make_calculation_status_with_calculating(calculation_calculating_status const& x); calculation_status make_calculation_status_with_calculating(calculation_calculating_status&& x); calculation_status make_calculation_status_with_canceled(nil_t const& x); calculation_status make_calculation_status_with_canceled(nil_t&& x); calculation_status make_calculation_status_with_completed(nil_t const& x); calculation_status make_calculation_status_with_completed(nil_t&& x); calculation_status make_calculation_status_with_failed(calculation_failure_status const& x); calculation_status make_calculation_status_with_failed(calculation_failure_status&& x); calculation_status make_calculation_status_with_generating(nil_t const& x); calculation_status make_calculation_status_with_generating(nil_t&& x); calculation_status make_calculation_status_with_queued(calculation_queue_type const& x); calculation_status make_calculation_status_with_queued(calculation_queue_type&& x); calculation_status make_calculation_status_with_uploading(calculation_uploading_status const& x); calculation_status make_calculation_status_with_uploading(calculation_uploading_status&& x); calculation_status make_calculation_status_with_waiting(nil_t const& x); calculation_status make_calculation_status_with_waiting(nil_t&& x); static inline calculation_status_tag  get_tag(calculation_status const& x) { return x.type; } bool static inline is_calculating(calculation_status const& x) { return x.type == calculation_status_tag::CALCULATING; } bool static inline is_canceled(calculation_status const& x) { return x.type == calculation_status_tag::CANCELED; } bool static inline is_completed(calculation_status const& x) { return x.type == calculation_status_tag::COMPLETED; } bool static inline is_failed(calculation_status const& x) { return x.type == calculation_status_tag::FAILED; } bool static inline is_generating(calculation_status const& x) { return x.type == calculation_status_tag::GENERATING; } bool static inline is_queued(calculation_status const& x) { return x.type == calculation_status_tag::QUEUED; } bool static inline is_uploading(calculation_status const& x) { return x.type == calculation_status_tag::UPLOADING; } bool static inline is_waiting(calculation_status const& x) { return x.type == calculation_status_tag::WAITING; } calculation_calculating_status const& as_calculating(calculation_status const& x); nil_t const& as_canceled(calculation_status const& x); nil_t const& as_completed(calculation_status const& x); calculation_failure_status const& as_failed(calculation_status const& x); nil_t const& as_generating(calculation_status const& x); calculation_queue_type const& as_queued(calculation_status const& x); calculation_uploading_status const& as_uploading(calculation_status const& x); nil_t const& as_waiting(calculation_status const& x); calculation_calculating_status& as_calculating(calculation_status& x); nil_t& as_canceled(calculation_status& x); nil_t& as_completed(calculation_status& x); calculation_failure_status& as_failed(calculation_status& x); nil_t& as_generating(calculation_status& x); calculation_queue_type& as_queued(calculation_status& x); calculation_uploading_status& as_uploading(calculation_status& x); nil_t& as_waiting(calculation_status& x); void set_to_calculating(calculation_status& x, calculation_calculating_status const& y); void set_to_calculating(calculation_status& x, calculation_calculating_status&& y); void set_to_canceled(calculation_status& x, nil_t const& y); void set_to_canceled(calculation_status& x, nil_t&& y); void set_to_completed(calculation_status& x, nil_t const& y); void set_to_completed(calculation_status& x, nil_t&& y); void set_to_failed(calculation_status& x, calculation_failure_status const& y); void set_to_failed(calculation_status& x, calculation_failure_status&& y); void set_to_generating(calculation_status& x, nil_t const& y); void set_to_generating(calculation_status& x, nil_t&& y); void set_to_queued(calculation_status& x, calculation_queue_type const& y); void set_to_queued(calculation_status& x, calculation_queue_type&& y); void set_to_uploading(calculation_status& x, calculation_uploading_status const& y); void set_to_uploading(calculation_status& x, calculation_uploading_status&& y); void set_to_waiting(calculation_status& x, nil_t const& y); void set_to_waiting(calculation_status& x, nil_t&& y); bool operator==(calculation_status const& a, calculation_status const& b); bool operator!=(calculation_status const& a, calculation_status const& b); bool operator<(calculation_status const& a, calculation_status const& b); size_t hash_value(calculation_status const& x);void swap(calculation_status& a, calculation_status& b); void to_dynamic(cradle::dynamic* v, calculation_status const& x); void from_dynamic(calculation_status* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, calculation_status const& x); size_t deep_sizeof(calculation_status const& x); 

#line 230 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_nil_type {  thinknode_nil_type() {} };  inline thinknode_nil_type make_thinknode_nil_type(   ) { return thinknode_nil_type(   ); }template<> struct definitive_type_info_query<thinknode_nil_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_nil_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_nil_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_nil_type const& a, thinknode_nil_type const& b); bool operator!=(thinknode_nil_type const& a, thinknode_nil_type const& b); bool operator<(thinknode_nil_type const& a, thinknode_nil_type const& b); void swap(thinknode_nil_type& a, thinknode_nil_type& b); size_t deep_sizeof(thinknode_nil_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_nil_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_nil_type const& x); void read_fields_from_record(thinknode_nil_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_nil_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_nil_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_nil_type const& x);size_t hash_value(thinknode_nil_type const& x);} namespace cradle { 

#line 235 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_boolean_type {  thinknode_boolean_type() {} };  inline thinknode_boolean_type make_thinknode_boolean_type(   ) { return thinknode_boolean_type(   ); }template<> struct definitive_type_info_query<thinknode_boolean_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_boolean_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_boolean_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_boolean_type const& a, thinknode_boolean_type const& b); bool operator!=(thinknode_boolean_type const& a, thinknode_boolean_type const& b); bool operator<(thinknode_boolean_type const& a, thinknode_boolean_type const& b); void swap(thinknode_boolean_type& a, thinknode_boolean_type& b); size_t deep_sizeof(thinknode_boolean_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_boolean_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_boolean_type const& x); void read_fields_from_record(thinknode_boolean_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_boolean_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_boolean_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_boolean_type const& x);size_t hash_value(thinknode_boolean_type const& x);} namespace cradle { 

#line 240 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_integer_type {  thinknode_integer_type() {} };  inline thinknode_integer_type make_thinknode_integer_type(   ) { return thinknode_integer_type(   ); }template<> struct definitive_type_info_query<thinknode_integer_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_integer_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_integer_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_integer_type const& a, thinknode_integer_type const& b); bool operator!=(thinknode_integer_type const& a, thinknode_integer_type const& b); bool operator<(thinknode_integer_type const& a, thinknode_integer_type const& b); void swap(thinknode_integer_type& a, thinknode_integer_type& b); size_t deep_sizeof(thinknode_integer_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_integer_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_integer_type const& x); void read_fields_from_record(thinknode_integer_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_integer_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_integer_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_integer_type const& x);size_t hash_value(thinknode_integer_type const& x);} namespace cradle { 

#line 245 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_float_type {  thinknode_float_type() {} };  inline thinknode_float_type make_thinknode_float_type(   ) { return thinknode_float_type(   ); }template<> struct definitive_type_info_query<thinknode_float_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_float_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_float_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_float_type const& a, thinknode_float_type const& b); bool operator!=(thinknode_float_type const& a, thinknode_float_type const& b); bool operator<(thinknode_float_type const& a, thinknode_float_type const& b); void swap(thinknode_float_type& a, thinknode_float_type& b); size_t deep_sizeof(thinknode_float_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_float_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_float_type const& x); void read_fields_from_record(thinknode_float_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_float_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_float_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_float_type const& x);size_t hash_value(thinknode_float_type const& x);} namespace cradle { 

#line 250 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_string_type {  thinknode_string_type() {} };  inline thinknode_string_type make_thinknode_string_type(   ) { return thinknode_string_type(   ); }template<> struct definitive_type_info_query<thinknode_string_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_string_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_string_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_string_type const& a, thinknode_string_type const& b); bool operator!=(thinknode_string_type const& a, thinknode_string_type const& b); bool operator<(thinknode_string_type const& a, thinknode_string_type const& b); void swap(thinknode_string_type& a, thinknode_string_type& b); size_t deep_sizeof(thinknode_string_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_string_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_string_type const& x); void read_fields_from_record(thinknode_string_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_string_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_string_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_string_type const& x);size_t hash_value(thinknode_string_type const& x);} namespace cradle { 

#line 255 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_datetime_type {  thinknode_datetime_type() {} };  inline thinknode_datetime_type make_thinknode_datetime_type(   ) { return thinknode_datetime_type(   ); }template<> struct definitive_type_info_query<thinknode_datetime_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_datetime_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_datetime_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_datetime_type const& a, thinknode_datetime_type const& b); bool operator!=(thinknode_datetime_type const& a, thinknode_datetime_type const& b); bool operator<(thinknode_datetime_type const& a, thinknode_datetime_type const& b); void swap(thinknode_datetime_type& a, thinknode_datetime_type& b); size_t deep_sizeof(thinknode_datetime_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_datetime_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_datetime_type const& x); void read_fields_from_record(thinknode_datetime_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_datetime_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_datetime_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_datetime_type const& x);size_t hash_value(thinknode_datetime_type const& x);} namespace cradle { 

#line 260 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_blob_type {  thinknode_blob_type() {} };  inline thinknode_blob_type make_thinknode_blob_type(   ) { return thinknode_blob_type(   ); }template<> struct definitive_type_info_query<thinknode_blob_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_blob_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_blob_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_blob_type const& a, thinknode_blob_type const& b); bool operator!=(thinknode_blob_type const& a, thinknode_blob_type const& b); bool operator<(thinknode_blob_type const& a, thinknode_blob_type const& b); void swap(thinknode_blob_type& a, thinknode_blob_type& b); size_t deep_sizeof(thinknode_blob_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_blob_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_blob_type const& x); void read_fields_from_record(thinknode_blob_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_blob_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_blob_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_blob_type const& x);size_t hash_value(thinknode_blob_type const& x);} namespace cradle { 

#line 265 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_dynamic_type {  thinknode_dynamic_type() {} };  inline thinknode_dynamic_type make_thinknode_dynamic_type(   ) { return thinknode_dynamic_type(   ); }template<> struct definitive_type_info_query<thinknode_dynamic_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_dynamic_type> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_dynamic_type> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_dynamic_type const& a, thinknode_dynamic_type const& b); bool operator!=(thinknode_dynamic_type const& a, thinknode_dynamic_type const& b); bool operator<(thinknode_dynamic_type const& a, thinknode_dynamic_type const& b); void swap(thinknode_dynamic_type& a, thinknode_dynamic_type& b); size_t deep_sizeof(thinknode_dynamic_type const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_dynamic_type const& x); void to_dynamic(cradle::dynamic* v, thinknode_dynamic_type const& x); void read_fields_from_record(thinknode_dynamic_type& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_dynamic_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_dynamic_type const& x);std::ostream& operator<<(std::ostream& s, thinknode_dynamic_type const& x);size_t hash_value(thinknode_dynamic_type const& x);} namespace cradle { 

#line 270 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_structure_field_info { std::string description;  cradle::omissible<bool > omissible;  cradle::thinknode_type_info schema;  thinknode_structure_field_info() {} thinknode_structure_field_info(std::string const& description, cradle::omissible<bool > const& omissible, cradle::thinknode_type_info const& schema) : description(description), omissible(omissible), schema(schema) {} };  inline thinknode_structure_field_info make_thinknode_structure_field_info(  std::string description, cradle::omissible<bool > omissible, cradle::thinknode_type_info schema ) { return thinknode_structure_field_info(  std::move(description), std::move(omissible), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_structure_field_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_structure_field_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_structure_field_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_structure_field_info const& a, thinknode_structure_field_info const& b); bool operator!=(thinknode_structure_field_info const& a, thinknode_structure_field_info const& b); bool operator<(thinknode_structure_field_info const& a, thinknode_structure_field_info const& b); void swap(thinknode_structure_field_info& a, thinknode_structure_field_info& b); size_t deep_sizeof(thinknode_structure_field_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_structure_field_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_structure_field_info const& x); void read_fields_from_record(thinknode_structure_field_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_structure_field_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_structure_field_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_structure_field_info const& x);size_t hash_value(thinknode_structure_field_info const& x);} namespace cradle { 

#line 278 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_structure_info { std::map<std::string,cradle::thinknode_structure_field_info > fields;  thinknode_structure_info() {} explicit thinknode_structure_info(std::map<std::string,cradle::thinknode_structure_field_info > const& fields) : fields(fields) {} };  inline thinknode_structure_info make_thinknode_structure_info(  std::map<std::string,cradle::thinknode_structure_field_info > fields ) { return thinknode_structure_info(  std::move(fields) ); }template<> struct definitive_type_info_query<thinknode_structure_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_structure_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_structure_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_structure_info const& a, thinknode_structure_info const& b); bool operator!=(thinknode_structure_info const& a, thinknode_structure_info const& b); bool operator<(thinknode_structure_info const& a, thinknode_structure_info const& b); void swap(thinknode_structure_info& a, thinknode_structure_info& b); size_t deep_sizeof(thinknode_structure_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_structure_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_structure_info const& x); void read_fields_from_record(thinknode_structure_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_structure_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_structure_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_structure_info const& x);size_t hash_value(thinknode_structure_info const& x);} namespace cradle { 

#line 284 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_union_member_info { std::string description;  cradle::thinknode_type_info schema;  thinknode_union_member_info() {} thinknode_union_member_info(std::string const& description, cradle::thinknode_type_info const& schema) : description(description), schema(schema) {} };  inline thinknode_union_member_info make_thinknode_union_member_info(  std::string description, cradle::thinknode_type_info schema ) { return thinknode_union_member_info(  std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_union_member_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_union_member_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_union_member_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_union_member_info const& a, thinknode_union_member_info const& b); bool operator!=(thinknode_union_member_info const& a, thinknode_union_member_info const& b); bool operator<(thinknode_union_member_info const& a, thinknode_union_member_info const& b); void swap(thinknode_union_member_info& a, thinknode_union_member_info& b); size_t deep_sizeof(thinknode_union_member_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_union_member_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_union_member_info const& x); void read_fields_from_record(thinknode_union_member_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_union_member_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_union_member_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_union_member_info const& x);size_t hash_value(thinknode_union_member_info const& x);} namespace cradle { 

#line 291 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_union_info { std::map<std::string,cradle::thinknode_union_member_info > members;  thinknode_union_info() {} explicit thinknode_union_info(std::map<std::string,cradle::thinknode_union_member_info > const& members) : members(members) {} };  inline thinknode_union_info make_thinknode_union_info(  std::map<std::string,cradle::thinknode_union_member_info > members ) { return thinknode_union_info(  std::move(members) ); }template<> struct definitive_type_info_query<thinknode_union_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_union_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_union_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_union_info const& a, thinknode_union_info const& b); bool operator!=(thinknode_union_info const& a, thinknode_union_info const& b); bool operator<(thinknode_union_info const& a, thinknode_union_info const& b); void swap(thinknode_union_info& a, thinknode_union_info& b); size_t deep_sizeof(thinknode_union_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_union_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_union_info const& x); void read_fields_from_record(thinknode_union_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_union_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_union_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_union_info const& x);size_t hash_value(thinknode_union_info const& x);} namespace cradle { 

#line 297 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_enum_value_info { std::string description;  thinknode_enum_value_info() {} explicit thinknode_enum_value_info(std::string const& description) : description(description) {} };  inline thinknode_enum_value_info make_thinknode_enum_value_info(  std::string description ) { return thinknode_enum_value_info(  std::move(description) ); }template<> struct definitive_type_info_query<thinknode_enum_value_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_enum_value_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_enum_value_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_enum_value_info const& a, thinknode_enum_value_info const& b); bool operator!=(thinknode_enum_value_info const& a, thinknode_enum_value_info const& b); bool operator<(thinknode_enum_value_info const& a, thinknode_enum_value_info const& b); void swap(thinknode_enum_value_info& a, thinknode_enum_value_info& b); size_t deep_sizeof(thinknode_enum_value_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_enum_value_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_enum_value_info const& x); void read_fields_from_record(thinknode_enum_value_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_enum_value_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_enum_value_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_enum_value_info const& x);size_t hash_value(thinknode_enum_value_info const& x);} namespace cradle { 

#line 303 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_enum_info { std::map<std::string,cradle::thinknode_enum_value_info > values;  thinknode_enum_info() {} explicit thinknode_enum_info(std::map<std::string,cradle::thinknode_enum_value_info > const& values) : values(values) {} };  inline thinknode_enum_info make_thinknode_enum_info(  std::map<std::string,cradle::thinknode_enum_value_info > values ) { return thinknode_enum_info(  std::move(values) ); }template<> struct definitive_type_info_query<thinknode_enum_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_enum_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_enum_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_enum_info const& a, thinknode_enum_info const& b); bool operator!=(thinknode_enum_info const& a, thinknode_enum_info const& b); bool operator<(thinknode_enum_info const& a, thinknode_enum_info const& b); void swap(thinknode_enum_info& a, thinknode_enum_info& b); size_t deep_sizeof(thinknode_enum_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_enum_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_enum_info const& x); void read_fields_from_record(thinknode_enum_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_enum_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_enum_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_enum_info const& x);size_t hash_value(thinknode_enum_info const& x);} namespace cradle { 

#line 309 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_array_info { cradle::thinknode_type_info element_schema;  omissible<cradle::integer > size;  thinknode_array_info() {} thinknode_array_info(cradle::thinknode_type_info const& element_schema, omissible<cradle::integer > const& size) : element_schema(element_schema), size(size) {} };  inline thinknode_array_info make_thinknode_array_info(  cradle::thinknode_type_info element_schema, omissible<cradle::integer > size ) { return thinknode_array_info(  std::move(element_schema), std::move(size) ); }template<> struct definitive_type_info_query<thinknode_array_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_array_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_array_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_array_info const& a, thinknode_array_info const& b); bool operator!=(thinknode_array_info const& a, thinknode_array_info const& b); bool operator<(thinknode_array_info const& a, thinknode_array_info const& b); void swap(thinknode_array_info& a, thinknode_array_info& b); size_t deep_sizeof(thinknode_array_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_array_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_array_info const& x); void read_fields_from_record(thinknode_array_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_array_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_array_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_array_info const& x);size_t hash_value(thinknode_array_info const& x);} namespace cradle { 

#line 317 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_map_info { cradle::thinknode_type_info key_schema;  cradle::thinknode_type_info value_schema;  thinknode_map_info() {} thinknode_map_info(cradle::thinknode_type_info const& key_schema, cradle::thinknode_type_info const& value_schema) : key_schema(key_schema), value_schema(value_schema) {} };  inline thinknode_map_info make_thinknode_map_info(  cradle::thinknode_type_info key_schema, cradle::thinknode_type_info value_schema ) { return thinknode_map_info(  std::move(key_schema), std::move(value_schema) ); }template<> struct definitive_type_info_query<thinknode_map_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_map_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_map_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_map_info const& a, thinknode_map_info const& b); bool operator!=(thinknode_map_info const& a, thinknode_map_info const& b); bool operator<(thinknode_map_info const& a, thinknode_map_info const& b); void swap(thinknode_map_info& a, thinknode_map_info& b); size_t deep_sizeof(thinknode_map_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_map_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_map_info const& x); void read_fields_from_record(thinknode_map_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_map_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_map_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_map_info const& x);size_t hash_value(thinknode_map_info const& x);} namespace cradle { 

#line 324 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_named_type_reference { omissible<std::string > account;  std::string app;  std::string name;  thinknode_named_type_reference() {} thinknode_named_type_reference(omissible<std::string > const& account, std::string const& app, std::string const& name) : account(account), app(app), name(name) {} };  inline thinknode_named_type_reference make_thinknode_named_type_reference(  omissible<std::string > account, std::string app, std::string name ) { return thinknode_named_type_reference(  std::move(account), std::move(app), std::move(name) ); }template<> struct definitive_type_info_query<thinknode_named_type_reference> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_named_type_reference> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_named_type_reference> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_named_type_reference const& a, thinknode_named_type_reference const& b); bool operator!=(thinknode_named_type_reference const& a, thinknode_named_type_reference const& b); bool operator<(thinknode_named_type_reference const& a, thinknode_named_type_reference const& b); void swap(thinknode_named_type_reference& a, thinknode_named_type_reference& b); size_t deep_sizeof(thinknode_named_type_reference const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_named_type_reference const& x); void to_dynamic(cradle::dynamic* v, thinknode_named_type_reference const& x); void read_fields_from_record(thinknode_named_type_reference& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_named_type_reference* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_named_type_reference const& x);std::ostream& operator<<(std::ostream& s, thinknode_named_type_reference const& x);size_t hash_value(thinknode_named_type_reference const& x);} namespace cradle { 

#line 332 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_function_parameter_info { std::string name;  std::string description;  cradle::thinknode_type_info schema;  thinknode_function_parameter_info() {} thinknode_function_parameter_info(std::string const& name, std::string const& description, cradle::thinknode_type_info const& schema) : name(name), description(description), schema(schema) {} };  inline thinknode_function_parameter_info make_thinknode_function_parameter_info(  std::string name, std::string description, cradle::thinknode_type_info schema ) { return thinknode_function_parameter_info(  std::move(name), std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_function_parameter_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_parameter_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_function_parameter_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_function_parameter_info const& a, thinknode_function_parameter_info const& b); bool operator!=(thinknode_function_parameter_info const& a, thinknode_function_parameter_info const& b); bool operator<(thinknode_function_parameter_info const& a, thinknode_function_parameter_info const& b); void swap(thinknode_function_parameter_info& a, thinknode_function_parameter_info& b); size_t deep_sizeof(thinknode_function_parameter_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_parameter_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_function_parameter_info const& x); void read_fields_from_record(thinknode_function_parameter_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_function_parameter_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_function_parameter_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_function_parameter_info const& x);size_t hash_value(thinknode_function_parameter_info const& x);} namespace cradle { 

#line 340 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_function_result_info { std::string description;  cradle::thinknode_type_info schema;  thinknode_function_result_info() {} thinknode_function_result_info(std::string const& description, cradle::thinknode_type_info const& schema) : description(description), schema(schema) {} };  inline thinknode_function_result_info make_thinknode_function_result_info(  std::string description, cradle::thinknode_type_info schema ) { return thinknode_function_result_info(  std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_function_result_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_result_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_function_result_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_function_result_info const& a, thinknode_function_result_info const& b); bool operator!=(thinknode_function_result_info const& a, thinknode_function_result_info const& b); bool operator<(thinknode_function_result_info const& a, thinknode_function_result_info const& b); void swap(thinknode_function_result_info& a, thinknode_function_result_info& b); size_t deep_sizeof(thinknode_function_result_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_result_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_function_result_info const& x); void read_fields_from_record(thinknode_function_result_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_function_result_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_function_result_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_function_result_info const& x);size_t hash_value(thinknode_function_result_info const& x);} namespace cradle { 

#line 347 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_function_type_info { std::vector<cradle::thinknode_function_parameter_info > parameters;  cradle::thinknode_function_result_info returns;  thinknode_function_type_info() {} thinknode_function_type_info(std::vector<cradle::thinknode_function_parameter_info > const& parameters, cradle::thinknode_function_result_info const& returns) : parameters(parameters), returns(returns) {} };  inline thinknode_function_type_info make_thinknode_function_type_info(  std::vector<cradle::thinknode_function_parameter_info > parameters, cradle::thinknode_function_result_info returns ) { return thinknode_function_type_info(  std::move(parameters), std::move(returns) ); }template<> struct definitive_type_info_query<thinknode_function_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_function_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_function_type_info const& a, thinknode_function_type_info const& b); bool operator!=(thinknode_function_type_info const& a, thinknode_function_type_info const& b); bool operator<(thinknode_function_type_info const& a, thinknode_function_type_info const& b); void swap(thinknode_function_type_info& a, thinknode_function_type_info& b); size_t deep_sizeof(thinknode_function_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_type_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_function_type_info const& x); void read_fields_from_record(thinknode_function_type_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_function_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_function_type_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_function_type_info const& x);size_t hash_value(thinknode_function_type_info const& x);} namespace cradle { 


#ifdef FUNCTION_TYPE 
    #undef FUNCTION_TYPE 
#endif 
#line 354 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_function_type_tag { FUNCTION_TYPE }; template<> struct definitive_type_info_query<thinknode_function_type_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_type_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_function_type_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_function_type_tag) { return sizeof(thinknode_function_type_tag); } inline size_t hash_value(thinknode_function_type_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_function_type_tag) { return 1; } char const* get_value_id(thinknode_function_type_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_function_type_tag x); void from_dynamic(     thinknode_function_type_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_function_type_tag const& x); struct thinknode_function_type { thinknode_function_type_tag type; std::any contents_; thinknode_function_type() {} thinknode_function_type(thinknode_function_type const& other) : type(other.type), contents_(other.contents_) {} thinknode_function_type(thinknode_function_type&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_function_type& operator=(thinknode_function_type const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_function_type& operator=(thinknode_function_type&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_function_type> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_type> {     static void     get(cradle::api_type_info*); }; thinknode_function_type make_thinknode_function_type_with_function_type(thinknode_function_type_info const& x); thinknode_function_type make_thinknode_function_type_with_function_type(thinknode_function_type_info&& x); static inline thinknode_function_type_tag  get_tag(thinknode_function_type const& x) { return x.type; } bool static inline is_function_type(thinknode_function_type const& x) { return x.type == thinknode_function_type_tag::FUNCTION_TYPE; } thinknode_function_type_info const& as_function_type(thinknode_function_type const& x); thinknode_function_type_info& as_function_type(thinknode_function_type& x); void set_to_function_type(thinknode_function_type& x, thinknode_function_type_info const& y); void set_to_function_type(thinknode_function_type& x, thinknode_function_type_info&& y); bool operator==(thinknode_function_type const& a, thinknode_function_type const& b); bool operator!=(thinknode_function_type const& a, thinknode_function_type const& b); bool operator<(thinknode_function_type const& a, thinknode_function_type const& b); size_t hash_value(thinknode_function_type const& x);void swap(thinknode_function_type& a, thinknode_function_type& b); void to_dynamic(cradle::dynamic* v, thinknode_function_type const& x); void from_dynamic(thinknode_function_type* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_function_type const& x); size_t deep_sizeof(thinknode_function_type const& x); 

#line 360 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_function_info { std::string name;  std::string description;  std::string execution_class;  cradle::thinknode_function_type schema;  thinknode_function_info() {} thinknode_function_info(std::string const& name, std::string const& description, std::string const& execution_class, cradle::thinknode_function_type const& schema) : name(name), description(description), execution_class(execution_class), schema(schema) {} };  inline thinknode_function_info make_thinknode_function_info(  std::string name, std::string description, std::string execution_class, cradle::thinknode_function_type schema ) { return thinknode_function_info(  std::move(name), std::move(description), std::move(execution_class), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_function_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_function_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_function_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_function_info const& a, thinknode_function_info const& b); bool operator!=(thinknode_function_info const& a, thinknode_function_info const& b); bool operator<(thinknode_function_info const& a, thinknode_function_info const& b); void swap(thinknode_function_info& a, thinknode_function_info& b); size_t deep_sizeof(thinknode_function_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_function_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_function_info const& x); void read_fields_from_record(thinknode_function_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_function_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_function_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_function_info const& x);size_t hash_value(thinknode_function_info const& x);} namespace cradle { 

#line 369 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_named_type_info { std::string name;  std::string description;  cradle::thinknode_type_info schema;  thinknode_named_type_info() {} thinknode_named_type_info(std::string const& name, std::string const& description, cradle::thinknode_type_info const& schema) : name(name), description(description), schema(schema) {} };  inline thinknode_named_type_info make_thinknode_named_type_info(  std::string name, std::string description, cradle::thinknode_type_info schema ) { return thinknode_named_type_info(  std::move(name), std::move(description), std::move(schema) ); }template<> struct definitive_type_info_query<thinknode_named_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_named_type_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_named_type_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_named_type_info const& a, thinknode_named_type_info const& b); bool operator!=(thinknode_named_type_info const& a, thinknode_named_type_info const& b); bool operator<(thinknode_named_type_info const& a, thinknode_named_type_info const& b); void swap(thinknode_named_type_info& a, thinknode_named_type_info& b); size_t deep_sizeof(thinknode_named_type_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_named_type_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_named_type_info const& x); void read_fields_from_record(thinknode_named_type_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_named_type_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_named_type_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_named_type_info const& x);size_t hash_value(thinknode_named_type_info const& x);} namespace cradle { 


#ifdef TAG 
    #undef TAG 
#endif 

#ifdef DIGEST 
    #undef DIGEST 
#endif 
#line 377 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_provider_image_info_tag { TAG,DIGEST }; template<> struct definitive_type_info_query<thinknode_provider_image_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_image_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_provider_image_info_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_provider_image_info_tag) { return sizeof(thinknode_provider_image_info_tag); } inline size_t hash_value(thinknode_provider_image_info_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_provider_image_info_tag) { return 2; } char const* get_value_id(thinknode_provider_image_info_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_provider_image_info_tag x); void from_dynamic(     thinknode_provider_image_info_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_provider_image_info_tag const& x); struct thinknode_provider_image_info { thinknode_provider_image_info_tag type; std::any contents_; thinknode_provider_image_info() {} thinknode_provider_image_info(thinknode_provider_image_info const& other) : type(other.type), contents_(other.contents_) {} thinknode_provider_image_info(thinknode_provider_image_info&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_provider_image_info& operator=(thinknode_provider_image_info const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_provider_image_info& operator=(thinknode_provider_image_info&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_provider_image_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_image_info> {     static void     get(cradle::api_type_info*); }; thinknode_provider_image_info make_thinknode_provider_image_info_with_tag(std::string const& x); thinknode_provider_image_info make_thinknode_provider_image_info_with_tag(std::string&& x); thinknode_provider_image_info make_thinknode_provider_image_info_with_digest(std::string const& x); thinknode_provider_image_info make_thinknode_provider_image_info_with_digest(std::string&& x); static inline thinknode_provider_image_info_tag  get_tag(thinknode_provider_image_info const& x) { return x.type; } bool static inline is_tag(thinknode_provider_image_info const& x) { return x.type == thinknode_provider_image_info_tag::TAG; } bool static inline is_digest(thinknode_provider_image_info const& x) { return x.type == thinknode_provider_image_info_tag::DIGEST; } std::string const& as_tag(thinknode_provider_image_info const& x); std::string const& as_digest(thinknode_provider_image_info const& x); std::string& as_tag(thinknode_provider_image_info& x); std::string& as_digest(thinknode_provider_image_info& x); void set_to_tag(thinknode_provider_image_info& x, std::string const& y); void set_to_tag(thinknode_provider_image_info& x, std::string&& y); void set_to_digest(thinknode_provider_image_info& x, std::string const& y); void set_to_digest(thinknode_provider_image_info& x, std::string&& y); bool operator==(thinknode_provider_image_info const& a, thinknode_provider_image_info const& b); bool operator!=(thinknode_provider_image_info const& a, thinknode_provider_image_info const& b); bool operator<(thinknode_provider_image_info const& a, thinknode_provider_image_info const& b); size_t hash_value(thinknode_provider_image_info const& x);void swap(thinknode_provider_image_info& a, thinknode_provider_image_info& b); void to_dynamic(cradle::dynamic* v, thinknode_provider_image_info const& x); void from_dynamic(thinknode_provider_image_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_provider_image_info const& x); size_t deep_sizeof(thinknode_provider_image_info const& x); 

#line 386 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_private_provider_info { cradle::thinknode_provider_image_info image;  thinknode_private_provider_info() {} explicit thinknode_private_provider_info(cradle::thinknode_provider_image_info const& image) : image(image) {} };  inline thinknode_private_provider_info make_thinknode_private_provider_info(  cradle::thinknode_provider_image_info image ) { return thinknode_private_provider_info(  std::move(image) ); }template<> struct definitive_type_info_query<thinknode_private_provider_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_private_provider_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_private_provider_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_private_provider_info const& a, thinknode_private_provider_info const& b); bool operator!=(thinknode_private_provider_info const& a, thinknode_private_provider_info const& b); bool operator<(thinknode_private_provider_info const& a, thinknode_private_provider_info const& b); void swap(thinknode_private_provider_info& a, thinknode_private_provider_info& b); size_t deep_sizeof(thinknode_private_provider_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_private_provider_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_private_provider_info const& x); void read_fields_from_record(thinknode_private_provider_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_private_provider_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_private_provider_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_private_provider_info const& x);size_t hash_value(thinknode_private_provider_info const& x);} namespace cradle { 


#ifdef PRIVATE 
    #undef PRIVATE 
#endif 
#line 392 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_provider_info_tag { PRIVATE }; template<> struct definitive_type_info_query<thinknode_provider_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_provider_info_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_provider_info_tag) { return sizeof(thinknode_provider_info_tag); } inline size_t hash_value(thinknode_provider_info_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_provider_info_tag) { return 1; } char const* get_value_id(thinknode_provider_info_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_provider_info_tag x); void from_dynamic(     thinknode_provider_info_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_provider_info_tag const& x); struct thinknode_provider_info { thinknode_provider_info_tag type; std::any contents_; thinknode_provider_info() {} thinknode_provider_info(thinknode_provider_info const& other) : type(other.type), contents_(other.contents_) {} thinknode_provider_info(thinknode_provider_info&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_provider_info& operator=(thinknode_provider_info const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_provider_info& operator=(thinknode_provider_info&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_provider_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_info> {     static void     get(cradle::api_type_info*); }; thinknode_provider_info make_thinknode_provider_info_with_private(thinknode_private_provider_info const& x); thinknode_provider_info make_thinknode_provider_info_with_private(thinknode_private_provider_info&& x); static inline thinknode_provider_info_tag  get_tag(thinknode_provider_info const& x) { return x.type; } bool static inline is_private(thinknode_provider_info const& x) { return x.type == thinknode_provider_info_tag::PRIVATE; } thinknode_private_provider_info const& as_private(thinknode_provider_info const& x); thinknode_private_provider_info& as_private(thinknode_provider_info& x); void set_to_private(thinknode_provider_info& x, thinknode_private_provider_info const& y); void set_to_private(thinknode_provider_info& x, thinknode_private_provider_info&& y); bool operator==(thinknode_provider_info const& a, thinknode_provider_info const& b); bool operator!=(thinknode_provider_info const& a, thinknode_provider_info const& b); bool operator<(thinknode_provider_info const& a, thinknode_provider_info const& b); size_t hash_value(thinknode_provider_info const& x);void swap(thinknode_provider_info& a, thinknode_provider_info& b); void to_dynamic(cradle::dynamic* v, thinknode_provider_info const& x); void from_dynamic(thinknode_provider_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_provider_info const& x); size_t deep_sizeof(thinknode_provider_info const& x); 

#line 398 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_app_manifest { std::vector<cradle::dynamic > dependencies;  omissible<cradle::thinknode_provider_info > provider;  std::vector<cradle::thinknode_named_type_info > types;  std::vector<cradle::thinknode_function_info > functions;  std::vector<cradle::dynamic > records;  std::vector<cradle::dynamic > upgrades;  thinknode_app_manifest() {} thinknode_app_manifest(std::vector<cradle::dynamic > const& dependencies, omissible<cradle::thinknode_provider_info > const& provider, std::vector<cradle::thinknode_named_type_info > const& types, std::vector<cradle::thinknode_function_info > const& functions, std::vector<cradle::dynamic > const& records, std::vector<cradle::dynamic > const& upgrades) : dependencies(dependencies), provider(provider), types(types), functions(functions), records(records), upgrades(upgrades) {} };  inline thinknode_app_manifest make_thinknode_app_manifest(  std::vector<cradle::dynamic > dependencies, omissible<cradle::thinknode_provider_info > provider, std::vector<cradle::thinknode_named_type_info > types, std::vector<cradle::thinknode_function_info > functions, std::vector<cradle::dynamic > records, std::vector<cradle::dynamic > upgrades ) { return thinknode_app_manifest(  std::move(dependencies), std::move(provider), std::move(types), std::move(functions), std::move(records), std::move(upgrades) ); }template<> struct definitive_type_info_query<thinknode_app_manifest> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_app_manifest> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_app_manifest> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_app_manifest const& a, thinknode_app_manifest const& b); bool operator!=(thinknode_app_manifest const& a, thinknode_app_manifest const& b); bool operator<(thinknode_app_manifest const& a, thinknode_app_manifest const& b); void swap(thinknode_app_manifest& a, thinknode_app_manifest& b); size_t deep_sizeof(thinknode_app_manifest const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_app_manifest const& x); void to_dynamic(cradle::dynamic* v, thinknode_app_manifest const& x); void read_fields_from_record(thinknode_app_manifest& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_app_manifest* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_app_manifest const& x);std::ostream& operator<<(std::ostream& s, thinknode_app_manifest const& x);size_t hash_value(thinknode_app_manifest const& x);} namespace cradle { 

#line 417 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_app_version_info { std::string name;  omissible<cradle::thinknode_app_manifest > manifest;  cradle::dynamic created_by;  boost::posix_time::ptime created_at;  thinknode_app_version_info() {} thinknode_app_version_info(std::string const& name, omissible<cradle::thinknode_app_manifest > const& manifest, cradle::dynamic const& created_by, boost::posix_time::ptime const& created_at) : name(name), manifest(manifest), created_by(created_by), created_at(created_at) {} };  inline thinknode_app_version_info make_thinknode_app_version_info(  std::string name, omissible<cradle::thinknode_app_manifest > manifest, cradle::dynamic created_by, boost::posix_time::ptime created_at ) { return thinknode_app_version_info(  std::move(name), std::move(manifest), std::move(created_by), std::move(created_at) ); }template<> struct definitive_type_info_query<thinknode_app_version_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_app_version_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_app_version_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_app_version_info const& a, thinknode_app_version_info const& b); bool operator!=(thinknode_app_version_info const& a, thinknode_app_version_info const& b); bool operator<(thinknode_app_version_info const& a, thinknode_app_version_info const& b); void swap(thinknode_app_version_info& a, thinknode_app_version_info& b); size_t deep_sizeof(thinknode_app_version_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_app_version_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_app_version_info const& x); void read_fields_from_record(thinknode_app_version_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_app_version_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_app_version_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_app_version_info const& x);size_t hash_value(thinknode_app_version_info const& x);} namespace cradle { 


#ifdef VERSION 
    #undef VERSION 
#endif 

#ifdef BRANCH 
    #undef BRANCH 
#endif 

#ifdef COMMIT 
    #undef COMMIT 
#endif 
#line 430 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_app_source_info_tag { VERSION,BRANCH,COMMIT }; template<> struct definitive_type_info_query<thinknode_app_source_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_app_source_info_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_app_source_info_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_app_source_info_tag) { return sizeof(thinknode_app_source_info_tag); } inline size_t hash_value(thinknode_app_source_info_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_app_source_info_tag) { return 3; } char const* get_value_id(thinknode_app_source_info_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_app_source_info_tag x); void from_dynamic(     thinknode_app_source_info_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_app_source_info_tag const& x); struct thinknode_app_source_info { thinknode_app_source_info_tag type; std::any contents_; thinknode_app_source_info() {} thinknode_app_source_info(thinknode_app_source_info const& other) : type(other.type), contents_(other.contents_) {} thinknode_app_source_info(thinknode_app_source_info&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_app_source_info& operator=(thinknode_app_source_info const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_app_source_info& operator=(thinknode_app_source_info&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_app_source_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_app_source_info> {     static void     get(cradle::api_type_info*); }; thinknode_app_source_info make_thinknode_app_source_info_with_version(std::string const& x); thinknode_app_source_info make_thinknode_app_source_info_with_version(std::string&& x); thinknode_app_source_info make_thinknode_app_source_info_with_branch(std::string const& x); thinknode_app_source_info make_thinknode_app_source_info_with_branch(std::string&& x); thinknode_app_source_info make_thinknode_app_source_info_with_commit(std::string const& x); thinknode_app_source_info make_thinknode_app_source_info_with_commit(std::string&& x); static inline thinknode_app_source_info_tag  get_tag(thinknode_app_source_info const& x) { return x.type; } bool static inline is_version(thinknode_app_source_info const& x) { return x.type == thinknode_app_source_info_tag::VERSION; } bool static inline is_branch(thinknode_app_source_info const& x) { return x.type == thinknode_app_source_info_tag::BRANCH; } bool static inline is_commit(thinknode_app_source_info const& x) { return x.type == thinknode_app_source_info_tag::COMMIT; } std::string const& as_version(thinknode_app_source_info const& x); std::string const& as_branch(thinknode_app_source_info const& x); std::string const& as_commit(thinknode_app_source_info const& x); std::string& as_version(thinknode_app_source_info& x); std::string& as_branch(thinknode_app_source_info& x); std::string& as_commit(thinknode_app_source_info& x); void set_to_version(thinknode_app_source_info& x, std::string const& y); void set_to_version(thinknode_app_source_info& x, std::string&& y); void set_to_branch(thinknode_app_source_info& x, std::string const& y); void set_to_branch(thinknode_app_source_info& x, std::string&& y); void set_to_commit(thinknode_app_source_info& x, std::string const& y); void set_to_commit(thinknode_app_source_info& x, std::string&& y); bool operator==(thinknode_app_source_info const& a, thinknode_app_source_info const& b); bool operator!=(thinknode_app_source_info const& a, thinknode_app_source_info const& b); bool operator<(thinknode_app_source_info const& a, thinknode_app_source_info const& b); size_t hash_value(thinknode_app_source_info const& x);void swap(thinknode_app_source_info& a, thinknode_app_source_info& b); void to_dynamic(cradle::dynamic* v, thinknode_app_source_info const& x); void from_dynamic(thinknode_app_source_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_app_source_info const& x); size_t deep_sizeof(thinknode_app_source_info const& x); 

#line 444 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_context_app_info { std::string account;  std::string app;  cradle::thinknode_app_source_info source;  thinknode_context_app_info() {} thinknode_context_app_info(std::string const& account, std::string const& app, cradle::thinknode_app_source_info const& source) : account(account), app(app), source(source) {} };  inline thinknode_context_app_info make_thinknode_context_app_info(  std::string account, std::string app, cradle::thinknode_app_source_info source ) { return thinknode_context_app_info(  std::move(account), std::move(app), std::move(source) ); }template<> struct definitive_type_info_query<thinknode_context_app_info> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_context_app_info> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_context_app_info> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_context_app_info const& a, thinknode_context_app_info const& b); bool operator!=(thinknode_context_app_info const& a, thinknode_context_app_info const& b); bool operator<(thinknode_context_app_info const& a, thinknode_context_app_info const& b); void swap(thinknode_context_app_info& a, thinknode_context_app_info& b); size_t deep_sizeof(thinknode_context_app_info const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_context_app_info const& x); void to_dynamic(cradle::dynamic* v, thinknode_context_app_info const& x); void read_fields_from_record(thinknode_context_app_info& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_context_app_info* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_context_app_info const& x);std::ostream& operator<<(std::ostream& s, thinknode_context_app_info const& x);size_t hash_value(thinknode_context_app_info const& x);} namespace cradle { 

#line 454 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_context_contents { std::string bucket;  std::vector<cradle::thinknode_context_app_info > contents;  thinknode_context_contents() {} thinknode_context_contents(std::string const& bucket, std::vector<cradle::thinknode_context_app_info > const& contents) : bucket(bucket), contents(contents) {} };  inline thinknode_context_contents make_thinknode_context_contents(  std::string bucket, std::vector<cradle::thinknode_context_app_info > contents ) { return thinknode_context_contents(  std::move(bucket), std::move(contents) ); }template<> struct definitive_type_info_query<thinknode_context_contents> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_context_contents> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_context_contents> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_context_contents const& a, thinknode_context_contents const& b); bool operator!=(thinknode_context_contents const& a, thinknode_context_contents const& b); bool operator<(thinknode_context_contents const& a, thinknode_context_contents const& b); void swap(thinknode_context_contents& a, thinknode_context_contents& b); size_t deep_sizeof(thinknode_context_contents const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_context_contents const& x); void to_dynamic(cradle::dynamic* v, thinknode_context_contents const& x); void read_fields_from_record(thinknode_context_contents& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_context_contents* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_context_contents const& x);std::ostream& operator<<(std::ostream& s, thinknode_context_contents const& x);size_t hash_value(thinknode_context_contents const& x);} namespace cradle { 

#line 463 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_supervisor_calculation_request { std::string name;  std::vector<cradle::dynamic > args;  thinknode_supervisor_calculation_request() {} thinknode_supervisor_calculation_request(std::string const& name, std::vector<cradle::dynamic > const& args) : name(name), args(args) {} };  inline thinknode_supervisor_calculation_request make_thinknode_supervisor_calculation_request(  std::string name, std::vector<cradle::dynamic > args ) { return thinknode_supervisor_calculation_request(  std::move(name), std::move(args) ); }template<> struct definitive_type_info_query<thinknode_supervisor_calculation_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_supervisor_calculation_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_supervisor_calculation_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_supervisor_calculation_request const& a, thinknode_supervisor_calculation_request const& b); bool operator!=(thinknode_supervisor_calculation_request const& a, thinknode_supervisor_calculation_request const& b); bool operator<(thinknode_supervisor_calculation_request const& a, thinknode_supervisor_calculation_request const& b); void swap(thinknode_supervisor_calculation_request& a, thinknode_supervisor_calculation_request& b); size_t deep_sizeof(thinknode_supervisor_calculation_request const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_supervisor_calculation_request const& x); void to_dynamic(cradle::dynamic* v, thinknode_supervisor_calculation_request const& x); void read_fields_from_record(thinknode_supervisor_calculation_request& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_supervisor_calculation_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_supervisor_calculation_request const& x);std::ostream& operator<<(std::ostream& s, thinknode_supervisor_calculation_request const& x);size_t hash_value(thinknode_supervisor_calculation_request const& x);} namespace cradle { 


#ifdef FUNCTION 
    #undef FUNCTION 
#endif 

#ifdef PING 
    #undef PING 
#endif 
#line 472 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_supervisor_message_tag { FUNCTION,PING }; template<> struct definitive_type_info_query<thinknode_supervisor_message_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_supervisor_message_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_supervisor_message_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_supervisor_message_tag) { return sizeof(thinknode_supervisor_message_tag); } inline size_t hash_value(thinknode_supervisor_message_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_supervisor_message_tag) { return 2; } char const* get_value_id(thinknode_supervisor_message_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_supervisor_message_tag x); void from_dynamic(     thinknode_supervisor_message_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_supervisor_message_tag const& x); struct thinknode_supervisor_message { thinknode_supervisor_message_tag type; std::any contents_; thinknode_supervisor_message() {} thinknode_supervisor_message(thinknode_supervisor_message const& other) : type(other.type), contents_(other.contents_) {} thinknode_supervisor_message(thinknode_supervisor_message&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_supervisor_message& operator=(thinknode_supervisor_message const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_supervisor_message& operator=(thinknode_supervisor_message&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_supervisor_message> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_supervisor_message> {     static void     get(cradle::api_type_info*); }; thinknode_supervisor_message make_thinknode_supervisor_message_with_function(thinknode_supervisor_calculation_request const& x); thinknode_supervisor_message make_thinknode_supervisor_message_with_function(thinknode_supervisor_calculation_request&& x); thinknode_supervisor_message make_thinknode_supervisor_message_with_ping(std::string const& x); thinknode_supervisor_message make_thinknode_supervisor_message_with_ping(std::string&& x); static inline thinknode_supervisor_message_tag  get_tag(thinknode_supervisor_message const& x) { return x.type; } bool static inline is_function(thinknode_supervisor_message const& x) { return x.type == thinknode_supervisor_message_tag::FUNCTION; } bool static inline is_ping(thinknode_supervisor_message const& x) { return x.type == thinknode_supervisor_message_tag::PING; } thinknode_supervisor_calculation_request const& as_function(thinknode_supervisor_message const& x); std::string const& as_ping(thinknode_supervisor_message const& x); thinknode_supervisor_calculation_request& as_function(thinknode_supervisor_message& x); std::string& as_ping(thinknode_supervisor_message& x); void set_to_function(thinknode_supervisor_message& x, thinknode_supervisor_calculation_request const& y); void set_to_function(thinknode_supervisor_message& x, thinknode_supervisor_calculation_request&& y); void set_to_ping(thinknode_supervisor_message& x, std::string const& y); void set_to_ping(thinknode_supervisor_message& x, std::string&& y); bool operator==(thinknode_supervisor_message const& a, thinknode_supervisor_message const& b); bool operator!=(thinknode_supervisor_message const& a, thinknode_supervisor_message const& b); bool operator<(thinknode_supervisor_message const& a, thinknode_supervisor_message const& b); size_t hash_value(thinknode_supervisor_message const& x);void swap(thinknode_supervisor_message& a, thinknode_supervisor_message& b); void to_dynamic(cradle::dynamic* v, thinknode_supervisor_message const& x); void from_dynamic(thinknode_supervisor_message* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_supervisor_message const& x); size_t deep_sizeof(thinknode_supervisor_message const& x); 

#line 479 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_provider_progress_update { double value;  std::string message;  thinknode_provider_progress_update() {} thinknode_provider_progress_update(double const& value, std::string const& message) : value(value), message(message) {} };  inline thinknode_provider_progress_update make_thinknode_provider_progress_update(  double value, std::string message ) { return thinknode_provider_progress_update(  std::move(value), std::move(message) ); }template<> struct definitive_type_info_query<thinknode_provider_progress_update> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_progress_update> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_provider_progress_update> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_provider_progress_update const& a, thinknode_provider_progress_update const& b); bool operator!=(thinknode_provider_progress_update const& a, thinknode_provider_progress_update const& b); bool operator<(thinknode_provider_progress_update const& a, thinknode_provider_progress_update const& b); void swap(thinknode_provider_progress_update& a, thinknode_provider_progress_update& b); size_t deep_sizeof(thinknode_provider_progress_update const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_provider_progress_update const& x); void to_dynamic(cradle::dynamic* v, thinknode_provider_progress_update const& x); void read_fields_from_record(thinknode_provider_progress_update& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_provider_progress_update* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_provider_progress_update const& x);std::ostream& operator<<(std::ostream& s, thinknode_provider_progress_update const& x);size_t hash_value(thinknode_provider_progress_update const& x);} namespace cradle { 

#line 486 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_provider_failure { std::string code;  std::string message;  thinknode_provider_failure() {} thinknode_provider_failure(std::string const& code, std::string const& message) : code(code), message(message) {} };  inline thinknode_provider_failure make_thinknode_provider_failure(  std::string code, std::string message ) { return thinknode_provider_failure(  std::move(code), std::move(message) ); }template<> struct definitive_type_info_query<thinknode_provider_failure> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_failure> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_provider_failure> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_provider_failure const& a, thinknode_provider_failure const& b); bool operator!=(thinknode_provider_failure const& a, thinknode_provider_failure const& b); bool operator<(thinknode_provider_failure const& a, thinknode_provider_failure const& b); void swap(thinknode_provider_failure& a, thinknode_provider_failure& b); size_t deep_sizeof(thinknode_provider_failure const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_provider_failure const& x); void to_dynamic(cradle::dynamic* v, thinknode_provider_failure const& x); void read_fields_from_record(thinknode_provider_failure& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_provider_failure* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_provider_failure const& x);std::ostream& operator<<(std::ostream& s, thinknode_provider_failure const& x);size_t hash_value(thinknode_provider_failure const& x);} namespace cradle { 

#line 493 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} namespace cradle { struct thinknode_provider_registration { cradle::integer protocol;  std::string pid;  thinknode_provider_registration() {} thinknode_provider_registration(cradle::integer const& protocol, std::string const& pid) : protocol(protocol), pid(pid) {} };  inline thinknode_provider_registration make_thinknode_provider_registration(  cradle::integer protocol, std::string pid ) { return thinknode_provider_registration(  std::move(protocol), std::move(pid) ); }template<> struct definitive_type_info_query<thinknode_provider_registration> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_registration> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<thinknode_provider_registration> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(thinknode_provider_registration const& a, thinknode_provider_registration const& b); bool operator!=(thinknode_provider_registration const& a, thinknode_provider_registration const& b); bool operator<(thinknode_provider_registration const& a, thinknode_provider_registration const& b); void swap(thinknode_provider_registration& a, thinknode_provider_registration& b); size_t deep_sizeof(thinknode_provider_registration const& x); void write_fields_to_record(cradle::dynamic_map& record, thinknode_provider_registration const& x); void to_dynamic(cradle::dynamic* v, thinknode_provider_registration const& x); void read_fields_from_record(thinknode_provider_registration& x, cradle::dynamic_map const& record); void from_dynamic(thinknode_provider_registration* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_provider_registration const& x);std::ostream& operator<<(std::ostream& s, thinknode_provider_registration const& x);size_t hash_value(thinknode_provider_registration const& x);} namespace cradle { 


#ifdef REGISTRATION 
    #undef REGISTRATION 
#endif 

#ifdef PROGRESS 
    #undef PROGRESS 
#endif 

#ifdef PONG 
    #undef PONG 
#endif 

#ifdef RESULT 
    #undef RESULT 
#endif 

#ifdef FAILURE 
    #undef FAILURE 
#endif 
#line 502 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
enum class thinknode_provider_message_tag { REGISTRATION,PROGRESS,PONG,RESULT,FAILURE }; template<> struct definitive_type_info_query<thinknode_provider_message_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_message_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<thinknode_provider_message_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(thinknode_provider_message_tag) { return sizeof(thinknode_provider_message_tag); } inline size_t hash_value(thinknode_provider_message_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(thinknode_provider_message_tag) { return 5; } char const* get_value_id(thinknode_provider_message_tag value); void to_dynamic(     cradle::dynamic* v,     thinknode_provider_message_tag x); void from_dynamic(     thinknode_provider_message_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      thinknode_provider_message_tag const& x); struct thinknode_provider_message { thinknode_provider_message_tag type; std::any contents_; thinknode_provider_message() {} thinknode_provider_message(thinknode_provider_message const& other) : type(other.type), contents_(other.contents_) {} thinknode_provider_message(thinknode_provider_message&& other) : type(other.type), contents_(std::move(other.contents_)) {} thinknode_provider_message& operator=(thinknode_provider_message const& other) { type = other.type; contents_ = other.contents_; return *this; } thinknode_provider_message& operator=(thinknode_provider_message&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<thinknode_provider_message> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<thinknode_provider_message> {     static void     get(cradle::api_type_info*); }; thinknode_provider_message make_thinknode_provider_message_with_registration(thinknode_provider_registration const& x); thinknode_provider_message make_thinknode_provider_message_with_registration(thinknode_provider_registration&& x); thinknode_provider_message make_thinknode_provider_message_with_progress(thinknode_provider_progress_update const& x); thinknode_provider_message make_thinknode_provider_message_with_progress(thinknode_provider_progress_update&& x); thinknode_provider_message make_thinknode_provider_message_with_pong(std::string const& x); thinknode_provider_message make_thinknode_provider_message_with_pong(std::string&& x); thinknode_provider_message make_thinknode_provider_message_with_result(dynamic const& x); thinknode_provider_message make_thinknode_provider_message_with_result(dynamic&& x); thinknode_provider_message make_thinknode_provider_message_with_failure(thinknode_provider_failure const& x); thinknode_provider_message make_thinknode_provider_message_with_failure(thinknode_provider_failure&& x); static inline thinknode_provider_message_tag  get_tag(thinknode_provider_message const& x) { return x.type; } bool static inline is_registration(thinknode_provider_message const& x) { return x.type == thinknode_provider_message_tag::REGISTRATION; } bool static inline is_progress(thinknode_provider_message const& x) { return x.type == thinknode_provider_message_tag::PROGRESS; } bool static inline is_pong(thinknode_provider_message const& x) { return x.type == thinknode_provider_message_tag::PONG; } bool static inline is_result(thinknode_provider_message const& x) { return x.type == thinknode_provider_message_tag::RESULT; } bool static inline is_failure(thinknode_provider_message const& x) { return x.type == thinknode_provider_message_tag::FAILURE; } thinknode_provider_registration const& as_registration(thinknode_provider_message const& x); thinknode_provider_progress_update const& as_progress(thinknode_provider_message const& x); std::string const& as_pong(thinknode_provider_message const& x); dynamic const& as_result(thinknode_provider_message const& x); thinknode_provider_failure const& as_failure(thinknode_provider_message const& x); thinknode_provider_registration& as_registration(thinknode_provider_message& x); thinknode_provider_progress_update& as_progress(thinknode_provider_message& x); std::string& as_pong(thinknode_provider_message& x); dynamic& as_result(thinknode_provider_message& x); thinknode_provider_failure& as_failure(thinknode_provider_message& x); void set_to_registration(thinknode_provider_message& x, thinknode_provider_registration const& y); void set_to_registration(thinknode_provider_message& x, thinknode_provider_registration&& y); void set_to_progress(thinknode_provider_message& x, thinknode_provider_progress_update const& y); void set_to_progress(thinknode_provider_message& x, thinknode_provider_progress_update&& y); void set_to_pong(thinknode_provider_message& x, std::string const& y); void set_to_pong(thinknode_provider_message& x, std::string&& y); void set_to_result(thinknode_provider_message& x, dynamic const& y); void set_to_result(thinknode_provider_message& x, dynamic&& y); void set_to_failure(thinknode_provider_message& x, thinknode_provider_failure const& y); void set_to_failure(thinknode_provider_message& x, thinknode_provider_failure&& y); bool operator==(thinknode_provider_message const& a, thinknode_provider_message const& b); bool operator!=(thinknode_provider_message const& a, thinknode_provider_message const& b); bool operator<(thinknode_provider_message const& a, thinknode_provider_message const& b); size_t hash_value(thinknode_provider_message const& x);void swap(thinknode_provider_message& a, thinknode_provider_message& b); void to_dynamic(cradle::dynamic* v, thinknode_provider_message const& x); void from_dynamic(thinknode_provider_message* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, thinknode_provider_message const& x); size_t deep_sizeof(thinknode_provider_message const& x); 

#line 512 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
} // namespace cradle

#line 514 "/home/runner/work/cradle/cradle/src/cradle/thinknode/types.hpp"
#endif
