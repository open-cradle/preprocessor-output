// THIS FILE WAS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
// DO NOT EDIT!

#ifndef THINKNODE_ACCOUNT
#define THINKNODE_ACCOUNT "mgh"
#endif
#ifndef THINKNODE_FUNCTION_APP
#define THINKNODE_FUNCTION_APP "dosimetry"
#endif
#ifndef THINKNODE_TYPES_APP
#define THINKNODE_TYPES_APP "dosimetry"
#endif
#include <cradle/typing/core/preprocessed.h>









#ifdef REFERENCE 
    #undef REFERENCE 
#endif 

#ifdef VALUE 
    #undef VALUE 
#endif 

#ifdef LAMBDA 
    #undef LAMBDA 
#endif 

#ifdef FUNCTION 
    #undef FUNCTION 
#endif 

#ifdef ARRAY 
    #undef ARRAY 
#endif 

#ifdef ITEM 
    #undef ITEM 
#endif 

#ifdef OBJECT 
    #undef OBJECT 
#endif 

#ifdef PROPERTY 
    #undef PROPERTY 
#endif 

#ifdef LET 
    #undef LET 
#endif 

#ifdef VARIABLE 
    #undef VARIABLE 
#endif 

#ifdef META 
    #undef META 
#endif 

#ifdef CAST 
    #undef CAST 
#endif 



#ifdef ANY 
    #undef ANY 
#endif 

#ifdef THINKNODE 
    #undef THINKNODE 
#endif 

#ifdef LOCAL 
    #undef LOCAL 
#endif 


























#line 1 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
#ifndef CRADLE_WEBSOCKET_TYPES_HPP
#define CRADLE_WEBSOCKET_TYPES_HPP

#line 4 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
#include <cradle/thinknode/types.hpp>
#include <cradle/websocket/sample_lambdas.h>

#line 7 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
namespace cradle {

#line 9 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
class tasklet_tracker;
struct lambda_calculation;
struct function_application;
struct array_calc_request;
struct item_calc_request;
struct object_calc_request;
struct property_calc_request;
struct let_calc_request;
struct meta_calc_request;
struct cast_calc_request;


#ifdef REFERENCE 
    #undef REFERENCE 
#endif 

#ifdef VALUE 
    #undef VALUE 
#endif 

#ifdef LAMBDA 
    #undef LAMBDA 
#endif 

#ifdef FUNCTION 
    #undef FUNCTION 
#endif 

#ifdef ARRAY 
    #undef ARRAY 
#endif 

#ifdef ITEM 
    #undef ITEM 
#endif 

#ifdef OBJECT 
    #undef OBJECT 
#endif 

#ifdef PROPERTY 
    #undef PROPERTY 
#endif 

#ifdef LET 
    #undef LET 
#endif 

#ifdef VARIABLE 
    #undef VARIABLE 
#endif 

#ifdef META 
    #undef META 
#endif 

#ifdef CAST 
    #undef CAST 
#endif 
#line 20 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
enum class calculation_request_tag { REFERENCE,VALUE,LAMBDA,FUNCTION,ARRAY,ITEM,OBJECT,PROPERTY,LET,VARIABLE,META,CAST }; template<> struct definitive_type_info_query<calculation_request_tag> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_request_tag> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<calculation_request_tag> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(calculation_request_tag) { return sizeof(calculation_request_tag); } inline size_t hash_value(calculation_request_tag const& x) {     return size_t(x); }static inline unsigned get_value_count(calculation_request_tag) { return 12; } char const* get_value_id(calculation_request_tag value); void to_dynamic(     cradle::dynamic* v,     calculation_request_tag x); void from_dynamic(     calculation_request_tag* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      calculation_request_tag const& x); struct calculation_request { calculation_request_tag type; std::any contents_; calculation_request() {} calculation_request(calculation_request const& other) : type(other.type), contents_(other.contents_) {} calculation_request(calculation_request&& other) : type(other.type), contents_(std::move(other.contents_)) {} calculation_request& operator=(calculation_request const& other) { type = other.type; contents_ = other.contents_; return *this; } calculation_request& operator=(calculation_request&& other) { type = other.type; contents_ = std::move(other.contents_); return *this; } }; template<> struct definitive_type_info_query<calculation_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<calculation_request> {     static void     get(cradle::api_type_info*); }; calculation_request make_calculation_request_with_reference(std::string const& x); calculation_request make_calculation_request_with_reference(std::string&& x); calculation_request make_calculation_request_with_value(dynamic const& x); calculation_request make_calculation_request_with_value(dynamic&& x); calculation_request make_calculation_request_with_lambda(lambda_calculation const& x); calculation_request make_calculation_request_with_lambda(lambda_calculation&& x); calculation_request make_calculation_request_with_function(function_application const& x); calculation_request make_calculation_request_with_function(function_application&& x); calculation_request make_calculation_request_with_array(array_calc_request const& x); calculation_request make_calculation_request_with_array(array_calc_request&& x); calculation_request make_calculation_request_with_item(item_calc_request const& x); calculation_request make_calculation_request_with_item(item_calc_request&& x); calculation_request make_calculation_request_with_object(object_calc_request const& x); calculation_request make_calculation_request_with_object(object_calc_request&& x); calculation_request make_calculation_request_with_property(property_calc_request const& x); calculation_request make_calculation_request_with_property(property_calc_request&& x); calculation_request make_calculation_request_with_let(let_calc_request const& x); calculation_request make_calculation_request_with_let(let_calc_request&& x); calculation_request make_calculation_request_with_variable(std::string const& x); calculation_request make_calculation_request_with_variable(std::string&& x); calculation_request make_calculation_request_with_meta(meta_calc_request const& x); calculation_request make_calculation_request_with_meta(meta_calc_request&& x); calculation_request make_calculation_request_with_cast(cast_calc_request const& x); calculation_request make_calculation_request_with_cast(cast_calc_request&& x); static inline calculation_request_tag  get_tag(calculation_request const& x) { return x.type; } bool static inline is_reference(calculation_request const& x) { return x.type == calculation_request_tag::REFERENCE; } bool static inline is_value(calculation_request const& x) { return x.type == calculation_request_tag::VALUE; } bool static inline is_lambda(calculation_request const& x) { return x.type == calculation_request_tag::LAMBDA; } bool static inline is_function(calculation_request const& x) { return x.type == calculation_request_tag::FUNCTION; } bool static inline is_array(calculation_request const& x) { return x.type == calculation_request_tag::ARRAY; } bool static inline is_item(calculation_request const& x) { return x.type == calculation_request_tag::ITEM; } bool static inline is_object(calculation_request const& x) { return x.type == calculation_request_tag::OBJECT; } bool static inline is_property(calculation_request const& x) { return x.type == calculation_request_tag::PROPERTY; } bool static inline is_let(calculation_request const& x) { return x.type == calculation_request_tag::LET; } bool static inline is_variable(calculation_request const& x) { return x.type == calculation_request_tag::VARIABLE; } bool static inline is_meta(calculation_request const& x) { return x.type == calculation_request_tag::META; } bool static inline is_cast(calculation_request const& x) { return x.type == calculation_request_tag::CAST; } std::string const& as_reference(calculation_request const& x); dynamic const& as_value(calculation_request const& x); lambda_calculation const& as_lambda(calculation_request const& x); function_application const& as_function(calculation_request const& x); array_calc_request const& as_array(calculation_request const& x); item_calc_request const& as_item(calculation_request const& x); object_calc_request const& as_object(calculation_request const& x); property_calc_request const& as_property(calculation_request const& x); let_calc_request const& as_let(calculation_request const& x); std::string const& as_variable(calculation_request const& x); meta_calc_request const& as_meta(calculation_request const& x); cast_calc_request const& as_cast(calculation_request const& x); std::string& as_reference(calculation_request& x); dynamic& as_value(calculation_request& x); lambda_calculation& as_lambda(calculation_request& x); function_application& as_function(calculation_request& x); array_calc_request& as_array(calculation_request& x); item_calc_request& as_item(calculation_request& x); object_calc_request& as_object(calculation_request& x); property_calc_request& as_property(calculation_request& x); let_calc_request& as_let(calculation_request& x); std::string& as_variable(calculation_request& x); meta_calc_request& as_meta(calculation_request& x); cast_calc_request& as_cast(calculation_request& x); void set_to_reference(calculation_request& x, std::string const& y); void set_to_reference(calculation_request& x, std::string&& y); void set_to_value(calculation_request& x, dynamic const& y); void set_to_value(calculation_request& x, dynamic&& y); void set_to_lambda(calculation_request& x, lambda_calculation const& y); void set_to_lambda(calculation_request& x, lambda_calculation&& y); void set_to_function(calculation_request& x, function_application const& y); void set_to_function(calculation_request& x, function_application&& y); void set_to_array(calculation_request& x, array_calc_request const& y); void set_to_array(calculation_request& x, array_calc_request&& y); void set_to_item(calculation_request& x, item_calc_request const& y); void set_to_item(calculation_request& x, item_calc_request&& y); void set_to_object(calculation_request& x, object_calc_request const& y); void set_to_object(calculation_request& x, object_calc_request&& y); void set_to_property(calculation_request& x, property_calc_request const& y); void set_to_property(calculation_request& x, property_calc_request&& y); void set_to_let(calculation_request& x, let_calc_request const& y); void set_to_let(calculation_request& x, let_calc_request&& y); void set_to_variable(calculation_request& x, std::string const& y); void set_to_variable(calculation_request& x, std::string&& y); void set_to_meta(calculation_request& x, meta_calc_request const& y); void set_to_meta(calculation_request& x, meta_calc_request&& y); void set_to_cast(calculation_request& x, cast_calc_request const& y); void set_to_cast(calculation_request& x, cast_calc_request&& y); bool operator==(calculation_request const& a, calculation_request const& b); bool operator!=(calculation_request const& a, calculation_request const& b); bool operator<(calculation_request const& a, calculation_request const& b); size_t hash_value(calculation_request const& x);void swap(calculation_request& a, calculation_request& b); void to_dynamic(cradle::dynamic* v, calculation_request const& x); void from_dynamic(calculation_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, calculation_request const& x); size_t deep_sizeof(calculation_request const& x); 


#ifdef ANY 
    #undef ANY 
#endif 

#ifdef THINKNODE 
    #undef THINKNODE 
#endif 

#ifdef LOCAL 
    #undef LOCAL 
#endif 
#line 37 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
enum class execution_host_selection { ANY,THINKNODE,LOCAL }; template<> struct definitive_type_info_query<execution_host_selection> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<execution_host_selection> {     static void     get(cradle::api_type_info*); }; template<> struct enum_type_info_query<execution_host_selection> {     static void     get(cradle::api_enum_info*); }; static inline size_t deep_sizeof(execution_host_selection) { return sizeof(execution_host_selection); } inline size_t hash_value(execution_host_selection const& x) {     return size_t(x); }static inline unsigned get_value_count(execution_host_selection) { return 3; } char const* get_value_id(execution_host_selection value); void to_dynamic(     cradle::dynamic* v,     execution_host_selection x); void from_dynamic(     execution_host_selection* x,     cradle::dynamic const& v); std::ostream& operator<<(     std::ostream& s,      execution_host_selection const& x); 

#line 46 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct function_application { std::string account;  std::string app;  std::string name;  omissible<execution_host_selection > host;  omissible<cradle::integer > level;  std::vector<calculation_request > args;  function_application() {} function_application(std::string const& account, std::string const& app, std::string const& name, omissible<execution_host_selection > const& host, omissible<cradle::integer > const& level, std::vector<calculation_request > const& args) : account(account), app(app), name(name), host(host), level(level), args(args) {} };  inline function_application make_function_application(  std::string account, std::string app, std::string name, omissible<execution_host_selection > host, omissible<cradle::integer > level, std::vector<calculation_request > args ) { return function_application(  std::move(account), std::move(app), std::move(name), std::move(host), std::move(level), std::move(args) ); }template<> struct definitive_type_info_query<function_application> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<function_application> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<function_application> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(function_application const& a, function_application const& b); bool operator!=(function_application const& a, function_application const& b); bool operator<(function_application const& a, function_application const& b); void swap(function_application& a, function_application& b); size_t deep_sizeof(function_application const& x); void write_fields_to_record(cradle::dynamic_map& record, function_application const& x); void to_dynamic(cradle::dynamic* v, function_application const& x); void read_fields_from_record(function_application& x, cradle::dynamic_map const& record); void from_dynamic(function_application* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, function_application const& x);std::ostream& operator<<(std::ostream& s, function_application const& x);size_t hash_value(function_application const& x);} namespace cradle { 

#line 57 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
struct lambda_function
{
    captured_id id;
    std::function<dynamic(dynamic_array const& args, tasklet_tracker* tasklet)>
        object;
};
inline bool
operator<(lambda_function const& a, lambda_function const& b)
{
    return a.id < b.id;
}
inline bool
operator==(lambda_function const& a, lambda_function const& b)
{
    return a.id == b.id;
}
inline void
to_dynamic(dynamic* v, lambda_function const& x)
{
    throw "unimplemented";
}
inline void
from_dynamic(lambda_function* x, dynamic const& v)
{
    find_sample_lambda(x, v);
}
inline size_t
deep_sizeof(lambda_function const& x)
{
    return 0;
}
inline size_t
hash_value(lambda_function const& x)
{
    return x.id.hash();
}
template<>
struct type_info_query<lambda_function>
{
    static void
    get(api_type_info*)
    {
        throw "unimplemented";
    }
};

#line 103 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct lambda_calculation { lambda_function function;  std::vector<calculation_request > args;  lambda_calculation() {} lambda_calculation(lambda_function const& function, std::vector<calculation_request > const& args) : function(function), args(args) {} };  inline lambda_calculation make_lambda_calculation(  lambda_function function, std::vector<calculation_request > args ) { return lambda_calculation(  std::move(function), std::move(args) ); }template<> struct definitive_type_info_query<lambda_calculation> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<lambda_calculation> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<lambda_calculation> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(lambda_calculation const& a, lambda_calculation const& b); bool operator!=(lambda_calculation const& a, lambda_calculation const& b); bool operator<(lambda_calculation const& a, lambda_calculation const& b); void swap(lambda_calculation& a, lambda_calculation& b); size_t deep_sizeof(lambda_calculation const& x); void write_fields_to_record(cradle::dynamic_map& record, lambda_calculation const& x); void to_dynamic(cradle::dynamic* v, lambda_calculation const& x); void read_fields_from_record(lambda_calculation& x, cradle::dynamic_map const& record); void from_dynamic(lambda_calculation* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, lambda_calculation const& x);std::ostream& operator<<(std::ostream& s, lambda_calculation const& x);size_t hash_value(lambda_calculation const& x);} namespace cradle { 

#line 110 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct array_calc_request { std::vector<calculation_request > items;  cradle::thinknode_type_info item_schema;  array_calc_request() {} array_calc_request(std::vector<calculation_request > const& items, cradle::thinknode_type_info const& item_schema) : items(items), item_schema(item_schema) {} };  inline array_calc_request make_array_calc_request(  std::vector<calculation_request > items, cradle::thinknode_type_info item_schema ) { return array_calc_request(  std::move(items), std::move(item_schema) ); }template<> struct definitive_type_info_query<array_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<array_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<array_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(array_calc_request const& a, array_calc_request const& b); bool operator!=(array_calc_request const& a, array_calc_request const& b); bool operator<(array_calc_request const& a, array_calc_request const& b); void swap(array_calc_request& a, array_calc_request& b); size_t deep_sizeof(array_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, array_calc_request const& x); void to_dynamic(cradle::dynamic* v, array_calc_request const& x); void read_fields_from_record(array_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(array_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, array_calc_request const& x);std::ostream& operator<<(std::ostream& s, array_calc_request const& x);size_t hash_value(array_calc_request const& x);} namespace cradle { 

#line 117 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct object_calc_request { std::map<std::string,calculation_request > properties;  cradle::thinknode_type_info schema;  object_calc_request() {} object_calc_request(std::map<std::string,calculation_request > const& properties, cradle::thinknode_type_info const& schema) : properties(properties), schema(schema) {} };  inline object_calc_request make_object_calc_request(  std::map<std::string,calculation_request > properties, cradle::thinknode_type_info schema ) { return object_calc_request(  std::move(properties), std::move(schema) ); }template<> struct definitive_type_info_query<object_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<object_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<object_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(object_calc_request const& a, object_calc_request const& b); bool operator!=(object_calc_request const& a, object_calc_request const& b); bool operator<(object_calc_request const& a, object_calc_request const& b); void swap(object_calc_request& a, object_calc_request& b); size_t deep_sizeof(object_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, object_calc_request const& x); void to_dynamic(cradle::dynamic* v, object_calc_request const& x); void read_fields_from_record(object_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(object_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, object_calc_request const& x);std::ostream& operator<<(std::ostream& s, object_calc_request const& x);size_t hash_value(object_calc_request const& x);} namespace cradle { 

#line 124 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct item_calc_request { calculation_request array;  calculation_request index;  cradle::thinknode_type_info schema;  item_calc_request() {} item_calc_request(calculation_request const& array, calculation_request const& index, cradle::thinknode_type_info const& schema) : array(array), index(index), schema(schema) {} };  inline item_calc_request make_item_calc_request(  calculation_request array, calculation_request index, cradle::thinknode_type_info schema ) { return item_calc_request(  std::move(array), std::move(index), std::move(schema) ); }template<> struct definitive_type_info_query<item_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<item_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<item_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(item_calc_request const& a, item_calc_request const& b); bool operator!=(item_calc_request const& a, item_calc_request const& b); bool operator<(item_calc_request const& a, item_calc_request const& b); void swap(item_calc_request& a, item_calc_request& b); size_t deep_sizeof(item_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, item_calc_request const& x); void to_dynamic(cradle::dynamic* v, item_calc_request const& x); void read_fields_from_record(item_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(item_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, item_calc_request const& x);std::ostream& operator<<(std::ostream& s, item_calc_request const& x);size_t hash_value(item_calc_request const& x);} namespace cradle { 

#line 132 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct property_calc_request { calculation_request object;  calculation_request field;  cradle::thinknode_type_info schema;  property_calc_request() {} property_calc_request(calculation_request const& object, calculation_request const& field, cradle::thinknode_type_info const& schema) : object(object), field(field), schema(schema) {} };  inline property_calc_request make_property_calc_request(  calculation_request object, calculation_request field, cradle::thinknode_type_info schema ) { return property_calc_request(  std::move(object), std::move(field), std::move(schema) ); }template<> struct definitive_type_info_query<property_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<property_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<property_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(property_calc_request const& a, property_calc_request const& b); bool operator!=(property_calc_request const& a, property_calc_request const& b); bool operator<(property_calc_request const& a, property_calc_request const& b); void swap(property_calc_request& a, property_calc_request& b); size_t deep_sizeof(property_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, property_calc_request const& x); void to_dynamic(cradle::dynamic* v, property_calc_request const& x); void read_fields_from_record(property_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(property_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, property_calc_request const& x);std::ostream& operator<<(std::ostream& s, property_calc_request const& x);size_t hash_value(property_calc_request const& x);} namespace cradle { 

#line 140 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct meta_calc_request { calculation_request generator;  cradle::thinknode_type_info schema;  meta_calc_request() {} meta_calc_request(calculation_request const& generator, cradle::thinknode_type_info const& schema) : generator(generator), schema(schema) {} };  inline meta_calc_request make_meta_calc_request(  calculation_request generator, cradle::thinknode_type_info schema ) { return meta_calc_request(  std::move(generator), std::move(schema) ); }template<> struct definitive_type_info_query<meta_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<meta_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<meta_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(meta_calc_request const& a, meta_calc_request const& b); bool operator!=(meta_calc_request const& a, meta_calc_request const& b); bool operator<(meta_calc_request const& a, meta_calc_request const& b); void swap(meta_calc_request& a, meta_calc_request& b); size_t deep_sizeof(meta_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, meta_calc_request const& x); void to_dynamic(cradle::dynamic* v, meta_calc_request const& x); void read_fields_from_record(meta_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(meta_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, meta_calc_request const& x);std::ostream& operator<<(std::ostream& s, meta_calc_request const& x);size_t hash_value(meta_calc_request const& x);} namespace cradle { 

#line 147 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct cast_calc_request { cradle::thinknode_type_info schema;  calculation_request object;  cast_calc_request() {} cast_calc_request(cradle::thinknode_type_info const& schema, calculation_request const& object) : schema(schema), object(object) {} };  inline cast_calc_request make_cast_calc_request(  cradle::thinknode_type_info schema, calculation_request object ) { return cast_calc_request(  std::move(schema), std::move(object) ); }template<> struct definitive_type_info_query<cast_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<cast_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<cast_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(cast_calc_request const& a, cast_calc_request const& b); bool operator!=(cast_calc_request const& a, cast_calc_request const& b); bool operator<(cast_calc_request const& a, cast_calc_request const& b); void swap(cast_calc_request& a, cast_calc_request& b); size_t deep_sizeof(cast_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, cast_calc_request const& x); void to_dynamic(cradle::dynamic* v, cast_calc_request const& x); void read_fields_from_record(cast_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(cast_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, cast_calc_request const& x);std::ostream& operator<<(std::ostream& s, cast_calc_request const& x);size_t hash_value(cast_calc_request const& x);} namespace cradle { 

#line 154 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct let_calc_request { std::map<std::string,calculation_request > variables;  calculation_request in;  let_calc_request() {} let_calc_request(std::map<std::string,calculation_request > const& variables, calculation_request const& in) : variables(variables), in(in) {} };  inline let_calc_request make_let_calc_request(  std::map<std::string,calculation_request > variables, calculation_request in ) { return let_calc_request(  std::move(variables), std::move(in) ); }template<> struct definitive_type_info_query<let_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<let_calc_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<let_calc_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(let_calc_request const& a, let_calc_request const& b); bool operator!=(let_calc_request const& a, let_calc_request const& b); bool operator<(let_calc_request const& a, let_calc_request const& b); void swap(let_calc_request& a, let_calc_request& b); size_t deep_sizeof(let_calc_request const& x); void write_fields_to_record(cradle::dynamic_map& record, let_calc_request const& x); void to_dynamic(cradle::dynamic* v, let_calc_request const& x); void read_fields_from_record(let_calc_request& x, cradle::dynamic_map const& record); void from_dynamic(let_calc_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, let_calc_request const& x);std::ostream& operator<<(std::ostream& s, let_calc_request const& x);size_t hash_value(let_calc_request const& x);} namespace cradle { 

#line 161 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} namespace cradle { struct results_api_generated_request { std::string context_id;  optional<calculation_request > request;  results_api_generated_request() {} results_api_generated_request(std::string const& context_id, optional<calculation_request > const& request) : context_id(context_id), request(request) {} };  inline results_api_generated_request make_results_api_generated_request(  std::string context_id, optional<calculation_request > request ) { return results_api_generated_request(  std::move(context_id), std::move(request) ); }template<> struct definitive_type_info_query<results_api_generated_request> {     static void     get(cradle::api_type_info*); }; template<> struct type_info_query<results_api_generated_request> {     static void     get(cradle::api_type_info*); }; template<> struct structure_field_type_info_adder<results_api_generated_request> {     static void     add(std::map<std::string, cradle::api_structure_field_info>*); }; bool operator==(results_api_generated_request const& a, results_api_generated_request const& b); bool operator!=(results_api_generated_request const& a, results_api_generated_request const& b); bool operator<(results_api_generated_request const& a, results_api_generated_request const& b); void swap(results_api_generated_request& a, results_api_generated_request& b); size_t deep_sizeof(results_api_generated_request const& x); void write_fields_to_record(cradle::dynamic_map& record, results_api_generated_request const& x); void to_dynamic(cradle::dynamic* v, results_api_generated_request const& x); void read_fields_from_record(results_api_generated_request& x, cradle::dynamic_map const& record); void from_dynamic(results_api_generated_request* x, cradle::dynamic const& v); std::ostream& operator<<(std::ostream& s, results_api_generated_request const& x);std::ostream& operator<<(std::ostream& s, results_api_generated_request const& x);size_t hash_value(results_api_generated_request const& x);} namespace cradle { 

#line 168 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
} // namespace cradle

#line 170 "/home/runner/work/cradle/cradle/src/cradle/websocket/types.hpp"
#endif
